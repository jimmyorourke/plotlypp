// Copyright (c) 2025 Jimmy O'Rourke
// Licensed under and subject to the terms of the LICENSE file accompanying this distribution.
// Official repository: https://github.com/jimmyorourke/plotlypp

// Autogenerated by plotlypp/generator, from official Plotly sources.
// See https://plotly.com/graphing-libraries.
// Do not edit, changes may be overwritten!

#pragma once

namespace plotlypp {

std::string Layout::to_string(Calendar e) {
    switch(e) {
        case Calendar::CHINESE: return "chinese";
        case Calendar::COPTIC: return "coptic";
        case Calendar::DISCWORLD: return "discworld";
        case Calendar::ETHIOPIAN: return "ethiopian";
        case Calendar::GREGORIAN: return "gregorian";
        case Calendar::HEBREW: return "hebrew";
        case Calendar::ISLAMIC: return "islamic";
        case Calendar::JALALI: return "jalali";
        case Calendar::JULIAN: return "julian";
        case Calendar::MAYAN: return "mayan";
        case Calendar::NANAKSHAHI: return "nanakshahi";
        case Calendar::NEPALI: return "nepali";
        case Calendar::PERSIAN: return "persian";
        case Calendar::TAIWAN: return "taiwan";
        case Calendar::THAI: return "thai";
        case Calendar::UMMALQURA: return "ummalqura";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::to_string(Dragmode e) {
    switch(e) {
        case Dragmode::ZOOM: return "zoom";
        case Dragmode::PAN: return "pan";
        case Dragmode::SELECT: return "select";
        case Dragmode::LASSO: return "lasso";
        case Dragmode::DRAWCLOSEDPATH: return "drawclosedpath";
        case Dragmode::DRAWOPENPATH: return "drawopenpath";
        case Dragmode::DRAWLINE: return "drawline";
        case Dragmode::DRAWRECT: return "drawrect";
        case Dragmode::DRAWCIRCLE: return "drawcircle";
        case Dragmode::ORBIT: return "orbit";
        case Dragmode::TURNTABLE: return "turntable";
        case Dragmode::FALSE: return "False";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::to_string(Hoversubplots e) {
    switch(e) {
        case Hoversubplots::SINGLE: return "single";
        case Hoversubplots::OVERLAYING: return "overlaying";
        case Hoversubplots::AXIS: return "axis";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::to_string(Selectdirection e) {
    switch(e) {
        case Selectdirection::H: return "h";
        case Selectdirection::V: return "v";
        case Selectdirection::D: return "d";
        case Selectdirection::ANY: return "any";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout& Layout::activeselection(Activeselection f) {
    json["activeselection"] = std::move(f.json);
    return *this;
}

Layout& Layout::activeshape(Activeshape f) {
    json["activeshape"] = std::move(f.json);
    return *this;
}

Layout& Layout::annotations(Annotations f) {
    json["annotations"] = std::move(f.json);
    return *this;
}

Layout& Layout::autosize(bool f) {
    json["autosize"] = std::move(f);
    return *this;
}

Layout& Layout::autotypenumbers(std::string f) {
    json["autotypenumbers"] = std::move(f);
    return *this;
}

Layout& Layout::calendar(enum Calendar f) {
    json["calendar"] = to_string(f);
    return *this;
}

Layout& Layout::clickmode(std::string f) {
    json["clickmode"] = std::move(f);
    return *this;
}

Layout& Layout::coloraxis(Coloraxis f) {
    json["coloraxis"] = std::move(f.json);
    return *this;
}

Layout& Layout::colorscale(Colorscale f) {
    json["colorscale"] = std::move(f.json);
    return *this;
}

Layout& Layout::colorway(std::vector<std::string> f) {
    json["colorway"] = std::move(f);
    return *this;
}

template <typename T>
Layout& Layout::computed(T f) {
    json["computed"] = std::move(f);
    return *this;
}

template <typename T>
Layout& Layout::datarevision(T f) {
    json["datarevision"] = std::move(f);
    return *this;
}

Layout& Layout::dragmode(enum Dragmode f) {
    json["dragmode"] = to_string(f);
    return *this;
}

template <typename T>
Layout& Layout::editrevision(T f) {
    json["editrevision"] = std::move(f);
    return *this;
}

Layout& Layout::font(Font f) {
    json["font"] = std::move(f.json);
    return *this;
}

Layout& Layout::geo(Geo f) {
    json["geo"] = std::move(f.json);
    return *this;
}

Layout& Layout::grid(Grid f) {
    json["grid"] = std::move(f.json);
    return *this;
}

Layout& Layout::height(double f) {
    json["height"] = std::move(f);
    return *this;
}

Layout& Layout::hidesources(bool f) {
    json["hidesources"] = std::move(f);
    return *this;
}

Layout& Layout::hoverdistance(int f) {
    json["hoverdistance"] = std::move(f);
    return *this;
}

Layout& Layout::hoverlabel(Hoverlabel f) {
    json["hoverlabel"] = std::move(f.json);
    return *this;
}

Layout& Layout::hovermode(std::string f) {
    json["hovermode"] = std::move(f);
    return *this;
}

Layout& Layout::hoversubplots(enum Hoversubplots f) {
    json["hoversubplots"] = to_string(f);
    return *this;
}

Layout& Layout::images(Images f) {
    json["images"] = std::move(f.json);
    return *this;
}

Layout& Layout::legend(Legend f) {
    json["legend"] = std::move(f.json);
    return *this;
}

Layout& Layout::map(Map f) {
    json["map"] = std::move(f.json);
    return *this;
}

Layout& Layout::mapbox(Mapbox f) {
    json["mapbox"] = std::move(f.json);
    return *this;
}

Layout& Layout::margin(Margin f) {
    json["margin"] = std::move(f.json);
    return *this;
}

template <typename T>
Layout& Layout::meta(T f) {
    json["meta"] = std::move(f);
    return *this;
}
template <typename T>
Layout& Layout::meta(std::vector<T> f) {
    json["meta"] = std::move(f);
    return *this;
}

Layout& Layout::metasrc(std::string f) {
    json["metasrc"] = std::move(f);
    return *this;
}

Layout& Layout::minreducedheight(double f) {
    json["minreducedheight"] = std::move(f);
    return *this;
}

Layout& Layout::minreducedwidth(double f) {
    json["minreducedwidth"] = std::move(f);
    return *this;
}

Layout& Layout::modebar(Modebar f) {
    json["modebar"] = std::move(f.json);
    return *this;
}

Layout& Layout::newselection(Newselection f) {
    json["newselection"] = std::move(f.json);
    return *this;
}

Layout& Layout::newshape(Newshape f) {
    json["newshape"] = std::move(f.json);
    return *this;
}

Layout& Layout::paper_bgcolor(std::string f) {
    json["paper_bgcolor"] = std::move(f);
    return *this;
}

Layout& Layout::plot_bgcolor(std::string f) {
    json["plot_bgcolor"] = std::move(f);
    return *this;
}

Layout& Layout::polar(Polar f) {
    json["polar"] = std::move(f.json);
    return *this;
}

Layout& Layout::scene(Scene f) {
    json["scene"] = std::move(f.json);
    return *this;
}

Layout& Layout::selectdirection(enum Selectdirection f) {
    json["selectdirection"] = to_string(f);
    return *this;
}

template <typename T>
Layout& Layout::selectionrevision(T f) {
    json["selectionrevision"] = std::move(f);
    return *this;
}

Layout& Layout::selections(Selections f) {
    json["selections"] = std::move(f.json);
    return *this;
}

Layout& Layout::separators(std::string f) {
    json["separators"] = std::move(f);
    return *this;
}

Layout& Layout::shapes(Shapes f) {
    json["shapes"] = std::move(f.json);
    return *this;
}

Layout& Layout::showlegend(bool f) {
    json["showlegend"] = std::move(f);
    return *this;
}

Layout& Layout::sliders(Sliders f) {
    json["sliders"] = std::move(f.json);
    return *this;
}

Layout& Layout::smith(Smith f) {
    json["smith"] = std::move(f.json);
    return *this;
}

Layout& Layout::spikedistance(int f) {
    json["spikedistance"] = std::move(f);
    return *this;
}

template <typename T>
Layout& Layout::platoly_template(T f) {
    json["platoly_template"] = std::move(f);
    return *this;
}

Layout& Layout::ternary(Ternary f) {
    json["ternary"] = std::move(f.json);
    return *this;
}

Layout& Layout::title(Title f) {
    json["title"] = std::move(f.json);
    return *this;
}

Layout& Layout::transition(Transition f) {
    json["transition"] = std::move(f.json);
    return *this;
}

template <typename T>
Layout& Layout::uirevision(T f) {
    json["uirevision"] = std::move(f);
    return *this;
}

Layout& Layout::uniformtext(Uniformtext f) {
    json["uniformtext"] = std::move(f.json);
    return *this;
}

Layout& Layout::updatemenus(Updatemenus f) {
    json["updatemenus"] = std::move(f.json);
    return *this;
}

Layout& Layout::width(double f) {
    json["width"] = std::move(f);
    return *this;
}

Layout& Layout::xaxis(Xaxis f) {
    json["xaxis"] = std::move(f.json);
    return *this;
}

Layout& Layout::yaxis(Yaxis f) {
    json["yaxis"] = std::move(f.json);
    return *this;
}


Layout::Activeselection& Layout::Activeselection::fillcolor(std::string f) {
    json["fillcolor"] = std::move(f);
    return *this;
}

Layout::Activeselection& Layout::Activeselection::opacity(double f) {
    json["opacity"] = std::move(f);
    return *this;
}


Layout::Activeshape& Layout::Activeshape::fillcolor(std::string f) {
    json["fillcolor"] = std::move(f);
    return *this;
}

Layout::Activeshape& Layout::Activeshape::opacity(double f) {
    json["opacity"] = std::move(f);
    return *this;
}


Layout::Annotations& Layout::Annotations::annotation(Annotation f) {
    json["annotation"] = std::move(f.json);
    return *this;
}

std::string Layout::Annotations::Annotation::to_string(Align e) {
    switch(e) {
        case Align::LEFT: return "left";
        case Align::CENTER: return "center";
        case Align::RIGHT: return "right";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Annotations::Annotation::to_string(Clicktoshow e) {
    switch(e) {
        case Clicktoshow::FALSE: return "False";
        case Clicktoshow::ONOFF: return "onoff";
        case Clicktoshow::ONOUT: return "onout";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Annotations::Annotation::to_string(Valign e) {
    switch(e) {
        case Valign::TOP: return "top";
        case Valign::MIDDLE: return "middle";
        case Valign::BOTTOM: return "bottom";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Annotations::Annotation::to_string(Xanchor e) {
    switch(e) {
        case Xanchor::AUTO: return "auto";
        case Xanchor::LEFT: return "left";
        case Xanchor::CENTER: return "center";
        case Xanchor::RIGHT: return "right";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Annotations::Annotation::to_string(Yanchor e) {
    switch(e) {
        case Yanchor::AUTO: return "auto";
        case Yanchor::TOP: return "top";
        case Yanchor::MIDDLE: return "middle";
        case Yanchor::BOTTOM: return "bottom";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Annotations::Annotation& Layout::Annotations::Annotation::align(enum Align f) {
    json["align"] = to_string(f);
    return *this;
}

Layout::Annotations::Annotation& Layout::Annotations::Annotation::arrowcolor(std::string f) {
    json["arrowcolor"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation& Layout::Annotations::Annotation::arrowhead(int f) {
    json["arrowhead"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation& Layout::Annotations::Annotation::arrowside(std::string f) {
    json["arrowside"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation& Layout::Annotations::Annotation::arrowsize(double f) {
    json["arrowsize"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation& Layout::Annotations::Annotation::arrowwidth(double f) {
    json["arrowwidth"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Annotations::Annotation& Layout::Annotations::Annotation::ax(T f) {
    json["ax"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation& Layout::Annotations::Annotation::axref(std::string f) {
    json["axref"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Annotations::Annotation& Layout::Annotations::Annotation::ay(T f) {
    json["ay"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation& Layout::Annotations::Annotation::ayref(std::string f) {
    json["ayref"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation& Layout::Annotations::Annotation::bgcolor(std::string f) {
    json["bgcolor"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation& Layout::Annotations::Annotation::bordercolor(std::string f) {
    json["bordercolor"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation& Layout::Annotations::Annotation::borderpad(double f) {
    json["borderpad"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation& Layout::Annotations::Annotation::borderwidth(double f) {
    json["borderwidth"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation& Layout::Annotations::Annotation::captureevents(bool f) {
    json["captureevents"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation& Layout::Annotations::Annotation::clicktoshow(enum Clicktoshow f) {
    json["clicktoshow"] = to_string(f);
    return *this;
}

Layout::Annotations::Annotation& Layout::Annotations::Annotation::font(Font f) {
    json["font"] = std::move(f.json);
    return *this;
}

Layout::Annotations::Annotation& Layout::Annotations::Annotation::height(double f) {
    json["height"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation& Layout::Annotations::Annotation::hoverlabel(Hoverlabel f) {
    json["hoverlabel"] = std::move(f.json);
    return *this;
}

Layout::Annotations::Annotation& Layout::Annotations::Annotation::hovertext(std::string f) {
    json["hovertext"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation& Layout::Annotations::Annotation::name(std::string f) {
    json["name"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation& Layout::Annotations::Annotation::opacity(double f) {
    json["opacity"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation& Layout::Annotations::Annotation::showarrow(bool f) {
    json["showarrow"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation& Layout::Annotations::Annotation::standoff(double f) {
    json["standoff"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation& Layout::Annotations::Annotation::startarrowhead(int f) {
    json["startarrowhead"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation& Layout::Annotations::Annotation::startarrowsize(double f) {
    json["startarrowsize"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation& Layout::Annotations::Annotation::startstandoff(double f) {
    json["startstandoff"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation& Layout::Annotations::Annotation::templateitemname(std::string f) {
    json["templateitemname"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation& Layout::Annotations::Annotation::text(std::string f) {
    json["text"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation& Layout::Annotations::Annotation::textangle(double f) {
    json["textangle"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation& Layout::Annotations::Annotation::valign(enum Valign f) {
    json["valign"] = to_string(f);
    return *this;
}

Layout::Annotations::Annotation& Layout::Annotations::Annotation::visible(bool f) {
    json["visible"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation& Layout::Annotations::Annotation::width(double f) {
    json["width"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Annotations::Annotation& Layout::Annotations::Annotation::x(T f) {
    json["x"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation& Layout::Annotations::Annotation::xanchor(enum Xanchor f) {
    json["xanchor"] = to_string(f);
    return *this;
}

template <typename T>
Layout::Annotations::Annotation& Layout::Annotations::Annotation::xclick(T f) {
    json["xclick"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation& Layout::Annotations::Annotation::xref(std::string f) {
    json["xref"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation& Layout::Annotations::Annotation::xshift(double f) {
    json["xshift"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Annotations::Annotation& Layout::Annotations::Annotation::y(T f) {
    json["y"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation& Layout::Annotations::Annotation::yanchor(enum Yanchor f) {
    json["yanchor"] = to_string(f);
    return *this;
}

template <typename T>
Layout::Annotations::Annotation& Layout::Annotations::Annotation::yclick(T f) {
    json["yclick"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation& Layout::Annotations::Annotation::yref(std::string f) {
    json["yref"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation& Layout::Annotations::Annotation::yshift(double f) {
    json["yshift"] = std::move(f);
    return *this;
}

std::string Layout::Annotations::Annotation::Font::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Annotations::Annotation::Font& Layout::Annotations::Annotation::Font::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation::Font& Layout::Annotations::Annotation::Font::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation::Font& Layout::Annotations::Annotation::Font::lineposition(std::string f) {
    json["lineposition"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation::Font& Layout::Annotations::Annotation::Font::shadow(std::string f) {
    json["shadow"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation::Font& Layout::Annotations::Annotation::Font::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation::Font& Layout::Annotations::Annotation::Font::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Annotations::Annotation::Font& Layout::Annotations::Annotation::Font::textcase(std::string f) {
    json["textcase"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation::Font& Layout::Annotations::Annotation::Font::variant(std::string f) {
    json["variant"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation::Font& Layout::Annotations::Annotation::Font::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}


Layout::Annotations::Annotation::Hoverlabel& Layout::Annotations::Annotation::Hoverlabel::bgcolor(std::string f) {
    json["bgcolor"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation::Hoverlabel& Layout::Annotations::Annotation::Hoverlabel::bordercolor(std::string f) {
    json["bordercolor"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation::Hoverlabel& Layout::Annotations::Annotation::Hoverlabel::font(Font f) {
    json["font"] = std::move(f.json);
    return *this;
}

std::string Layout::Annotations::Annotation::Hoverlabel::Font::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Annotations::Annotation::Hoverlabel::Font& Layout::Annotations::Annotation::Hoverlabel::Font::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation::Hoverlabel::Font& Layout::Annotations::Annotation::Hoverlabel::Font::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation::Hoverlabel::Font& Layout::Annotations::Annotation::Hoverlabel::Font::lineposition(std::string f) {
    json["lineposition"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation::Hoverlabel::Font& Layout::Annotations::Annotation::Hoverlabel::Font::shadow(std::string f) {
    json["shadow"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation::Hoverlabel::Font& Layout::Annotations::Annotation::Hoverlabel::Font::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation::Hoverlabel::Font& Layout::Annotations::Annotation::Hoverlabel::Font::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Annotations::Annotation::Hoverlabel::Font& Layout::Annotations::Annotation::Hoverlabel::Font::textcase(std::string f) {
    json["textcase"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation::Hoverlabel::Font& Layout::Annotations::Annotation::Hoverlabel::Font::variant(std::string f) {
    json["variant"] = std::move(f);
    return *this;
}

Layout::Annotations::Annotation::Hoverlabel::Font& Layout::Annotations::Annotation::Hoverlabel::Font::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}


Layout::Coloraxis& Layout::Coloraxis::autocolorscale(bool f) {
    json["autocolorscale"] = std::move(f);
    return *this;
}

Layout::Coloraxis& Layout::Coloraxis::cauto(bool f) {
    json["cauto"] = std::move(f);
    return *this;
}

Layout::Coloraxis& Layout::Coloraxis::cmax(double f) {
    json["cmax"] = std::move(f);
    return *this;
}

Layout::Coloraxis& Layout::Coloraxis::cmid(double f) {
    json["cmid"] = std::move(f);
    return *this;
}

Layout::Coloraxis& Layout::Coloraxis::cmin(double f) {
    json["cmin"] = std::move(f);
    return *this;
}

Layout::Coloraxis& Layout::Coloraxis::colorbar(Colorbar f) {
    json["colorbar"] = std::move(f.json);
    return *this;
}

Layout::Coloraxis& Layout::Coloraxis::colorscale(std::string f) {
    json["colorscale"] = std::move(f);
    return *this;
}
Layout::Coloraxis& Layout::Coloraxis::colorscale(std::vector<std::pair<double, std::string>> f) {
    json["colorscale"] = std::move(f);
    return *this;
}

Layout::Coloraxis& Layout::Coloraxis::reversescale(bool f) {
    json["reversescale"] = std::move(f);
    return *this;
}

Layout::Coloraxis& Layout::Coloraxis::showscale(bool f) {
    json["showscale"] = std::move(f);
    return *this;
}

std::string Layout::Coloraxis::Colorbar::to_string(Exponentformat e) {
    switch(e) {
        case Exponentformat::NONE: return "none";
        case Exponentformat::E: return "E";
        case Exponentformat::POWER: return "power";
        case Exponentformat::SI: return "SI";
        case Exponentformat::B: return "B";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Coloraxis::Colorbar::to_string(Lenmode e) {
    switch(e) {
        case Lenmode::FRACTION: return "fraction";
        case Lenmode::PIXELS: return "pixels";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Coloraxis::Colorbar::to_string(Orientation e) {
    switch(e) {
        case Orientation::H: return "h";
        case Orientation::V: return "v";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Coloraxis::Colorbar::to_string(Showexponent e) {
    switch(e) {
        case Showexponent::ALL: return "all";
        case Showexponent::FIRST: return "first";
        case Showexponent::LAST: return "last";
        case Showexponent::NONE: return "none";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Coloraxis::Colorbar::to_string(Showtickprefix e) {
    switch(e) {
        case Showtickprefix::ALL: return "all";
        case Showtickprefix::FIRST: return "first";
        case Showtickprefix::LAST: return "last";
        case Showtickprefix::NONE: return "none";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Coloraxis::Colorbar::to_string(Showticksuffix e) {
    switch(e) {
        case Showticksuffix::ALL: return "all";
        case Showticksuffix::FIRST: return "first";
        case Showticksuffix::LAST: return "last";
        case Showticksuffix::NONE: return "none";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Coloraxis::Colorbar::to_string(Thicknessmode e) {
    switch(e) {
        case Thicknessmode::FRACTION: return "fraction";
        case Thicknessmode::PIXELS: return "pixels";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Coloraxis::Colorbar::to_string(Tickmode e) {
    switch(e) {
        case Tickmode::AUTO: return "auto";
        case Tickmode::LINEAR: return "linear";
        case Tickmode::ARRAY: return "array";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Coloraxis::Colorbar::to_string(Ticks e) {
    switch(e) {
        case Ticks::OUTSIDE: return "outside";
        case Ticks::INSIDE: return "inside";
        case Ticks::EMPTY: return "";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Coloraxis::Colorbar::to_string(Xanchor e) {
    switch(e) {
        case Xanchor::LEFT: return "left";
        case Xanchor::CENTER: return "center";
        case Xanchor::RIGHT: return "right";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Coloraxis::Colorbar::to_string(Xref e) {
    switch(e) {
        case Xref::CONTAINER: return "container";
        case Xref::PAPER: return "paper";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Coloraxis::Colorbar::to_string(Yanchor e) {
    switch(e) {
        case Yanchor::TOP: return "top";
        case Yanchor::MIDDLE: return "middle";
        case Yanchor::BOTTOM: return "bottom";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Coloraxis::Colorbar::to_string(Yref e) {
    switch(e) {
        case Yref::CONTAINER: return "container";
        case Yref::PAPER: return "paper";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::bgcolor(std::string f) {
    json["bgcolor"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::bordercolor(std::string f) {
    json["bordercolor"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::borderwidth(double f) {
    json["borderwidth"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::dtick(T f) {
    json["dtick"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::exponentformat(enum Exponentformat f) {
    json["exponentformat"] = to_string(f);
    return *this;
}

template <typename T>
Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::labelalias(T f) {
    json["labelalias"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::len(double f) {
    json["len"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::lenmode(enum Lenmode f) {
    json["lenmode"] = to_string(f);
    return *this;
}

Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::minexponent(double f) {
    json["minexponent"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::nticks(int f) {
    json["nticks"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::orientation(enum Orientation f) {
    json["orientation"] = to_string(f);
    return *this;
}

Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::outlinecolor(std::string f) {
    json["outlinecolor"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::outlinewidth(double f) {
    json["outlinewidth"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::separatethousands(bool f) {
    json["separatethousands"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::showexponent(enum Showexponent f) {
    json["showexponent"] = to_string(f);
    return *this;
}

Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::showticklabels(bool f) {
    json["showticklabels"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::showtickprefix(enum Showtickprefix f) {
    json["showtickprefix"] = to_string(f);
    return *this;
}

Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::showticksuffix(enum Showticksuffix f) {
    json["showticksuffix"] = to_string(f);
    return *this;
}

Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::thickness(double f) {
    json["thickness"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::thicknessmode(enum Thicknessmode f) {
    json["thicknessmode"] = to_string(f);
    return *this;
}

template <typename T>
Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::tick0(T f) {
    json["tick0"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::tickangle(double f) {
    json["tickangle"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::tickcolor(std::string f) {
    json["tickcolor"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::tickfont(Tickfont f) {
    json["tickfont"] = std::move(f.json);
    return *this;
}

Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::tickformat(std::string f) {
    json["tickformat"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::tickformatstops(Tickformatstops f) {
    json["tickformatstops"] = std::move(f.json);
    return *this;
}

Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::ticklabeloverflow(std::string f) {
    json["ticklabeloverflow"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::ticklabelposition(std::string f) {
    json["ticklabelposition"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::ticklabelstep(int f) {
    json["ticklabelstep"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::ticklen(double f) {
    json["ticklen"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::tickmode(enum Tickmode f) {
    json["tickmode"] = to_string(f);
    return *this;
}

Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::tickprefix(std::string f) {
    json["tickprefix"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::ticks(enum Ticks f) {
    json["ticks"] = to_string(f);
    return *this;
}

Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::ticksuffix(std::string f) {
    json["ticksuffix"] = std::move(f);
    return *this;
}

template <typename T, typename>
Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::ticktext(std::vector<T> f) {
    json["ticktext"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::ticktextsrc(std::string f) {
    json["ticktextsrc"] = std::move(f);
    return *this;
}

template <typename T, typename>
Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::tickvals(std::vector<T> f) {
    json["tickvals"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::tickvalssrc(std::string f) {
    json["tickvalssrc"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::tickwidth(double f) {
    json["tickwidth"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::title(Title f) {
    json["title"] = std::move(f.json);
    return *this;
}

Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::x(double f) {
    json["x"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::xanchor(enum Xanchor f) {
    json["xanchor"] = to_string(f);
    return *this;
}

Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::xpad(double f) {
    json["xpad"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::xref(enum Xref f) {
    json["xref"] = to_string(f);
    return *this;
}

Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::y(double f) {
    json["y"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::yanchor(enum Yanchor f) {
    json["yanchor"] = to_string(f);
    return *this;
}

Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::ypad(double f) {
    json["ypad"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar& Layout::Coloraxis::Colorbar::yref(enum Yref f) {
    json["yref"] = to_string(f);
    return *this;
}

std::string Layout::Coloraxis::Colorbar::Tickfont::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Coloraxis::Colorbar::Tickfont& Layout::Coloraxis::Colorbar::Tickfont::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar::Tickfont& Layout::Coloraxis::Colorbar::Tickfont::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar::Tickfont& Layout::Coloraxis::Colorbar::Tickfont::lineposition(std::string f) {
    json["lineposition"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar::Tickfont& Layout::Coloraxis::Colorbar::Tickfont::shadow(std::string f) {
    json["shadow"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar::Tickfont& Layout::Coloraxis::Colorbar::Tickfont::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar::Tickfont& Layout::Coloraxis::Colorbar::Tickfont::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Coloraxis::Colorbar::Tickfont& Layout::Coloraxis::Colorbar::Tickfont::textcase(std::string f) {
    json["textcase"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar::Tickfont& Layout::Coloraxis::Colorbar::Tickfont::variant(std::string f) {
    json["variant"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar::Tickfont& Layout::Coloraxis::Colorbar::Tickfont::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}


Layout::Coloraxis::Colorbar::Tickformatstops& Layout::Coloraxis::Colorbar::Tickformatstops::tickformatstop(Tickformatstop f) {
    json["tickformatstop"] = std::move(f.json);
    return *this;
}


Layout::Coloraxis::Colorbar::Tickformatstops::Tickformatstop& Layout::Coloraxis::Colorbar::Tickformatstops::Tickformatstop::dtickrange(std::vector<double> f) {
    json["dtickrange"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar::Tickformatstops::Tickformatstop& Layout::Coloraxis::Colorbar::Tickformatstops::Tickformatstop::enabled(bool f) {
    json["enabled"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar::Tickformatstops::Tickformatstop& Layout::Coloraxis::Colorbar::Tickformatstops::Tickformatstop::name(std::string f) {
    json["name"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar::Tickformatstops::Tickformatstop& Layout::Coloraxis::Colorbar::Tickformatstops::Tickformatstop::templateitemname(std::string f) {
    json["templateitemname"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar::Tickformatstops::Tickformatstop& Layout::Coloraxis::Colorbar::Tickformatstops::Tickformatstop::value(std::string f) {
    json["value"] = std::move(f);
    return *this;
}

std::string Layout::Coloraxis::Colorbar::Title::to_string(Side e) {
    switch(e) {
        case Side::RIGHT: return "right";
        case Side::TOP: return "top";
        case Side::BOTTOM: return "bottom";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Coloraxis::Colorbar::Title& Layout::Coloraxis::Colorbar::Title::font(Font f) {
    json["font"] = std::move(f.json);
    return *this;
}

Layout::Coloraxis::Colorbar::Title& Layout::Coloraxis::Colorbar::Title::side(enum Side f) {
    json["side"] = to_string(f);
    return *this;
}

Layout::Coloraxis::Colorbar::Title& Layout::Coloraxis::Colorbar::Title::text(std::string f) {
    json["text"] = std::move(f);
    return *this;
}

std::string Layout::Coloraxis::Colorbar::Title::Font::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Coloraxis::Colorbar::Title::Font& Layout::Coloraxis::Colorbar::Title::Font::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar::Title::Font& Layout::Coloraxis::Colorbar::Title::Font::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar::Title::Font& Layout::Coloraxis::Colorbar::Title::Font::lineposition(std::string f) {
    json["lineposition"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar::Title::Font& Layout::Coloraxis::Colorbar::Title::Font::shadow(std::string f) {
    json["shadow"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar::Title::Font& Layout::Coloraxis::Colorbar::Title::Font::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar::Title::Font& Layout::Coloraxis::Colorbar::Title::Font::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Coloraxis::Colorbar::Title::Font& Layout::Coloraxis::Colorbar::Title::Font::textcase(std::string f) {
    json["textcase"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar::Title::Font& Layout::Coloraxis::Colorbar::Title::Font::variant(std::string f) {
    json["variant"] = std::move(f);
    return *this;
}

Layout::Coloraxis::Colorbar::Title::Font& Layout::Coloraxis::Colorbar::Title::Font::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}


Layout::Colorscale& Layout::Colorscale::diverging(std::string f) {
    json["diverging"] = std::move(f);
    return *this;
}
Layout::Colorscale& Layout::Colorscale::diverging(std::vector<std::pair<double, std::string>> f) {
    json["diverging"] = std::move(f);
    return *this;
}

Layout::Colorscale& Layout::Colorscale::sequential(std::string f) {
    json["sequential"] = std::move(f);
    return *this;
}
Layout::Colorscale& Layout::Colorscale::sequential(std::vector<std::pair<double, std::string>> f) {
    json["sequential"] = std::move(f);
    return *this;
}

Layout::Colorscale& Layout::Colorscale::sequentialminus(std::string f) {
    json["sequentialminus"] = std::move(f);
    return *this;
}
Layout::Colorscale& Layout::Colorscale::sequentialminus(std::vector<std::pair<double, std::string>> f) {
    json["sequentialminus"] = std::move(f);
    return *this;
}

std::string Layout::Font::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Font& Layout::Font::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Font& Layout::Font::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Font& Layout::Font::lineposition(std::string f) {
    json["lineposition"] = std::move(f);
    return *this;
}

Layout::Font& Layout::Font::shadow(std::string f) {
    json["shadow"] = std::move(f);
    return *this;
}

Layout::Font& Layout::Font::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Font& Layout::Font::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Font& Layout::Font::textcase(std::string f) {
    json["textcase"] = std::move(f);
    return *this;
}

Layout::Font& Layout::Font::variant(std::string f) {
    json["variant"] = std::move(f);
    return *this;
}

Layout::Font& Layout::Font::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}

std::string Layout::Geo::to_string(Fitbounds e) {
    switch(e) {
        case Fitbounds::FALSE: return "False";
        case Fitbounds::LOCATIONS: return "locations";
        case Fitbounds::GEOJSON: return "geojson";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Geo::to_string(Resolution e) {
    switch(e) {
        case Resolution::NUM_110: return "110";
        case Resolution::NUM_50: return "50";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Geo& Layout::Geo::bgcolor(std::string f) {
    json["bgcolor"] = std::move(f);
    return *this;
}

Layout::Geo& Layout::Geo::center(Center f) {
    json["center"] = std::move(f.json);
    return *this;
}

Layout::Geo& Layout::Geo::coastlinecolor(std::string f) {
    json["coastlinecolor"] = std::move(f);
    return *this;
}

Layout::Geo& Layout::Geo::coastlinewidth(double f) {
    json["coastlinewidth"] = std::move(f);
    return *this;
}

Layout::Geo& Layout::Geo::countrycolor(std::string f) {
    json["countrycolor"] = std::move(f);
    return *this;
}

Layout::Geo& Layout::Geo::countrywidth(double f) {
    json["countrywidth"] = std::move(f);
    return *this;
}

Layout::Geo& Layout::Geo::domain(Domain f) {
    json["domain"] = std::move(f.json);
    return *this;
}

Layout::Geo& Layout::Geo::fitbounds(enum Fitbounds f) {
    json["fitbounds"] = to_string(f);
    return *this;
}

Layout::Geo& Layout::Geo::framecolor(std::string f) {
    json["framecolor"] = std::move(f);
    return *this;
}

Layout::Geo& Layout::Geo::framewidth(double f) {
    json["framewidth"] = std::move(f);
    return *this;
}

Layout::Geo& Layout::Geo::lakecolor(std::string f) {
    json["lakecolor"] = std::move(f);
    return *this;
}

Layout::Geo& Layout::Geo::landcolor(std::string f) {
    json["landcolor"] = std::move(f);
    return *this;
}

Layout::Geo& Layout::Geo::lataxis(Lataxis f) {
    json["lataxis"] = std::move(f.json);
    return *this;
}

Layout::Geo& Layout::Geo::lonaxis(Lonaxis f) {
    json["lonaxis"] = std::move(f.json);
    return *this;
}

Layout::Geo& Layout::Geo::oceancolor(std::string f) {
    json["oceancolor"] = std::move(f);
    return *this;
}

Layout::Geo& Layout::Geo::projection(Projection f) {
    json["projection"] = std::move(f.json);
    return *this;
}

Layout::Geo& Layout::Geo::resolution(enum Resolution f) {
    json["resolution"] = to_string(f);
    return *this;
}

Layout::Geo& Layout::Geo::rivercolor(std::string f) {
    json["rivercolor"] = std::move(f);
    return *this;
}

Layout::Geo& Layout::Geo::riverwidth(double f) {
    json["riverwidth"] = std::move(f);
    return *this;
}

Layout::Geo& Layout::Geo::scope(std::string f) {
    json["scope"] = std::move(f);
    return *this;
}

Layout::Geo& Layout::Geo::showcoastlines(bool f) {
    json["showcoastlines"] = std::move(f);
    return *this;
}

Layout::Geo& Layout::Geo::showcountries(bool f) {
    json["showcountries"] = std::move(f);
    return *this;
}

Layout::Geo& Layout::Geo::showframe(bool f) {
    json["showframe"] = std::move(f);
    return *this;
}

Layout::Geo& Layout::Geo::showlakes(bool f) {
    json["showlakes"] = std::move(f);
    return *this;
}

Layout::Geo& Layout::Geo::showland(bool f) {
    json["showland"] = std::move(f);
    return *this;
}

Layout::Geo& Layout::Geo::showocean(bool f) {
    json["showocean"] = std::move(f);
    return *this;
}

Layout::Geo& Layout::Geo::showrivers(bool f) {
    json["showrivers"] = std::move(f);
    return *this;
}

Layout::Geo& Layout::Geo::showsubunits(bool f) {
    json["showsubunits"] = std::move(f);
    return *this;
}

Layout::Geo& Layout::Geo::subunitcolor(std::string f) {
    json["subunitcolor"] = std::move(f);
    return *this;
}

Layout::Geo& Layout::Geo::subunitwidth(double f) {
    json["subunitwidth"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Geo& Layout::Geo::uirevision(T f) {
    json["uirevision"] = std::move(f);
    return *this;
}

Layout::Geo& Layout::Geo::visible(bool f) {
    json["visible"] = std::move(f);
    return *this;
}


Layout::Geo::Center& Layout::Geo::Center::lat(double f) {
    json["lat"] = std::move(f);
    return *this;
}

Layout::Geo::Center& Layout::Geo::Center::lon(double f) {
    json["lon"] = std::move(f);
    return *this;
}


Layout::Geo::Domain& Layout::Geo::Domain::column(int f) {
    json["column"] = std::move(f);
    return *this;
}

Layout::Geo::Domain& Layout::Geo::Domain::row(int f) {
    json["row"] = std::move(f);
    return *this;
}

Layout::Geo::Domain& Layout::Geo::Domain::x(std::vector<double> f) {
    json["x"] = std::move(f);
    return *this;
}

Layout::Geo::Domain& Layout::Geo::Domain::y(std::vector<double> f) {
    json["y"] = std::move(f);
    return *this;
}


Layout::Geo::Lataxis& Layout::Geo::Lataxis::dtick(double f) {
    json["dtick"] = std::move(f);
    return *this;
}

Layout::Geo::Lataxis& Layout::Geo::Lataxis::gridcolor(std::string f) {
    json["gridcolor"] = std::move(f);
    return *this;
}

Layout::Geo::Lataxis& Layout::Geo::Lataxis::griddash(std::string f) {
    json["griddash"] = std::move(f);
    return *this;
}

Layout::Geo::Lataxis& Layout::Geo::Lataxis::gridwidth(double f) {
    json["gridwidth"] = std::move(f);
    return *this;
}

Layout::Geo::Lataxis& Layout::Geo::Lataxis::range(std::vector<double> f) {
    json["range"] = std::move(f);
    return *this;
}

Layout::Geo::Lataxis& Layout::Geo::Lataxis::showgrid(bool f) {
    json["showgrid"] = std::move(f);
    return *this;
}

Layout::Geo::Lataxis& Layout::Geo::Lataxis::tick0(double f) {
    json["tick0"] = std::move(f);
    return *this;
}


Layout::Geo::Lonaxis& Layout::Geo::Lonaxis::dtick(double f) {
    json["dtick"] = std::move(f);
    return *this;
}

Layout::Geo::Lonaxis& Layout::Geo::Lonaxis::gridcolor(std::string f) {
    json["gridcolor"] = std::move(f);
    return *this;
}

Layout::Geo::Lonaxis& Layout::Geo::Lonaxis::griddash(std::string f) {
    json["griddash"] = std::move(f);
    return *this;
}

Layout::Geo::Lonaxis& Layout::Geo::Lonaxis::gridwidth(double f) {
    json["gridwidth"] = std::move(f);
    return *this;
}

Layout::Geo::Lonaxis& Layout::Geo::Lonaxis::range(std::vector<double> f) {
    json["range"] = std::move(f);
    return *this;
}

Layout::Geo::Lonaxis& Layout::Geo::Lonaxis::showgrid(bool f) {
    json["showgrid"] = std::move(f);
    return *this;
}

Layout::Geo::Lonaxis& Layout::Geo::Lonaxis::tick0(double f) {
    json["tick0"] = std::move(f);
    return *this;
}


Layout::Geo::Projection& Layout::Geo::Projection::distance(double f) {
    json["distance"] = std::move(f);
    return *this;
}

Layout::Geo::Projection& Layout::Geo::Projection::parallels(std::vector<double> f) {
    json["parallels"] = std::move(f);
    return *this;
}

Layout::Geo::Projection& Layout::Geo::Projection::rotation(Rotation f) {
    json["rotation"] = std::move(f.json);
    return *this;
}

Layout::Geo::Projection& Layout::Geo::Projection::scale(double f) {
    json["scale"] = std::move(f);
    return *this;
}

Layout::Geo::Projection& Layout::Geo::Projection::tilt(double f) {
    json["tilt"] = std::move(f);
    return *this;
}

Layout::Geo::Projection& Layout::Geo::Projection::type(std::string f) {
    json["type"] = std::move(f);
    return *this;
}


Layout::Geo::Projection::Rotation& Layout::Geo::Projection::Rotation::lat(double f) {
    json["lat"] = std::move(f);
    return *this;
}

Layout::Geo::Projection::Rotation& Layout::Geo::Projection::Rotation::lon(double f) {
    json["lon"] = std::move(f);
    return *this;
}

Layout::Geo::Projection::Rotation& Layout::Geo::Projection::Rotation::roll(double f) {
    json["roll"] = std::move(f);
    return *this;
}

std::string Layout::Grid::to_string(Pattern e) {
    switch(e) {
        case Pattern::INDEPENDENT: return "independent";
        case Pattern::COUPLED: return "coupled";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Grid& Layout::Grid::columns(int f) {
    json["columns"] = std::move(f);
    return *this;
}

Layout::Grid& Layout::Grid::domain(Domain f) {
    json["domain"] = std::move(f.json);
    return *this;
}

Layout::Grid& Layout::Grid::pattern(enum Pattern f) {
    json["pattern"] = to_string(f);
    return *this;
}

Layout::Grid& Layout::Grid::roworder(std::string f) {
    json["roworder"] = std::move(f);
    return *this;
}

Layout::Grid& Layout::Grid::rows(int f) {
    json["rows"] = std::move(f);
    return *this;
}

Layout::Grid& Layout::Grid::subplots(std::vector<double> f) {
    json["subplots"] = std::move(f);
    return *this;
}

Layout::Grid& Layout::Grid::xaxes(std::vector<double> f) {
    json["xaxes"] = std::move(f);
    return *this;
}

Layout::Grid& Layout::Grid::xgap(double f) {
    json["xgap"] = std::move(f);
    return *this;
}

Layout::Grid& Layout::Grid::xside(std::string f) {
    json["xside"] = std::move(f);
    return *this;
}

Layout::Grid& Layout::Grid::yaxes(std::vector<double> f) {
    json["yaxes"] = std::move(f);
    return *this;
}

Layout::Grid& Layout::Grid::ygap(double f) {
    json["ygap"] = std::move(f);
    return *this;
}

Layout::Grid& Layout::Grid::yside(std::string f) {
    json["yside"] = std::move(f);
    return *this;
}


Layout::Grid::Domain& Layout::Grid::Domain::x(std::vector<double> f) {
    json["x"] = std::move(f);
    return *this;
}

Layout::Grid::Domain& Layout::Grid::Domain::y(std::vector<double> f) {
    json["y"] = std::move(f);
    return *this;
}

std::string Layout::Hoverlabel::to_string(Align e) {
    switch(e) {
        case Align::LEFT: return "left";
        case Align::RIGHT: return "right";
        case Align::AUTO: return "auto";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Hoverlabel& Layout::Hoverlabel::align(enum Align f) {
    json["align"] = to_string(f);
    return *this;
}

Layout::Hoverlabel& Layout::Hoverlabel::bgcolor(std::string f) {
    json["bgcolor"] = std::move(f);
    return *this;
}

Layout::Hoverlabel& Layout::Hoverlabel::bordercolor(std::string f) {
    json["bordercolor"] = std::move(f);
    return *this;
}

Layout::Hoverlabel& Layout::Hoverlabel::font(Font f) {
    json["font"] = std::move(f.json);
    return *this;
}

Layout::Hoverlabel& Layout::Hoverlabel::grouptitlefont(Grouptitlefont f) {
    json["grouptitlefont"] = std::move(f.json);
    return *this;
}

Layout::Hoverlabel& Layout::Hoverlabel::namelength(int f) {
    json["namelength"] = std::move(f);
    return *this;
}

std::string Layout::Hoverlabel::Font::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Hoverlabel::Font& Layout::Hoverlabel::Font::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Hoverlabel::Font& Layout::Hoverlabel::Font::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Hoverlabel::Font& Layout::Hoverlabel::Font::lineposition(std::string f) {
    json["lineposition"] = std::move(f);
    return *this;
}

Layout::Hoverlabel::Font& Layout::Hoverlabel::Font::shadow(std::string f) {
    json["shadow"] = std::move(f);
    return *this;
}

Layout::Hoverlabel::Font& Layout::Hoverlabel::Font::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Hoverlabel::Font& Layout::Hoverlabel::Font::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Hoverlabel::Font& Layout::Hoverlabel::Font::textcase(std::string f) {
    json["textcase"] = std::move(f);
    return *this;
}

Layout::Hoverlabel::Font& Layout::Hoverlabel::Font::variant(std::string f) {
    json["variant"] = std::move(f);
    return *this;
}

Layout::Hoverlabel::Font& Layout::Hoverlabel::Font::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}

std::string Layout::Hoverlabel::Grouptitlefont::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Hoverlabel::Grouptitlefont& Layout::Hoverlabel::Grouptitlefont::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Hoverlabel::Grouptitlefont& Layout::Hoverlabel::Grouptitlefont::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Hoverlabel::Grouptitlefont& Layout::Hoverlabel::Grouptitlefont::lineposition(std::string f) {
    json["lineposition"] = std::move(f);
    return *this;
}

Layout::Hoverlabel::Grouptitlefont& Layout::Hoverlabel::Grouptitlefont::shadow(std::string f) {
    json["shadow"] = std::move(f);
    return *this;
}

Layout::Hoverlabel::Grouptitlefont& Layout::Hoverlabel::Grouptitlefont::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Hoverlabel::Grouptitlefont& Layout::Hoverlabel::Grouptitlefont::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Hoverlabel::Grouptitlefont& Layout::Hoverlabel::Grouptitlefont::textcase(std::string f) {
    json["textcase"] = std::move(f);
    return *this;
}

Layout::Hoverlabel::Grouptitlefont& Layout::Hoverlabel::Grouptitlefont::variant(std::string f) {
    json["variant"] = std::move(f);
    return *this;
}

Layout::Hoverlabel::Grouptitlefont& Layout::Hoverlabel::Grouptitlefont::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}


Layout::Images& Layout::Images::image(Image f) {
    json["image"] = std::move(f.json);
    return *this;
}

std::string Layout::Images::Image::to_string(Layer e) {
    switch(e) {
        case Layer::BELOW: return "below";
        case Layer::ABOVE: return "above";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Images::Image::to_string(Sizing e) {
    switch(e) {
        case Sizing::FILL: return "fill";
        case Sizing::CONTAIN: return "contain";
        case Sizing::STRETCH: return "stretch";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Images::Image::to_string(Xanchor e) {
    switch(e) {
        case Xanchor::LEFT: return "left";
        case Xanchor::CENTER: return "center";
        case Xanchor::RIGHT: return "right";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Images::Image::to_string(Yanchor e) {
    switch(e) {
        case Yanchor::TOP: return "top";
        case Yanchor::MIDDLE: return "middle";
        case Yanchor::BOTTOM: return "bottom";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Images::Image& Layout::Images::Image::layer(enum Layer f) {
    json["layer"] = to_string(f);
    return *this;
}

Layout::Images::Image& Layout::Images::Image::name(std::string f) {
    json["name"] = std::move(f);
    return *this;
}

Layout::Images::Image& Layout::Images::Image::opacity(double f) {
    json["opacity"] = std::move(f);
    return *this;
}

Layout::Images::Image& Layout::Images::Image::sizex(double f) {
    json["sizex"] = std::move(f);
    return *this;
}

Layout::Images::Image& Layout::Images::Image::sizey(double f) {
    json["sizey"] = std::move(f);
    return *this;
}

Layout::Images::Image& Layout::Images::Image::sizing(enum Sizing f) {
    json["sizing"] = to_string(f);
    return *this;
}

Layout::Images::Image& Layout::Images::Image::source(std::string f) {
    json["source"] = std::move(f);
    return *this;
}

Layout::Images::Image& Layout::Images::Image::templateitemname(std::string f) {
    json["templateitemname"] = std::move(f);
    return *this;
}

Layout::Images::Image& Layout::Images::Image::visible(bool f) {
    json["visible"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Images::Image& Layout::Images::Image::x(T f) {
    json["x"] = std::move(f);
    return *this;
}

Layout::Images::Image& Layout::Images::Image::xanchor(enum Xanchor f) {
    json["xanchor"] = to_string(f);
    return *this;
}

Layout::Images::Image& Layout::Images::Image::xref(std::string f) {
    json["xref"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Images::Image& Layout::Images::Image::y(T f) {
    json["y"] = std::move(f);
    return *this;
}

Layout::Images::Image& Layout::Images::Image::yanchor(enum Yanchor f) {
    json["yanchor"] = to_string(f);
    return *this;
}

Layout::Images::Image& Layout::Images::Image::yref(std::string f) {
    json["yref"] = std::move(f);
    return *this;
}

std::string Layout::Legend::to_string(Entrywidthmode e) {
    switch(e) {
        case Entrywidthmode::FRACTION: return "fraction";
        case Entrywidthmode::PIXELS: return "pixels";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Legend::to_string(Groupclick e) {
    switch(e) {
        case Groupclick::TOGGLEITEM: return "toggleitem";
        case Groupclick::TOGGLEGROUP: return "togglegroup";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Legend::to_string(Itemclick e) {
    switch(e) {
        case Itemclick::TOGGLE: return "toggle";
        case Itemclick::TOGGLEOTHERS: return "toggleothers";
        case Itemclick::FALSE: return "False";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Legend::to_string(Itemdoubleclick e) {
    switch(e) {
        case Itemdoubleclick::TOGGLE: return "toggle";
        case Itemdoubleclick::TOGGLEOTHERS: return "toggleothers";
        case Itemdoubleclick::FALSE: return "False";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Legend::to_string(Itemsizing e) {
    switch(e) {
        case Itemsizing::TRACE: return "trace";
        case Itemsizing::CONSTANT: return "constant";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Legend::to_string(Orientation e) {
    switch(e) {
        case Orientation::V: return "v";
        case Orientation::H: return "h";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Legend::to_string(Valign e) {
    switch(e) {
        case Valign::TOP: return "top";
        case Valign::MIDDLE: return "middle";
        case Valign::BOTTOM: return "bottom";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Legend::to_string(Xanchor e) {
    switch(e) {
        case Xanchor::AUTO: return "auto";
        case Xanchor::LEFT: return "left";
        case Xanchor::CENTER: return "center";
        case Xanchor::RIGHT: return "right";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Legend::to_string(Xref e) {
    switch(e) {
        case Xref::CONTAINER: return "container";
        case Xref::PAPER: return "paper";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Legend::to_string(Yanchor e) {
    switch(e) {
        case Yanchor::AUTO: return "auto";
        case Yanchor::TOP: return "top";
        case Yanchor::MIDDLE: return "middle";
        case Yanchor::BOTTOM: return "bottom";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Legend::to_string(Yref e) {
    switch(e) {
        case Yref::CONTAINER: return "container";
        case Yref::PAPER: return "paper";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Legend& Layout::Legend::bgcolor(std::string f) {
    json["bgcolor"] = std::move(f);
    return *this;
}

Layout::Legend& Layout::Legend::bordercolor(std::string f) {
    json["bordercolor"] = std::move(f);
    return *this;
}

Layout::Legend& Layout::Legend::borderwidth(double f) {
    json["borderwidth"] = std::move(f);
    return *this;
}

Layout::Legend& Layout::Legend::entrywidth(double f) {
    json["entrywidth"] = std::move(f);
    return *this;
}

Layout::Legend& Layout::Legend::entrywidthmode(enum Entrywidthmode f) {
    json["entrywidthmode"] = to_string(f);
    return *this;
}

Layout::Legend& Layout::Legend::font(Font f) {
    json["font"] = std::move(f.json);
    return *this;
}

Layout::Legend& Layout::Legend::groupclick(enum Groupclick f) {
    json["groupclick"] = to_string(f);
    return *this;
}

Layout::Legend& Layout::Legend::grouptitlefont(Grouptitlefont f) {
    json["grouptitlefont"] = std::move(f.json);
    return *this;
}

Layout::Legend& Layout::Legend::indentation(double f) {
    json["indentation"] = std::move(f);
    return *this;
}

Layout::Legend& Layout::Legend::itemclick(enum Itemclick f) {
    json["itemclick"] = to_string(f);
    return *this;
}

Layout::Legend& Layout::Legend::itemdoubleclick(enum Itemdoubleclick f) {
    json["itemdoubleclick"] = to_string(f);
    return *this;
}

Layout::Legend& Layout::Legend::itemsizing(enum Itemsizing f) {
    json["itemsizing"] = to_string(f);
    return *this;
}

Layout::Legend& Layout::Legend::itemwidth(double f) {
    json["itemwidth"] = std::move(f);
    return *this;
}

Layout::Legend& Layout::Legend::orientation(enum Orientation f) {
    json["orientation"] = to_string(f);
    return *this;
}

Layout::Legend& Layout::Legend::title(Title f) {
    json["title"] = std::move(f.json);
    return *this;
}

Layout::Legend& Layout::Legend::tracegroupgap(double f) {
    json["tracegroupgap"] = std::move(f);
    return *this;
}

Layout::Legend& Layout::Legend::traceorder(std::string f) {
    json["traceorder"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Legend& Layout::Legend::uirevision(T f) {
    json["uirevision"] = std::move(f);
    return *this;
}

Layout::Legend& Layout::Legend::valign(enum Valign f) {
    json["valign"] = to_string(f);
    return *this;
}

Layout::Legend& Layout::Legend::visible(bool f) {
    json["visible"] = std::move(f);
    return *this;
}

Layout::Legend& Layout::Legend::x(double f) {
    json["x"] = std::move(f);
    return *this;
}

Layout::Legend& Layout::Legend::xanchor(enum Xanchor f) {
    json["xanchor"] = to_string(f);
    return *this;
}

Layout::Legend& Layout::Legend::xref(enum Xref f) {
    json["xref"] = to_string(f);
    return *this;
}

Layout::Legend& Layout::Legend::y(double f) {
    json["y"] = std::move(f);
    return *this;
}

Layout::Legend& Layout::Legend::yanchor(enum Yanchor f) {
    json["yanchor"] = to_string(f);
    return *this;
}

Layout::Legend& Layout::Legend::yref(enum Yref f) {
    json["yref"] = to_string(f);
    return *this;
}

std::string Layout::Legend::Font::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Legend::Font& Layout::Legend::Font::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Legend::Font& Layout::Legend::Font::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Legend::Font& Layout::Legend::Font::lineposition(std::string f) {
    json["lineposition"] = std::move(f);
    return *this;
}

Layout::Legend::Font& Layout::Legend::Font::shadow(std::string f) {
    json["shadow"] = std::move(f);
    return *this;
}

Layout::Legend::Font& Layout::Legend::Font::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Legend::Font& Layout::Legend::Font::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Legend::Font& Layout::Legend::Font::textcase(std::string f) {
    json["textcase"] = std::move(f);
    return *this;
}

Layout::Legend::Font& Layout::Legend::Font::variant(std::string f) {
    json["variant"] = std::move(f);
    return *this;
}

Layout::Legend::Font& Layout::Legend::Font::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}

std::string Layout::Legend::Grouptitlefont::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Legend::Grouptitlefont& Layout::Legend::Grouptitlefont::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Legend::Grouptitlefont& Layout::Legend::Grouptitlefont::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Legend::Grouptitlefont& Layout::Legend::Grouptitlefont::lineposition(std::string f) {
    json["lineposition"] = std::move(f);
    return *this;
}

Layout::Legend::Grouptitlefont& Layout::Legend::Grouptitlefont::shadow(std::string f) {
    json["shadow"] = std::move(f);
    return *this;
}

Layout::Legend::Grouptitlefont& Layout::Legend::Grouptitlefont::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Legend::Grouptitlefont& Layout::Legend::Grouptitlefont::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Legend::Grouptitlefont& Layout::Legend::Grouptitlefont::textcase(std::string f) {
    json["textcase"] = std::move(f);
    return *this;
}

Layout::Legend::Grouptitlefont& Layout::Legend::Grouptitlefont::variant(std::string f) {
    json["variant"] = std::move(f);
    return *this;
}

Layout::Legend::Grouptitlefont& Layout::Legend::Grouptitlefont::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}


Layout::Legend::Title& Layout::Legend::Title::font(Font f) {
    json["font"] = std::move(f.json);
    return *this;
}

Layout::Legend::Title& Layout::Legend::Title::side(std::string f) {
    json["side"] = std::move(f);
    return *this;
}

Layout::Legend::Title& Layout::Legend::Title::text(std::string f) {
    json["text"] = std::move(f);
    return *this;
}

std::string Layout::Legend::Title::Font::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Legend::Title::Font& Layout::Legend::Title::Font::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Legend::Title::Font& Layout::Legend::Title::Font::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Legend::Title::Font& Layout::Legend::Title::Font::lineposition(std::string f) {
    json["lineposition"] = std::move(f);
    return *this;
}

Layout::Legend::Title::Font& Layout::Legend::Title::Font::shadow(std::string f) {
    json["shadow"] = std::move(f);
    return *this;
}

Layout::Legend::Title::Font& Layout::Legend::Title::Font::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Legend::Title::Font& Layout::Legend::Title::Font::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Legend::Title::Font& Layout::Legend::Title::Font::textcase(std::string f) {
    json["textcase"] = std::move(f);
    return *this;
}

Layout::Legend::Title::Font& Layout::Legend::Title::Font::variant(std::string f) {
    json["variant"] = std::move(f);
    return *this;
}

Layout::Legend::Title::Font& Layout::Legend::Title::Font::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}


Layout::Map& Layout::Map::bearing(double f) {
    json["bearing"] = std::move(f);
    return *this;
}

Layout::Map& Layout::Map::bounds(Bounds f) {
    json["bounds"] = std::move(f.json);
    return *this;
}

Layout::Map& Layout::Map::center(Center f) {
    json["center"] = std::move(f.json);
    return *this;
}

Layout::Map& Layout::Map::domain(Domain f) {
    json["domain"] = std::move(f.json);
    return *this;
}

Layout::Map& Layout::Map::layers(Layers f) {
    json["layers"] = std::move(f.json);
    return *this;
}

Layout::Map& Layout::Map::pitch(double f) {
    json["pitch"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Map& Layout::Map::style(T f) {
    json["style"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Map& Layout::Map::uirevision(T f) {
    json["uirevision"] = std::move(f);
    return *this;
}

Layout::Map& Layout::Map::zoom(double f) {
    json["zoom"] = std::move(f);
    return *this;
}


Layout::Map::Bounds& Layout::Map::Bounds::east(double f) {
    json["east"] = std::move(f);
    return *this;
}

Layout::Map::Bounds& Layout::Map::Bounds::north(double f) {
    json["north"] = std::move(f);
    return *this;
}

Layout::Map::Bounds& Layout::Map::Bounds::south(double f) {
    json["south"] = std::move(f);
    return *this;
}

Layout::Map::Bounds& Layout::Map::Bounds::west(double f) {
    json["west"] = std::move(f);
    return *this;
}


Layout::Map::Center& Layout::Map::Center::lat(double f) {
    json["lat"] = std::move(f);
    return *this;
}

Layout::Map::Center& Layout::Map::Center::lon(double f) {
    json["lon"] = std::move(f);
    return *this;
}


Layout::Map::Domain& Layout::Map::Domain::column(int f) {
    json["column"] = std::move(f);
    return *this;
}

Layout::Map::Domain& Layout::Map::Domain::row(int f) {
    json["row"] = std::move(f);
    return *this;
}

Layout::Map::Domain& Layout::Map::Domain::x(std::vector<double> f) {
    json["x"] = std::move(f);
    return *this;
}

Layout::Map::Domain& Layout::Map::Domain::y(std::vector<double> f) {
    json["y"] = std::move(f);
    return *this;
}


Layout::Map::Layers& Layout::Map::Layers::layer(Layer f) {
    json["layer"] = std::move(f.json);
    return *this;
}

std::string Layout::Map::Layers::Layer::to_string(Sourcetype e) {
    switch(e) {
        case Sourcetype::GEOJSON: return "geojson";
        case Sourcetype::VECTOR: return "vector";
        case Sourcetype::RASTER: return "raster";
        case Sourcetype::IMAGE: return "image";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Map::Layers::Layer::to_string(Type e) {
    switch(e) {
        case Type::CIRCLE: return "circle";
        case Type::LINE: return "line";
        case Type::FILL: return "fill";
        case Type::SYMBOL: return "symbol";
        case Type::RASTER: return "raster";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Map::Layers::Layer& Layout::Map::Layers::Layer::below(std::string f) {
    json["below"] = std::move(f);
    return *this;
}

Layout::Map::Layers::Layer& Layout::Map::Layers::Layer::circle(Circle f) {
    json["circle"] = std::move(f.json);
    return *this;
}

Layout::Map::Layers::Layer& Layout::Map::Layers::Layer::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Map::Layers::Layer& Layout::Map::Layers::Layer::coordinates(T f) {
    json["coordinates"] = std::move(f);
    return *this;
}

Layout::Map::Layers::Layer& Layout::Map::Layers::Layer::fill(Fill f) {
    json["fill"] = std::move(f.json);
    return *this;
}

Layout::Map::Layers::Layer& Layout::Map::Layers::Layer::line(Line f) {
    json["line"] = std::move(f.json);
    return *this;
}

Layout::Map::Layers::Layer& Layout::Map::Layers::Layer::maxzoom(double f) {
    json["maxzoom"] = std::move(f);
    return *this;
}

Layout::Map::Layers::Layer& Layout::Map::Layers::Layer::minzoom(double f) {
    json["minzoom"] = std::move(f);
    return *this;
}

Layout::Map::Layers::Layer& Layout::Map::Layers::Layer::name(std::string f) {
    json["name"] = std::move(f);
    return *this;
}

Layout::Map::Layers::Layer& Layout::Map::Layers::Layer::opacity(double f) {
    json["opacity"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Map::Layers::Layer& Layout::Map::Layers::Layer::source(T f) {
    json["source"] = std::move(f);
    return *this;
}

Layout::Map::Layers::Layer& Layout::Map::Layers::Layer::sourceattribution(std::string f) {
    json["sourceattribution"] = std::move(f);
    return *this;
}

Layout::Map::Layers::Layer& Layout::Map::Layers::Layer::sourcelayer(std::string f) {
    json["sourcelayer"] = std::move(f);
    return *this;
}

Layout::Map::Layers::Layer& Layout::Map::Layers::Layer::sourcetype(enum Sourcetype f) {
    json["sourcetype"] = to_string(f);
    return *this;
}

Layout::Map::Layers::Layer& Layout::Map::Layers::Layer::symbol(Symbol f) {
    json["symbol"] = std::move(f.json);
    return *this;
}

Layout::Map::Layers::Layer& Layout::Map::Layers::Layer::templateitemname(std::string f) {
    json["templateitemname"] = std::move(f);
    return *this;
}

Layout::Map::Layers::Layer& Layout::Map::Layers::Layer::type(enum Type f) {
    json["type"] = to_string(f);
    return *this;
}

Layout::Map::Layers::Layer& Layout::Map::Layers::Layer::visible(bool f) {
    json["visible"] = std::move(f);
    return *this;
}


Layout::Map::Layers::Layer::Circle& Layout::Map::Layers::Layer::Circle::radius(double f) {
    json["radius"] = std::move(f);
    return *this;
}


Layout::Map::Layers::Layer::Fill& Layout::Map::Layers::Layer::Fill::outlinecolor(std::string f) {
    json["outlinecolor"] = std::move(f);
    return *this;
}


template <typename T, typename>
Layout::Map::Layers::Layer::Line& Layout::Map::Layers::Layer::Line::dash(std::vector<T> f) {
    json["dash"] = std::move(f);
    return *this;
}

Layout::Map::Layers::Layer::Line& Layout::Map::Layers::Layer::Line::dashsrc(std::string f) {
    json["dashsrc"] = std::move(f);
    return *this;
}

Layout::Map::Layers::Layer::Line& Layout::Map::Layers::Layer::Line::width(double f) {
    json["width"] = std::move(f);
    return *this;
}


Layout::Map::Layers::Layer::Symbol& Layout::Map::Layers::Layer::Symbol::icon(std::string f) {
    json["icon"] = std::move(f);
    return *this;
}

Layout::Map::Layers::Layer::Symbol& Layout::Map::Layers::Layer::Symbol::iconsize(double f) {
    json["iconsize"] = std::move(f);
    return *this;
}

Layout::Map::Layers::Layer::Symbol& Layout::Map::Layers::Layer::Symbol::placement(std::string f) {
    json["placement"] = std::move(f);
    return *this;
}

Layout::Map::Layers::Layer::Symbol& Layout::Map::Layers::Layer::Symbol::text(std::string f) {
    json["text"] = std::move(f);
    return *this;
}

Layout::Map::Layers::Layer::Symbol& Layout::Map::Layers::Layer::Symbol::textfont(Textfont f) {
    json["textfont"] = std::move(f.json);
    return *this;
}

Layout::Map::Layers::Layer::Symbol& Layout::Map::Layers::Layer::Symbol::textposition(std::string f) {
    json["textposition"] = std::move(f);
    return *this;
}

std::string Layout::Map::Layers::Layer::Symbol::Textfont::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Map::Layers::Layer::Symbol::Textfont& Layout::Map::Layers::Layer::Symbol::Textfont::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Map::Layers::Layer::Symbol::Textfont& Layout::Map::Layers::Layer::Symbol::Textfont::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Map::Layers::Layer::Symbol::Textfont& Layout::Map::Layers::Layer::Symbol::Textfont::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Map::Layers::Layer::Symbol::Textfont& Layout::Map::Layers::Layer::Symbol::Textfont::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Map::Layers::Layer::Symbol::Textfont& Layout::Map::Layers::Layer::Symbol::Textfont::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}


Layout::Mapbox& Layout::Mapbox::accesstoken(std::string f) {
    json["accesstoken"] = std::move(f);
    return *this;
}

Layout::Mapbox& Layout::Mapbox::bearing(double f) {
    json["bearing"] = std::move(f);
    return *this;
}

Layout::Mapbox& Layout::Mapbox::bounds(Bounds f) {
    json["bounds"] = std::move(f.json);
    return *this;
}

Layout::Mapbox& Layout::Mapbox::center(Center f) {
    json["center"] = std::move(f.json);
    return *this;
}

Layout::Mapbox& Layout::Mapbox::domain(Domain f) {
    json["domain"] = std::move(f.json);
    return *this;
}

Layout::Mapbox& Layout::Mapbox::layers(Layers f) {
    json["layers"] = std::move(f.json);
    return *this;
}

Layout::Mapbox& Layout::Mapbox::pitch(double f) {
    json["pitch"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Mapbox& Layout::Mapbox::style(T f) {
    json["style"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Mapbox& Layout::Mapbox::uirevision(T f) {
    json["uirevision"] = std::move(f);
    return *this;
}

Layout::Mapbox& Layout::Mapbox::zoom(double f) {
    json["zoom"] = std::move(f);
    return *this;
}


Layout::Mapbox::Bounds& Layout::Mapbox::Bounds::east(double f) {
    json["east"] = std::move(f);
    return *this;
}

Layout::Mapbox::Bounds& Layout::Mapbox::Bounds::north(double f) {
    json["north"] = std::move(f);
    return *this;
}

Layout::Mapbox::Bounds& Layout::Mapbox::Bounds::south(double f) {
    json["south"] = std::move(f);
    return *this;
}

Layout::Mapbox::Bounds& Layout::Mapbox::Bounds::west(double f) {
    json["west"] = std::move(f);
    return *this;
}


Layout::Mapbox::Center& Layout::Mapbox::Center::lat(double f) {
    json["lat"] = std::move(f);
    return *this;
}

Layout::Mapbox::Center& Layout::Mapbox::Center::lon(double f) {
    json["lon"] = std::move(f);
    return *this;
}


Layout::Mapbox::Domain& Layout::Mapbox::Domain::column(int f) {
    json["column"] = std::move(f);
    return *this;
}

Layout::Mapbox::Domain& Layout::Mapbox::Domain::row(int f) {
    json["row"] = std::move(f);
    return *this;
}

Layout::Mapbox::Domain& Layout::Mapbox::Domain::x(std::vector<double> f) {
    json["x"] = std::move(f);
    return *this;
}

Layout::Mapbox::Domain& Layout::Mapbox::Domain::y(std::vector<double> f) {
    json["y"] = std::move(f);
    return *this;
}


Layout::Mapbox::Layers& Layout::Mapbox::Layers::layer(Layer f) {
    json["layer"] = std::move(f.json);
    return *this;
}

std::string Layout::Mapbox::Layers::Layer::to_string(Sourcetype e) {
    switch(e) {
        case Sourcetype::GEOJSON: return "geojson";
        case Sourcetype::VECTOR: return "vector";
        case Sourcetype::RASTER: return "raster";
        case Sourcetype::IMAGE: return "image";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Mapbox::Layers::Layer::to_string(Type e) {
    switch(e) {
        case Type::CIRCLE: return "circle";
        case Type::LINE: return "line";
        case Type::FILL: return "fill";
        case Type::SYMBOL: return "symbol";
        case Type::RASTER: return "raster";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Mapbox::Layers::Layer& Layout::Mapbox::Layers::Layer::below(std::string f) {
    json["below"] = std::move(f);
    return *this;
}

Layout::Mapbox::Layers::Layer& Layout::Mapbox::Layers::Layer::circle(Circle f) {
    json["circle"] = std::move(f.json);
    return *this;
}

Layout::Mapbox::Layers::Layer& Layout::Mapbox::Layers::Layer::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Mapbox::Layers::Layer& Layout::Mapbox::Layers::Layer::coordinates(T f) {
    json["coordinates"] = std::move(f);
    return *this;
}

Layout::Mapbox::Layers::Layer& Layout::Mapbox::Layers::Layer::fill(Fill f) {
    json["fill"] = std::move(f.json);
    return *this;
}

Layout::Mapbox::Layers::Layer& Layout::Mapbox::Layers::Layer::line(Line f) {
    json["line"] = std::move(f.json);
    return *this;
}

Layout::Mapbox::Layers::Layer& Layout::Mapbox::Layers::Layer::maxzoom(double f) {
    json["maxzoom"] = std::move(f);
    return *this;
}

Layout::Mapbox::Layers::Layer& Layout::Mapbox::Layers::Layer::minzoom(double f) {
    json["minzoom"] = std::move(f);
    return *this;
}

Layout::Mapbox::Layers::Layer& Layout::Mapbox::Layers::Layer::name(std::string f) {
    json["name"] = std::move(f);
    return *this;
}

Layout::Mapbox::Layers::Layer& Layout::Mapbox::Layers::Layer::opacity(double f) {
    json["opacity"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Mapbox::Layers::Layer& Layout::Mapbox::Layers::Layer::source(T f) {
    json["source"] = std::move(f);
    return *this;
}

Layout::Mapbox::Layers::Layer& Layout::Mapbox::Layers::Layer::sourceattribution(std::string f) {
    json["sourceattribution"] = std::move(f);
    return *this;
}

Layout::Mapbox::Layers::Layer& Layout::Mapbox::Layers::Layer::sourcelayer(std::string f) {
    json["sourcelayer"] = std::move(f);
    return *this;
}

Layout::Mapbox::Layers::Layer& Layout::Mapbox::Layers::Layer::sourcetype(enum Sourcetype f) {
    json["sourcetype"] = to_string(f);
    return *this;
}

Layout::Mapbox::Layers::Layer& Layout::Mapbox::Layers::Layer::symbol(Symbol f) {
    json["symbol"] = std::move(f.json);
    return *this;
}

Layout::Mapbox::Layers::Layer& Layout::Mapbox::Layers::Layer::templateitemname(std::string f) {
    json["templateitemname"] = std::move(f);
    return *this;
}

Layout::Mapbox::Layers::Layer& Layout::Mapbox::Layers::Layer::type(enum Type f) {
    json["type"] = to_string(f);
    return *this;
}

Layout::Mapbox::Layers::Layer& Layout::Mapbox::Layers::Layer::visible(bool f) {
    json["visible"] = std::move(f);
    return *this;
}


Layout::Mapbox::Layers::Layer::Circle& Layout::Mapbox::Layers::Layer::Circle::radius(double f) {
    json["radius"] = std::move(f);
    return *this;
}


Layout::Mapbox::Layers::Layer::Fill& Layout::Mapbox::Layers::Layer::Fill::outlinecolor(std::string f) {
    json["outlinecolor"] = std::move(f);
    return *this;
}


template <typename T, typename>
Layout::Mapbox::Layers::Layer::Line& Layout::Mapbox::Layers::Layer::Line::dash(std::vector<T> f) {
    json["dash"] = std::move(f);
    return *this;
}

Layout::Mapbox::Layers::Layer::Line& Layout::Mapbox::Layers::Layer::Line::dashsrc(std::string f) {
    json["dashsrc"] = std::move(f);
    return *this;
}

Layout::Mapbox::Layers::Layer::Line& Layout::Mapbox::Layers::Layer::Line::width(double f) {
    json["width"] = std::move(f);
    return *this;
}


Layout::Mapbox::Layers::Layer::Symbol& Layout::Mapbox::Layers::Layer::Symbol::icon(std::string f) {
    json["icon"] = std::move(f);
    return *this;
}

Layout::Mapbox::Layers::Layer::Symbol& Layout::Mapbox::Layers::Layer::Symbol::iconsize(double f) {
    json["iconsize"] = std::move(f);
    return *this;
}

Layout::Mapbox::Layers::Layer::Symbol& Layout::Mapbox::Layers::Layer::Symbol::placement(std::string f) {
    json["placement"] = std::move(f);
    return *this;
}

Layout::Mapbox::Layers::Layer::Symbol& Layout::Mapbox::Layers::Layer::Symbol::text(std::string f) {
    json["text"] = std::move(f);
    return *this;
}

Layout::Mapbox::Layers::Layer::Symbol& Layout::Mapbox::Layers::Layer::Symbol::textfont(Textfont f) {
    json["textfont"] = std::move(f.json);
    return *this;
}

Layout::Mapbox::Layers::Layer::Symbol& Layout::Mapbox::Layers::Layer::Symbol::textposition(std::string f) {
    json["textposition"] = std::move(f);
    return *this;
}

std::string Layout::Mapbox::Layers::Layer::Symbol::Textfont::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Mapbox::Layers::Layer::Symbol::Textfont& Layout::Mapbox::Layers::Layer::Symbol::Textfont::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Mapbox::Layers::Layer::Symbol::Textfont& Layout::Mapbox::Layers::Layer::Symbol::Textfont::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Mapbox::Layers::Layer::Symbol::Textfont& Layout::Mapbox::Layers::Layer::Symbol::Textfont::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Mapbox::Layers::Layer::Symbol::Textfont& Layout::Mapbox::Layers::Layer::Symbol::Textfont::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Mapbox::Layers::Layer::Symbol::Textfont& Layout::Mapbox::Layers::Layer::Symbol::Textfont::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}


Layout::Margin& Layout::Margin::autoexpand(bool f) {
    json["autoexpand"] = std::move(f);
    return *this;
}

Layout::Margin& Layout::Margin::b(double f) {
    json["b"] = std::move(f);
    return *this;
}

Layout::Margin& Layout::Margin::l(double f) {
    json["l"] = std::move(f);
    return *this;
}

Layout::Margin& Layout::Margin::pad(double f) {
    json["pad"] = std::move(f);
    return *this;
}

Layout::Margin& Layout::Margin::r(double f) {
    json["r"] = std::move(f);
    return *this;
}

Layout::Margin& Layout::Margin::t(double f) {
    json["t"] = std::move(f);
    return *this;
}

std::string Layout::Modebar::to_string(Orientation e) {
    switch(e) {
        case Orientation::V: return "v";
        case Orientation::H: return "h";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Modebar& Layout::Modebar::activecolor(std::string f) {
    json["activecolor"] = std::move(f);
    return *this;
}

Layout::Modebar& Layout::Modebar::add(std::string f) {
    json["add"] = std::move(f);
    return *this;
}
Layout::Modebar& Layout::Modebar::add(std::vector<std::string> f) {
    json["add"] = std::move(f);
    return *this;
}

Layout::Modebar& Layout::Modebar::addsrc(std::string f) {
    json["addsrc"] = std::move(f);
    return *this;
}

Layout::Modebar& Layout::Modebar::bgcolor(std::string f) {
    json["bgcolor"] = std::move(f);
    return *this;
}

Layout::Modebar& Layout::Modebar::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Modebar& Layout::Modebar::orientation(enum Orientation f) {
    json["orientation"] = to_string(f);
    return *this;
}

Layout::Modebar& Layout::Modebar::remove(std::string f) {
    json["remove"] = std::move(f);
    return *this;
}
Layout::Modebar& Layout::Modebar::remove(std::vector<std::string> f) {
    json["remove"] = std::move(f);
    return *this;
}

Layout::Modebar& Layout::Modebar::removesrc(std::string f) {
    json["removesrc"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Modebar& Layout::Modebar::uirevision(T f) {
    json["uirevision"] = std::move(f);
    return *this;
}

std::string Layout::Newselection::to_string(Mode e) {
    switch(e) {
        case Mode::IMMEDIATE: return "immediate";
        case Mode::GRADUAL: return "gradual";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Newselection& Layout::Newselection::line(Line f) {
    json["line"] = std::move(f.json);
    return *this;
}

Layout::Newselection& Layout::Newselection::mode(enum Mode f) {
    json["mode"] = to_string(f);
    return *this;
}


Layout::Newselection::Line& Layout::Newselection::Line::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Newselection::Line& Layout::Newselection::Line::dash(std::string f) {
    json["dash"] = std::move(f);
    return *this;
}

Layout::Newselection::Line& Layout::Newselection::Line::width(double f) {
    json["width"] = std::move(f);
    return *this;
}

std::string Layout::Newshape::to_string(Drawdirection e) {
    switch(e) {
        case Drawdirection::ORTHO: return "ortho";
        case Drawdirection::HORIZONTAL: return "horizontal";
        case Drawdirection::VERTICAL: return "vertical";
        case Drawdirection::DIAGONAL: return "diagonal";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Newshape::to_string(Fillrule e) {
    switch(e) {
        case Fillrule::EVENODD: return "evenodd";
        case Fillrule::NONZERO: return "nonzero";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Newshape::to_string(Layer e) {
    switch(e) {
        case Layer::BELOW: return "below";
        case Layer::ABOVE: return "above";
        case Layer::BETWEEN: return "between";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Newshape::to_string(Visible e) {
    switch(e) {
        case Visible::TRUE: return "True";
        case Visible::FALSE: return "False";
        case Visible::LEGENDONLY: return "legendonly";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Newshape& Layout::Newshape::drawdirection(enum Drawdirection f) {
    json["drawdirection"] = to_string(f);
    return *this;
}

Layout::Newshape& Layout::Newshape::fillcolor(std::string f) {
    json["fillcolor"] = std::move(f);
    return *this;
}

Layout::Newshape& Layout::Newshape::fillrule(enum Fillrule f) {
    json["fillrule"] = to_string(f);
    return *this;
}

Layout::Newshape& Layout::Newshape::label(Label f) {
    json["label"] = std::move(f.json);
    return *this;
}

Layout::Newshape& Layout::Newshape::layer(enum Layer f) {
    json["layer"] = to_string(f);
    return *this;
}

Layout::Newshape& Layout::Newshape::legend(std::string f) {
    json["legend"] = std::move(f);
    return *this;
}

Layout::Newshape& Layout::Newshape::legendgroup(std::string f) {
    json["legendgroup"] = std::move(f);
    return *this;
}

Layout::Newshape& Layout::Newshape::legendgrouptitle(Legendgrouptitle f) {
    json["legendgrouptitle"] = std::move(f.json);
    return *this;
}

Layout::Newshape& Layout::Newshape::legendrank(double f) {
    json["legendrank"] = std::move(f);
    return *this;
}

Layout::Newshape& Layout::Newshape::legendwidth(double f) {
    json["legendwidth"] = std::move(f);
    return *this;
}

Layout::Newshape& Layout::Newshape::line(Line f) {
    json["line"] = std::move(f.json);
    return *this;
}

Layout::Newshape& Layout::Newshape::name(std::string f) {
    json["name"] = std::move(f);
    return *this;
}

Layout::Newshape& Layout::Newshape::opacity(double f) {
    json["opacity"] = std::move(f);
    return *this;
}

Layout::Newshape& Layout::Newshape::showlegend(bool f) {
    json["showlegend"] = std::move(f);
    return *this;
}

Layout::Newshape& Layout::Newshape::visible(enum Visible f) {
    json["visible"] = to_string(f);
    return *this;
}

std::string Layout::Newshape::Label::to_string(Xanchor e) {
    switch(e) {
        case Xanchor::AUTO: return "auto";
        case Xanchor::LEFT: return "left";
        case Xanchor::CENTER: return "center";
        case Xanchor::RIGHT: return "right";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Newshape::Label::to_string(Yanchor e) {
    switch(e) {
        case Yanchor::TOP: return "top";
        case Yanchor::MIDDLE: return "middle";
        case Yanchor::BOTTOM: return "bottom";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Newshape::Label& Layout::Newshape::Label::font(Font f) {
    json["font"] = std::move(f.json);
    return *this;
}

Layout::Newshape::Label& Layout::Newshape::Label::padding(double f) {
    json["padding"] = std::move(f);
    return *this;
}

Layout::Newshape::Label& Layout::Newshape::Label::text(std::string f) {
    json["text"] = std::move(f);
    return *this;
}

Layout::Newshape::Label& Layout::Newshape::Label::textangle(double f) {
    json["textangle"] = std::move(f);
    return *this;
}

Layout::Newshape::Label& Layout::Newshape::Label::textposition(std::string f) {
    json["textposition"] = std::move(f);
    return *this;
}

Layout::Newshape::Label& Layout::Newshape::Label::texttemplate(std::string f) {
    json["texttemplate"] = std::move(f);
    return *this;
}

Layout::Newshape::Label& Layout::Newshape::Label::xanchor(enum Xanchor f) {
    json["xanchor"] = to_string(f);
    return *this;
}

Layout::Newshape::Label& Layout::Newshape::Label::yanchor(enum Yanchor f) {
    json["yanchor"] = to_string(f);
    return *this;
}

std::string Layout::Newshape::Label::Font::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Newshape::Label::Font& Layout::Newshape::Label::Font::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Newshape::Label::Font& Layout::Newshape::Label::Font::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Newshape::Label::Font& Layout::Newshape::Label::Font::lineposition(std::string f) {
    json["lineposition"] = std::move(f);
    return *this;
}

Layout::Newshape::Label::Font& Layout::Newshape::Label::Font::shadow(std::string f) {
    json["shadow"] = std::move(f);
    return *this;
}

Layout::Newshape::Label::Font& Layout::Newshape::Label::Font::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Newshape::Label::Font& Layout::Newshape::Label::Font::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Newshape::Label::Font& Layout::Newshape::Label::Font::textcase(std::string f) {
    json["textcase"] = std::move(f);
    return *this;
}

Layout::Newshape::Label::Font& Layout::Newshape::Label::Font::variant(std::string f) {
    json["variant"] = std::move(f);
    return *this;
}

Layout::Newshape::Label::Font& Layout::Newshape::Label::Font::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}


Layout::Newshape::Legendgrouptitle& Layout::Newshape::Legendgrouptitle::font(Font f) {
    json["font"] = std::move(f.json);
    return *this;
}

Layout::Newshape::Legendgrouptitle& Layout::Newshape::Legendgrouptitle::text(std::string f) {
    json["text"] = std::move(f);
    return *this;
}

std::string Layout::Newshape::Legendgrouptitle::Font::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Newshape::Legendgrouptitle::Font& Layout::Newshape::Legendgrouptitle::Font::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Newshape::Legendgrouptitle::Font& Layout::Newshape::Legendgrouptitle::Font::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Newshape::Legendgrouptitle::Font& Layout::Newshape::Legendgrouptitle::Font::lineposition(std::string f) {
    json["lineposition"] = std::move(f);
    return *this;
}

Layout::Newshape::Legendgrouptitle::Font& Layout::Newshape::Legendgrouptitle::Font::shadow(std::string f) {
    json["shadow"] = std::move(f);
    return *this;
}

Layout::Newshape::Legendgrouptitle::Font& Layout::Newshape::Legendgrouptitle::Font::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Newshape::Legendgrouptitle::Font& Layout::Newshape::Legendgrouptitle::Font::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Newshape::Legendgrouptitle::Font& Layout::Newshape::Legendgrouptitle::Font::textcase(std::string f) {
    json["textcase"] = std::move(f);
    return *this;
}

Layout::Newshape::Legendgrouptitle::Font& Layout::Newshape::Legendgrouptitle::Font::variant(std::string f) {
    json["variant"] = std::move(f);
    return *this;
}

Layout::Newshape::Legendgrouptitle::Font& Layout::Newshape::Legendgrouptitle::Font::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}


Layout::Newshape::Line& Layout::Newshape::Line::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Newshape::Line& Layout::Newshape::Line::dash(std::string f) {
    json["dash"] = std::move(f);
    return *this;
}

Layout::Newshape::Line& Layout::Newshape::Line::width(double f) {
    json["width"] = std::move(f);
    return *this;
}

std::string Layout::Polar::to_string(Gridshape e) {
    switch(e) {
        case Gridshape::CIRCULAR: return "circular";
        case Gridshape::LINEAR: return "linear";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Polar& Layout::Polar::angularaxis(Angularaxis f) {
    json["angularaxis"] = std::move(f.json);
    return *this;
}

Layout::Polar& Layout::Polar::bgcolor(std::string f) {
    json["bgcolor"] = std::move(f);
    return *this;
}

Layout::Polar& Layout::Polar::domain(Domain f) {
    json["domain"] = std::move(f.json);
    return *this;
}

Layout::Polar& Layout::Polar::gridshape(enum Gridshape f) {
    json["gridshape"] = to_string(f);
    return *this;
}

Layout::Polar& Layout::Polar::hole(double f) {
    json["hole"] = std::move(f);
    return *this;
}

Layout::Polar& Layout::Polar::radialaxis(Radialaxis f) {
    json["radialaxis"] = std::move(f.json);
    return *this;
}

Layout::Polar& Layout::Polar::sector(std::vector<double> f) {
    json["sector"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Polar& Layout::Polar::uirevision(T f) {
    json["uirevision"] = std::move(f);
    return *this;
}

std::string Layout::Polar::Angularaxis::to_string(Direction e) {
    switch(e) {
        case Direction::COUNTERCLOCKWISE: return "counterclockwise";
        case Direction::CLOCKWISE: return "clockwise";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Polar::Angularaxis::to_string(Exponentformat e) {
    switch(e) {
        case Exponentformat::NONE: return "none";
        case Exponentformat::E: return "E";
        case Exponentformat::POWER: return "power";
        case Exponentformat::SI: return "SI";
        case Exponentformat::B: return "B";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Polar::Angularaxis::to_string(Showexponent e) {
    switch(e) {
        case Showexponent::ALL: return "all";
        case Showexponent::FIRST: return "first";
        case Showexponent::LAST: return "last";
        case Showexponent::NONE: return "none";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Polar::Angularaxis::to_string(Showtickprefix e) {
    switch(e) {
        case Showtickprefix::ALL: return "all";
        case Showtickprefix::FIRST: return "first";
        case Showtickprefix::LAST: return "last";
        case Showtickprefix::NONE: return "none";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Polar::Angularaxis::to_string(Showticksuffix e) {
    switch(e) {
        case Showticksuffix::ALL: return "all";
        case Showticksuffix::FIRST: return "first";
        case Showticksuffix::LAST: return "last";
        case Showticksuffix::NONE: return "none";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Polar::Angularaxis::to_string(Thetaunit e) {
    switch(e) {
        case Thetaunit::RADIANS: return "radians";
        case Thetaunit::DEGREES: return "degrees";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Polar::Angularaxis::to_string(Tickmode e) {
    switch(e) {
        case Tickmode::AUTO: return "auto";
        case Tickmode::LINEAR: return "linear";
        case Tickmode::ARRAY: return "array";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Polar::Angularaxis::to_string(Ticks e) {
    switch(e) {
        case Ticks::OUTSIDE: return "outside";
        case Ticks::INSIDE: return "inside";
        case Ticks::EMPTY: return "";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::autotypenumbers(std::string f) {
    json["autotypenumbers"] = std::move(f);
    return *this;
}

template <typename T, typename>
Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::categoryarray(std::vector<T> f) {
    json["categoryarray"] = std::move(f);
    return *this;
}

Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::categoryarraysrc(std::string f) {
    json["categoryarraysrc"] = std::move(f);
    return *this;
}

Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::categoryorder(std::string f) {
    json["categoryorder"] = std::move(f);
    return *this;
}

Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::direction(enum Direction f) {
    json["direction"] = to_string(f);
    return *this;
}

template <typename T>
Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::dtick(T f) {
    json["dtick"] = std::move(f);
    return *this;
}

Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::exponentformat(enum Exponentformat f) {
    json["exponentformat"] = to_string(f);
    return *this;
}

Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::gridcolor(std::string f) {
    json["gridcolor"] = std::move(f);
    return *this;
}

Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::griddash(std::string f) {
    json["griddash"] = std::move(f);
    return *this;
}

Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::gridwidth(double f) {
    json["gridwidth"] = std::move(f);
    return *this;
}

Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::hoverformat(std::string f) {
    json["hoverformat"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::labelalias(T f) {
    json["labelalias"] = std::move(f);
    return *this;
}

Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::layer(std::string f) {
    json["layer"] = std::move(f);
    return *this;
}

Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::linecolor(std::string f) {
    json["linecolor"] = std::move(f);
    return *this;
}

Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::linewidth(double f) {
    json["linewidth"] = std::move(f);
    return *this;
}

Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::minexponent(double f) {
    json["minexponent"] = std::move(f);
    return *this;
}

Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::nticks(int f) {
    json["nticks"] = std::move(f);
    return *this;
}

Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::period(double f) {
    json["period"] = std::move(f);
    return *this;
}

Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::rotation(double f) {
    json["rotation"] = std::move(f);
    return *this;
}

Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::separatethousands(bool f) {
    json["separatethousands"] = std::move(f);
    return *this;
}

Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::showexponent(enum Showexponent f) {
    json["showexponent"] = to_string(f);
    return *this;
}

Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::showgrid(bool f) {
    json["showgrid"] = std::move(f);
    return *this;
}

Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::showline(bool f) {
    json["showline"] = std::move(f);
    return *this;
}

Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::showticklabels(bool f) {
    json["showticklabels"] = std::move(f);
    return *this;
}

Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::showtickprefix(enum Showtickprefix f) {
    json["showtickprefix"] = to_string(f);
    return *this;
}

Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::showticksuffix(enum Showticksuffix f) {
    json["showticksuffix"] = to_string(f);
    return *this;
}

Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::thetaunit(enum Thetaunit f) {
    json["thetaunit"] = to_string(f);
    return *this;
}

template <typename T>
Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::tick0(T f) {
    json["tick0"] = std::move(f);
    return *this;
}

Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::tickangle(double f) {
    json["tickangle"] = std::move(f);
    return *this;
}

Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::tickcolor(std::string f) {
    json["tickcolor"] = std::move(f);
    return *this;
}

Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::tickfont(Tickfont f) {
    json["tickfont"] = std::move(f.json);
    return *this;
}

Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::tickformat(std::string f) {
    json["tickformat"] = std::move(f);
    return *this;
}

Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::tickformatstops(Tickformatstops f) {
    json["tickformatstops"] = std::move(f.json);
    return *this;
}

Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::ticklabelstep(int f) {
    json["ticklabelstep"] = std::move(f);
    return *this;
}

Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::ticklen(double f) {
    json["ticklen"] = std::move(f);
    return *this;
}

Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::tickmode(enum Tickmode f) {
    json["tickmode"] = to_string(f);
    return *this;
}

Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::tickprefix(std::string f) {
    json["tickprefix"] = std::move(f);
    return *this;
}

Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::ticks(enum Ticks f) {
    json["ticks"] = to_string(f);
    return *this;
}

Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::ticksuffix(std::string f) {
    json["ticksuffix"] = std::move(f);
    return *this;
}

template <typename T, typename>
Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::ticktext(std::vector<T> f) {
    json["ticktext"] = std::move(f);
    return *this;
}

Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::ticktextsrc(std::string f) {
    json["ticktextsrc"] = std::move(f);
    return *this;
}

template <typename T, typename>
Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::tickvals(std::vector<T> f) {
    json["tickvals"] = std::move(f);
    return *this;
}

Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::tickvalssrc(std::string f) {
    json["tickvalssrc"] = std::move(f);
    return *this;
}

Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::tickwidth(double f) {
    json["tickwidth"] = std::move(f);
    return *this;
}

Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::type(std::string f) {
    json["type"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::uirevision(T f) {
    json["uirevision"] = std::move(f);
    return *this;
}

Layout::Polar::Angularaxis& Layout::Polar::Angularaxis::visible(bool f) {
    json["visible"] = std::move(f);
    return *this;
}

std::string Layout::Polar::Angularaxis::Tickfont::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Polar::Angularaxis::Tickfont& Layout::Polar::Angularaxis::Tickfont::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Polar::Angularaxis::Tickfont& Layout::Polar::Angularaxis::Tickfont::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Polar::Angularaxis::Tickfont& Layout::Polar::Angularaxis::Tickfont::lineposition(std::string f) {
    json["lineposition"] = std::move(f);
    return *this;
}

Layout::Polar::Angularaxis::Tickfont& Layout::Polar::Angularaxis::Tickfont::shadow(std::string f) {
    json["shadow"] = std::move(f);
    return *this;
}

Layout::Polar::Angularaxis::Tickfont& Layout::Polar::Angularaxis::Tickfont::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Polar::Angularaxis::Tickfont& Layout::Polar::Angularaxis::Tickfont::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Polar::Angularaxis::Tickfont& Layout::Polar::Angularaxis::Tickfont::textcase(std::string f) {
    json["textcase"] = std::move(f);
    return *this;
}

Layout::Polar::Angularaxis::Tickfont& Layout::Polar::Angularaxis::Tickfont::variant(std::string f) {
    json["variant"] = std::move(f);
    return *this;
}

Layout::Polar::Angularaxis::Tickfont& Layout::Polar::Angularaxis::Tickfont::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}


Layout::Polar::Angularaxis::Tickformatstops& Layout::Polar::Angularaxis::Tickformatstops::tickformatstop(Tickformatstop f) {
    json["tickformatstop"] = std::move(f.json);
    return *this;
}


Layout::Polar::Angularaxis::Tickformatstops::Tickformatstop& Layout::Polar::Angularaxis::Tickformatstops::Tickformatstop::dtickrange(std::vector<double> f) {
    json["dtickrange"] = std::move(f);
    return *this;
}

Layout::Polar::Angularaxis::Tickformatstops::Tickformatstop& Layout::Polar::Angularaxis::Tickformatstops::Tickformatstop::enabled(bool f) {
    json["enabled"] = std::move(f);
    return *this;
}

Layout::Polar::Angularaxis::Tickformatstops::Tickformatstop& Layout::Polar::Angularaxis::Tickformatstops::Tickformatstop::name(std::string f) {
    json["name"] = std::move(f);
    return *this;
}

Layout::Polar::Angularaxis::Tickformatstops::Tickformatstop& Layout::Polar::Angularaxis::Tickformatstops::Tickformatstop::templateitemname(std::string f) {
    json["templateitemname"] = std::move(f);
    return *this;
}

Layout::Polar::Angularaxis::Tickformatstops::Tickformatstop& Layout::Polar::Angularaxis::Tickformatstops::Tickformatstop::value(std::string f) {
    json["value"] = std::move(f);
    return *this;
}


Layout::Polar::Domain& Layout::Polar::Domain::column(int f) {
    json["column"] = std::move(f);
    return *this;
}

Layout::Polar::Domain& Layout::Polar::Domain::row(int f) {
    json["row"] = std::move(f);
    return *this;
}

Layout::Polar::Domain& Layout::Polar::Domain::x(std::vector<double> f) {
    json["x"] = std::move(f);
    return *this;
}

Layout::Polar::Domain& Layout::Polar::Domain::y(std::vector<double> f) {
    json["y"] = std::move(f);
    return *this;
}

std::string Layout::Polar::Radialaxis::to_string(Calendar e) {
    switch(e) {
        case Calendar::CHINESE: return "chinese";
        case Calendar::COPTIC: return "coptic";
        case Calendar::DISCWORLD: return "discworld";
        case Calendar::ETHIOPIAN: return "ethiopian";
        case Calendar::GREGORIAN: return "gregorian";
        case Calendar::HEBREW: return "hebrew";
        case Calendar::ISLAMIC: return "islamic";
        case Calendar::JALALI: return "jalali";
        case Calendar::JULIAN: return "julian";
        case Calendar::MAYAN: return "mayan";
        case Calendar::NANAKSHAHI: return "nanakshahi";
        case Calendar::NEPALI: return "nepali";
        case Calendar::PERSIAN: return "persian";
        case Calendar::TAIWAN: return "taiwan";
        case Calendar::THAI: return "thai";
        case Calendar::UMMALQURA: return "ummalqura";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Polar::Radialaxis::to_string(Exponentformat e) {
    switch(e) {
        case Exponentformat::NONE: return "none";
        case Exponentformat::E: return "E";
        case Exponentformat::POWER: return "power";
        case Exponentformat::SI: return "SI";
        case Exponentformat::B: return "B";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Polar::Radialaxis::to_string(Rangemode e) {
    switch(e) {
        case Rangemode::TOZERO: return "tozero";
        case Rangemode::NONNEGATIVE: return "nonnegative";
        case Rangemode::NORMAL: return "normal";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Polar::Radialaxis::to_string(Showexponent e) {
    switch(e) {
        case Showexponent::ALL: return "all";
        case Showexponent::FIRST: return "first";
        case Showexponent::LAST: return "last";
        case Showexponent::NONE: return "none";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Polar::Radialaxis::to_string(Showtickprefix e) {
    switch(e) {
        case Showtickprefix::ALL: return "all";
        case Showtickprefix::FIRST: return "first";
        case Showtickprefix::LAST: return "last";
        case Showtickprefix::NONE: return "none";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Polar::Radialaxis::to_string(Showticksuffix e) {
    switch(e) {
        case Showticksuffix::ALL: return "all";
        case Showticksuffix::FIRST: return "first";
        case Showticksuffix::LAST: return "last";
        case Showticksuffix::NONE: return "none";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Polar::Radialaxis::to_string(Side e) {
    switch(e) {
        case Side::CLOCKWISE: return "clockwise";
        case Side::COUNTERCLOCKWISE: return "counterclockwise";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Polar::Radialaxis::to_string(Tickmode e) {
    switch(e) {
        case Tickmode::AUTO: return "auto";
        case Tickmode::LINEAR: return "linear";
        case Tickmode::ARRAY: return "array";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Polar::Radialaxis::to_string(Ticks e) {
    switch(e) {
        case Ticks::OUTSIDE: return "outside";
        case Ticks::INSIDE: return "inside";
        case Ticks::EMPTY: return "";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::angle(double f) {
    json["angle"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::autorange(std::string f) {
    json["autorange"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::autorangeoptions(Autorangeoptions f) {
    json["autorangeoptions"] = std::move(f.json);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::autotickangles(std::vector<double> f) {
    json["autotickangles"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::autotypenumbers(std::string f) {
    json["autotypenumbers"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::calendar(enum Calendar f) {
    json["calendar"] = to_string(f);
    return *this;
}

template <typename T, typename>
Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::categoryarray(std::vector<T> f) {
    json["categoryarray"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::categoryarraysrc(std::string f) {
    json["categoryarraysrc"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::categoryorder(std::string f) {
    json["categoryorder"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::dtick(T f) {
    json["dtick"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::exponentformat(enum Exponentformat f) {
    json["exponentformat"] = to_string(f);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::gridcolor(std::string f) {
    json["gridcolor"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::griddash(std::string f) {
    json["griddash"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::gridwidth(double f) {
    json["gridwidth"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::hoverformat(std::string f) {
    json["hoverformat"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::labelalias(T f) {
    json["labelalias"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::layer(std::string f) {
    json["layer"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::linecolor(std::string f) {
    json["linecolor"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::linewidth(double f) {
    json["linewidth"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::maxallowed(T f) {
    json["maxallowed"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::minallowed(T f) {
    json["minallowed"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::minexponent(double f) {
    json["minexponent"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::nticks(int f) {
    json["nticks"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::range(std::vector<double> f) {
    json["range"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::rangemode(enum Rangemode f) {
    json["rangemode"] = to_string(f);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::separatethousands(bool f) {
    json["separatethousands"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::showexponent(enum Showexponent f) {
    json["showexponent"] = to_string(f);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::showgrid(bool f) {
    json["showgrid"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::showline(bool f) {
    json["showline"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::showticklabels(bool f) {
    json["showticklabels"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::showtickprefix(enum Showtickprefix f) {
    json["showtickprefix"] = to_string(f);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::showticksuffix(enum Showticksuffix f) {
    json["showticksuffix"] = to_string(f);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::side(enum Side f) {
    json["side"] = to_string(f);
    return *this;
}

template <typename T>
Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::tick0(T f) {
    json["tick0"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::tickangle(double f) {
    json["tickangle"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::tickcolor(std::string f) {
    json["tickcolor"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::tickfont(Tickfont f) {
    json["tickfont"] = std::move(f.json);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::tickformat(std::string f) {
    json["tickformat"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::tickformatstops(Tickformatstops f) {
    json["tickformatstops"] = std::move(f.json);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::ticklabelstep(int f) {
    json["ticklabelstep"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::ticklen(double f) {
    json["ticklen"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::tickmode(enum Tickmode f) {
    json["tickmode"] = to_string(f);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::tickprefix(std::string f) {
    json["tickprefix"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::ticks(enum Ticks f) {
    json["ticks"] = to_string(f);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::ticksuffix(std::string f) {
    json["ticksuffix"] = std::move(f);
    return *this;
}

template <typename T, typename>
Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::ticktext(std::vector<T> f) {
    json["ticktext"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::ticktextsrc(std::string f) {
    json["ticktextsrc"] = std::move(f);
    return *this;
}

template <typename T, typename>
Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::tickvals(std::vector<T> f) {
    json["tickvals"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::tickvalssrc(std::string f) {
    json["tickvalssrc"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::tickwidth(double f) {
    json["tickwidth"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::title(Title f) {
    json["title"] = std::move(f.json);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::type(std::string f) {
    json["type"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::uirevision(T f) {
    json["uirevision"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis& Layout::Polar::Radialaxis::visible(bool f) {
    json["visible"] = std::move(f);
    return *this;
}


template <typename T>
Layout::Polar::Radialaxis::Autorangeoptions& Layout::Polar::Radialaxis::Autorangeoptions::clipmax(T f) {
    json["clipmax"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Polar::Radialaxis::Autorangeoptions& Layout::Polar::Radialaxis::Autorangeoptions::clipmin(T f) {
    json["clipmin"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Polar::Radialaxis::Autorangeoptions& Layout::Polar::Radialaxis::Autorangeoptions::include(T f) {
    json["include"] = std::move(f);
    return *this;
}
template <typename T>
Layout::Polar::Radialaxis::Autorangeoptions& Layout::Polar::Radialaxis::Autorangeoptions::include(std::vector<T> f) {
    json["include"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis::Autorangeoptions& Layout::Polar::Radialaxis::Autorangeoptions::includesrc(std::string f) {
    json["includesrc"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Polar::Radialaxis::Autorangeoptions& Layout::Polar::Radialaxis::Autorangeoptions::maxallowed(T f) {
    json["maxallowed"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Polar::Radialaxis::Autorangeoptions& Layout::Polar::Radialaxis::Autorangeoptions::minallowed(T f) {
    json["minallowed"] = std::move(f);
    return *this;
}

std::string Layout::Polar::Radialaxis::Tickfont::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Polar::Radialaxis::Tickfont& Layout::Polar::Radialaxis::Tickfont::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis::Tickfont& Layout::Polar::Radialaxis::Tickfont::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis::Tickfont& Layout::Polar::Radialaxis::Tickfont::lineposition(std::string f) {
    json["lineposition"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis::Tickfont& Layout::Polar::Radialaxis::Tickfont::shadow(std::string f) {
    json["shadow"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis::Tickfont& Layout::Polar::Radialaxis::Tickfont::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis::Tickfont& Layout::Polar::Radialaxis::Tickfont::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Polar::Radialaxis::Tickfont& Layout::Polar::Radialaxis::Tickfont::textcase(std::string f) {
    json["textcase"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis::Tickfont& Layout::Polar::Radialaxis::Tickfont::variant(std::string f) {
    json["variant"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis::Tickfont& Layout::Polar::Radialaxis::Tickfont::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}


Layout::Polar::Radialaxis::Tickformatstops& Layout::Polar::Radialaxis::Tickformatstops::tickformatstop(Tickformatstop f) {
    json["tickformatstop"] = std::move(f.json);
    return *this;
}


Layout::Polar::Radialaxis::Tickformatstops::Tickformatstop& Layout::Polar::Radialaxis::Tickformatstops::Tickformatstop::dtickrange(std::vector<double> f) {
    json["dtickrange"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis::Tickformatstops::Tickformatstop& Layout::Polar::Radialaxis::Tickformatstops::Tickformatstop::enabled(bool f) {
    json["enabled"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis::Tickformatstops::Tickformatstop& Layout::Polar::Radialaxis::Tickformatstops::Tickformatstop::name(std::string f) {
    json["name"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis::Tickformatstops::Tickformatstop& Layout::Polar::Radialaxis::Tickformatstops::Tickformatstop::templateitemname(std::string f) {
    json["templateitemname"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis::Tickformatstops::Tickformatstop& Layout::Polar::Radialaxis::Tickformatstops::Tickformatstop::value(std::string f) {
    json["value"] = std::move(f);
    return *this;
}


Layout::Polar::Radialaxis::Title& Layout::Polar::Radialaxis::Title::font(Font f) {
    json["font"] = std::move(f.json);
    return *this;
}

Layout::Polar::Radialaxis::Title& Layout::Polar::Radialaxis::Title::text(std::string f) {
    json["text"] = std::move(f);
    return *this;
}

std::string Layout::Polar::Radialaxis::Title::Font::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Polar::Radialaxis::Title::Font& Layout::Polar::Radialaxis::Title::Font::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis::Title::Font& Layout::Polar::Radialaxis::Title::Font::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis::Title::Font& Layout::Polar::Radialaxis::Title::Font::lineposition(std::string f) {
    json["lineposition"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis::Title::Font& Layout::Polar::Radialaxis::Title::Font::shadow(std::string f) {
    json["shadow"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis::Title::Font& Layout::Polar::Radialaxis::Title::Font::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis::Title::Font& Layout::Polar::Radialaxis::Title::Font::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Polar::Radialaxis::Title::Font& Layout::Polar::Radialaxis::Title::Font::textcase(std::string f) {
    json["textcase"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis::Title::Font& Layout::Polar::Radialaxis::Title::Font::variant(std::string f) {
    json["variant"] = std::move(f);
    return *this;
}

Layout::Polar::Radialaxis::Title::Font& Layout::Polar::Radialaxis::Title::Font::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}

std::string Layout::Scene::to_string(Aspectmode e) {
    switch(e) {
        case Aspectmode::AUTO: return "auto";
        case Aspectmode::CUBE: return "cube";
        case Aspectmode::DATA: return "data";
        case Aspectmode::MANUAL: return "manual";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Scene::to_string(Dragmode e) {
    switch(e) {
        case Dragmode::ORBIT: return "orbit";
        case Dragmode::TURNTABLE: return "turntable";
        case Dragmode::ZOOM: return "zoom";
        case Dragmode::PAN: return "pan";
        case Dragmode::FALSE: return "False";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Scene::to_string(Hovermode e) {
    switch(e) {
        case Hovermode::CLOSEST: return "closest";
        case Hovermode::FALSE: return "False";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Scene& Layout::Scene::annotations(Annotations f) {
    json["annotations"] = std::move(f.json);
    return *this;
}

Layout::Scene& Layout::Scene::aspectmode(enum Aspectmode f) {
    json["aspectmode"] = to_string(f);
    return *this;
}

Layout::Scene& Layout::Scene::aspectratio(Aspectratio f) {
    json["aspectratio"] = std::move(f.json);
    return *this;
}

Layout::Scene& Layout::Scene::bgcolor(std::string f) {
    json["bgcolor"] = std::move(f);
    return *this;
}

Layout::Scene& Layout::Scene::camera(Camera f) {
    json["camera"] = std::move(f.json);
    return *this;
}

Layout::Scene& Layout::Scene::domain(Domain f) {
    json["domain"] = std::move(f.json);
    return *this;
}

Layout::Scene& Layout::Scene::dragmode(enum Dragmode f) {
    json["dragmode"] = to_string(f);
    return *this;
}

Layout::Scene& Layout::Scene::hovermode(enum Hovermode f) {
    json["hovermode"] = to_string(f);
    return *this;
}

template <typename T>
Layout::Scene& Layout::Scene::uirevision(T f) {
    json["uirevision"] = std::move(f);
    return *this;
}

Layout::Scene& Layout::Scene::xaxis(Xaxis f) {
    json["xaxis"] = std::move(f.json);
    return *this;
}

Layout::Scene& Layout::Scene::yaxis(Yaxis f) {
    json["yaxis"] = std::move(f.json);
    return *this;
}

Layout::Scene& Layout::Scene::zaxis(Zaxis f) {
    json["zaxis"] = std::move(f.json);
    return *this;
}


Layout::Scene::Annotations& Layout::Scene::Annotations::annotation(Annotation f) {
    json["annotation"] = std::move(f.json);
    return *this;
}

std::string Layout::Scene::Annotations::Annotation::to_string(Align e) {
    switch(e) {
        case Align::LEFT: return "left";
        case Align::CENTER: return "center";
        case Align::RIGHT: return "right";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Scene::Annotations::Annotation::to_string(Valign e) {
    switch(e) {
        case Valign::TOP: return "top";
        case Valign::MIDDLE: return "middle";
        case Valign::BOTTOM: return "bottom";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Scene::Annotations::Annotation::to_string(Xanchor e) {
    switch(e) {
        case Xanchor::AUTO: return "auto";
        case Xanchor::LEFT: return "left";
        case Xanchor::CENTER: return "center";
        case Xanchor::RIGHT: return "right";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Scene::Annotations::Annotation::to_string(Yanchor e) {
    switch(e) {
        case Yanchor::AUTO: return "auto";
        case Yanchor::TOP: return "top";
        case Yanchor::MIDDLE: return "middle";
        case Yanchor::BOTTOM: return "bottom";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Scene::Annotations::Annotation& Layout::Scene::Annotations::Annotation::align(enum Align f) {
    json["align"] = to_string(f);
    return *this;
}

Layout::Scene::Annotations::Annotation& Layout::Scene::Annotations::Annotation::arrowcolor(std::string f) {
    json["arrowcolor"] = std::move(f);
    return *this;
}

Layout::Scene::Annotations::Annotation& Layout::Scene::Annotations::Annotation::arrowhead(int f) {
    json["arrowhead"] = std::move(f);
    return *this;
}

Layout::Scene::Annotations::Annotation& Layout::Scene::Annotations::Annotation::arrowside(std::string f) {
    json["arrowside"] = std::move(f);
    return *this;
}

Layout::Scene::Annotations::Annotation& Layout::Scene::Annotations::Annotation::arrowsize(double f) {
    json["arrowsize"] = std::move(f);
    return *this;
}

Layout::Scene::Annotations::Annotation& Layout::Scene::Annotations::Annotation::arrowwidth(double f) {
    json["arrowwidth"] = std::move(f);
    return *this;
}

Layout::Scene::Annotations::Annotation& Layout::Scene::Annotations::Annotation::ax(double f) {
    json["ax"] = std::move(f);
    return *this;
}

Layout::Scene::Annotations::Annotation& Layout::Scene::Annotations::Annotation::ay(double f) {
    json["ay"] = std::move(f);
    return *this;
}

Layout::Scene::Annotations::Annotation& Layout::Scene::Annotations::Annotation::bgcolor(std::string f) {
    json["bgcolor"] = std::move(f);
    return *this;
}

Layout::Scene::Annotations::Annotation& Layout::Scene::Annotations::Annotation::bordercolor(std::string f) {
    json["bordercolor"] = std::move(f);
    return *this;
}

Layout::Scene::Annotations::Annotation& Layout::Scene::Annotations::Annotation::borderpad(double f) {
    json["borderpad"] = std::move(f);
    return *this;
}

Layout::Scene::Annotations::Annotation& Layout::Scene::Annotations::Annotation::borderwidth(double f) {
    json["borderwidth"] = std::move(f);
    return *this;
}

Layout::Scene::Annotations::Annotation& Layout::Scene::Annotations::Annotation::captureevents(bool f) {
    json["captureevents"] = std::move(f);
    return *this;
}

Layout::Scene::Annotations::Annotation& Layout::Scene::Annotations::Annotation::font(Font f) {
    json["font"] = std::move(f.json);
    return *this;
}

Layout::Scene::Annotations::Annotation& Layout::Scene::Annotations::Annotation::height(double f) {
    json["height"] = std::move(f);
    return *this;
}

Layout::Scene::Annotations::Annotation& Layout::Scene::Annotations::Annotation::hoverlabel(Hoverlabel f) {
    json["hoverlabel"] = std::move(f.json);
    return *this;
}

Layout::Scene::Annotations::Annotation& Layout::Scene::Annotations::Annotation::hovertext(std::string f) {
    json["hovertext"] = std::move(f);
    return *this;
}

Layout::Scene::Annotations::Annotation& Layout::Scene::Annotations::Annotation::name(std::string f) {
    json["name"] = std::move(f);
    return *this;
}

Layout::Scene::Annotations::Annotation& Layout::Scene::Annotations::Annotation::opacity(double f) {
    json["opacity"] = std::move(f);
    return *this;
}

Layout::Scene::Annotations::Annotation& Layout::Scene::Annotations::Annotation::showarrow(bool f) {
    json["showarrow"] = std::move(f);
    return *this;
}

Layout::Scene::Annotations::Annotation& Layout::Scene::Annotations::Annotation::standoff(double f) {
    json["standoff"] = std::move(f);
    return *this;
}

Layout::Scene::Annotations::Annotation& Layout::Scene::Annotations::Annotation::startarrowhead(int f) {
    json["startarrowhead"] = std::move(f);
    return *this;
}

Layout::Scene::Annotations::Annotation& Layout::Scene::Annotations::Annotation::startarrowsize(double f) {
    json["startarrowsize"] = std::move(f);
    return *this;
}

Layout::Scene::Annotations::Annotation& Layout::Scene::Annotations::Annotation::startstandoff(double f) {
    json["startstandoff"] = std::move(f);
    return *this;
}

Layout::Scene::Annotations::Annotation& Layout::Scene::Annotations::Annotation::templateitemname(std::string f) {
    json["templateitemname"] = std::move(f);
    return *this;
}

Layout::Scene::Annotations::Annotation& Layout::Scene::Annotations::Annotation::text(std::string f) {
    json["text"] = std::move(f);
    return *this;
}

Layout::Scene::Annotations::Annotation& Layout::Scene::Annotations::Annotation::textangle(double f) {
    json["textangle"] = std::move(f);
    return *this;
}

Layout::Scene::Annotations::Annotation& Layout::Scene::Annotations::Annotation::valign(enum Valign f) {
    json["valign"] = to_string(f);
    return *this;
}

Layout::Scene::Annotations::Annotation& Layout::Scene::Annotations::Annotation::visible(bool f) {
    json["visible"] = std::move(f);
    return *this;
}

Layout::Scene::Annotations::Annotation& Layout::Scene::Annotations::Annotation::width(double f) {
    json["width"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Scene::Annotations::Annotation& Layout::Scene::Annotations::Annotation::x(T f) {
    json["x"] = std::move(f);
    return *this;
}

Layout::Scene::Annotations::Annotation& Layout::Scene::Annotations::Annotation::xanchor(enum Xanchor f) {
    json["xanchor"] = to_string(f);
    return *this;
}

Layout::Scene::Annotations::Annotation& Layout::Scene::Annotations::Annotation::xshift(double f) {
    json["xshift"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Scene::Annotations::Annotation& Layout::Scene::Annotations::Annotation::y(T f) {
    json["y"] = std::move(f);
    return *this;
}

Layout::Scene::Annotations::Annotation& Layout::Scene::Annotations::Annotation::yanchor(enum Yanchor f) {
    json["yanchor"] = to_string(f);
    return *this;
}

Layout::Scene::Annotations::Annotation& Layout::Scene::Annotations::Annotation::yshift(double f) {
    json["yshift"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Scene::Annotations::Annotation& Layout::Scene::Annotations::Annotation::z(T f) {
    json["z"] = std::move(f);
    return *this;
}

std::string Layout::Scene::Annotations::Annotation::Font::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Scene::Annotations::Annotation::Font& Layout::Scene::Annotations::Annotation::Font::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Scene::Annotations::Annotation::Font& Layout::Scene::Annotations::Annotation::Font::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Scene::Annotations::Annotation::Font& Layout::Scene::Annotations::Annotation::Font::lineposition(std::string f) {
    json["lineposition"] = std::move(f);
    return *this;
}

Layout::Scene::Annotations::Annotation::Font& Layout::Scene::Annotations::Annotation::Font::shadow(std::string f) {
    json["shadow"] = std::move(f);
    return *this;
}

Layout::Scene::Annotations::Annotation::Font& Layout::Scene::Annotations::Annotation::Font::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Scene::Annotations::Annotation::Font& Layout::Scene::Annotations::Annotation::Font::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Scene::Annotations::Annotation::Font& Layout::Scene::Annotations::Annotation::Font::textcase(std::string f) {
    json["textcase"] = std::move(f);
    return *this;
}

Layout::Scene::Annotations::Annotation::Font& Layout::Scene::Annotations::Annotation::Font::variant(std::string f) {
    json["variant"] = std::move(f);
    return *this;
}

Layout::Scene::Annotations::Annotation::Font& Layout::Scene::Annotations::Annotation::Font::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}


Layout::Scene::Annotations::Annotation::Hoverlabel& Layout::Scene::Annotations::Annotation::Hoverlabel::bgcolor(std::string f) {
    json["bgcolor"] = std::move(f);
    return *this;
}

Layout::Scene::Annotations::Annotation::Hoverlabel& Layout::Scene::Annotations::Annotation::Hoverlabel::bordercolor(std::string f) {
    json["bordercolor"] = std::move(f);
    return *this;
}

Layout::Scene::Annotations::Annotation::Hoverlabel& Layout::Scene::Annotations::Annotation::Hoverlabel::font(Font f) {
    json["font"] = std::move(f.json);
    return *this;
}

std::string Layout::Scene::Annotations::Annotation::Hoverlabel::Font::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Scene::Annotations::Annotation::Hoverlabel::Font& Layout::Scene::Annotations::Annotation::Hoverlabel::Font::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Scene::Annotations::Annotation::Hoverlabel::Font& Layout::Scene::Annotations::Annotation::Hoverlabel::Font::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Scene::Annotations::Annotation::Hoverlabel::Font& Layout::Scene::Annotations::Annotation::Hoverlabel::Font::lineposition(std::string f) {
    json["lineposition"] = std::move(f);
    return *this;
}

Layout::Scene::Annotations::Annotation::Hoverlabel::Font& Layout::Scene::Annotations::Annotation::Hoverlabel::Font::shadow(std::string f) {
    json["shadow"] = std::move(f);
    return *this;
}

Layout::Scene::Annotations::Annotation::Hoverlabel::Font& Layout::Scene::Annotations::Annotation::Hoverlabel::Font::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Scene::Annotations::Annotation::Hoverlabel::Font& Layout::Scene::Annotations::Annotation::Hoverlabel::Font::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Scene::Annotations::Annotation::Hoverlabel::Font& Layout::Scene::Annotations::Annotation::Hoverlabel::Font::textcase(std::string f) {
    json["textcase"] = std::move(f);
    return *this;
}

Layout::Scene::Annotations::Annotation::Hoverlabel::Font& Layout::Scene::Annotations::Annotation::Hoverlabel::Font::variant(std::string f) {
    json["variant"] = std::move(f);
    return *this;
}

Layout::Scene::Annotations::Annotation::Hoverlabel::Font& Layout::Scene::Annotations::Annotation::Hoverlabel::Font::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}


Layout::Scene::Aspectratio& Layout::Scene::Aspectratio::impliedEdits(Impliededits f) {
    json["impliedEdits"] = std::move(f.json);
    return *this;
}

Layout::Scene::Aspectratio& Layout::Scene::Aspectratio::x(double f) {
    json["x"] = std::move(f);
    return *this;
}

Layout::Scene::Aspectratio& Layout::Scene::Aspectratio::y(double f) {
    json["y"] = std::move(f);
    return *this;
}

Layout::Scene::Aspectratio& Layout::Scene::Aspectratio::z(double f) {
    json["z"] = std::move(f);
    return *this;
}



Layout::Scene::Camera& Layout::Scene::Camera::center(Center f) {
    json["center"] = std::move(f.json);
    return *this;
}

Layout::Scene::Camera& Layout::Scene::Camera::eye(Eye f) {
    json["eye"] = std::move(f.json);
    return *this;
}

Layout::Scene::Camera& Layout::Scene::Camera::projection(Projection f) {
    json["projection"] = std::move(f.json);
    return *this;
}

Layout::Scene::Camera& Layout::Scene::Camera::up(Up f) {
    json["up"] = std::move(f.json);
    return *this;
}


Layout::Scene::Camera::Center& Layout::Scene::Camera::Center::x(double f) {
    json["x"] = std::move(f);
    return *this;
}

Layout::Scene::Camera::Center& Layout::Scene::Camera::Center::y(double f) {
    json["y"] = std::move(f);
    return *this;
}

Layout::Scene::Camera::Center& Layout::Scene::Camera::Center::z(double f) {
    json["z"] = std::move(f);
    return *this;
}


Layout::Scene::Camera::Eye& Layout::Scene::Camera::Eye::x(double f) {
    json["x"] = std::move(f);
    return *this;
}

Layout::Scene::Camera::Eye& Layout::Scene::Camera::Eye::y(double f) {
    json["y"] = std::move(f);
    return *this;
}

Layout::Scene::Camera::Eye& Layout::Scene::Camera::Eye::z(double f) {
    json["z"] = std::move(f);
    return *this;
}

std::string Layout::Scene::Camera::Projection::to_string(Type e) {
    switch(e) {
        case Type::PERSPECTIVE: return "perspective";
        case Type::ORTHOGRAPHIC: return "orthographic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Scene::Camera::Projection& Layout::Scene::Camera::Projection::type(enum Type f) {
    json["type"] = to_string(f);
    return *this;
}


Layout::Scene::Camera::Up& Layout::Scene::Camera::Up::x(double f) {
    json["x"] = std::move(f);
    return *this;
}

Layout::Scene::Camera::Up& Layout::Scene::Camera::Up::y(double f) {
    json["y"] = std::move(f);
    return *this;
}

Layout::Scene::Camera::Up& Layout::Scene::Camera::Up::z(double f) {
    json["z"] = std::move(f);
    return *this;
}


Layout::Scene::Domain& Layout::Scene::Domain::column(int f) {
    json["column"] = std::move(f);
    return *this;
}

Layout::Scene::Domain& Layout::Scene::Domain::row(int f) {
    json["row"] = std::move(f);
    return *this;
}

Layout::Scene::Domain& Layout::Scene::Domain::x(std::vector<double> f) {
    json["x"] = std::move(f);
    return *this;
}

Layout::Scene::Domain& Layout::Scene::Domain::y(std::vector<double> f) {
    json["y"] = std::move(f);
    return *this;
}

std::string Layout::Scene::Xaxis::to_string(Calendar e) {
    switch(e) {
        case Calendar::CHINESE: return "chinese";
        case Calendar::COPTIC: return "coptic";
        case Calendar::DISCWORLD: return "discworld";
        case Calendar::ETHIOPIAN: return "ethiopian";
        case Calendar::GREGORIAN: return "gregorian";
        case Calendar::HEBREW: return "hebrew";
        case Calendar::ISLAMIC: return "islamic";
        case Calendar::JALALI: return "jalali";
        case Calendar::JULIAN: return "julian";
        case Calendar::MAYAN: return "mayan";
        case Calendar::NANAKSHAHI: return "nanakshahi";
        case Calendar::NEPALI: return "nepali";
        case Calendar::PERSIAN: return "persian";
        case Calendar::TAIWAN: return "taiwan";
        case Calendar::THAI: return "thai";
        case Calendar::UMMALQURA: return "ummalqura";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Scene::Xaxis::to_string(Exponentformat e) {
    switch(e) {
        case Exponentformat::NONE: return "none";
        case Exponentformat::E: return "E";
        case Exponentformat::POWER: return "power";
        case Exponentformat::SI: return "SI";
        case Exponentformat::B: return "B";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Scene::Xaxis::to_string(Mirror e) {
    switch(e) {
        case Mirror::TRUE: return "True";
        case Mirror::TICKS: return "ticks";
        case Mirror::FALSE: return "False";
        case Mirror::ALL: return "all";
        case Mirror::ALLTICKS: return "allticks";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Scene::Xaxis::to_string(Rangemode e) {
    switch(e) {
        case Rangemode::NORMAL: return "normal";
        case Rangemode::TOZERO: return "tozero";
        case Rangemode::NONNEGATIVE: return "nonnegative";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Scene::Xaxis::to_string(Showexponent e) {
    switch(e) {
        case Showexponent::ALL: return "all";
        case Showexponent::FIRST: return "first";
        case Showexponent::LAST: return "last";
        case Showexponent::NONE: return "none";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Scene::Xaxis::to_string(Showtickprefix e) {
    switch(e) {
        case Showtickprefix::ALL: return "all";
        case Showtickprefix::FIRST: return "first";
        case Showtickprefix::LAST: return "last";
        case Showtickprefix::NONE: return "none";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Scene::Xaxis::to_string(Showticksuffix e) {
    switch(e) {
        case Showticksuffix::ALL: return "all";
        case Showticksuffix::FIRST: return "first";
        case Showticksuffix::LAST: return "last";
        case Showticksuffix::NONE: return "none";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Scene::Xaxis::to_string(Tickmode e) {
    switch(e) {
        case Tickmode::AUTO: return "auto";
        case Tickmode::LINEAR: return "linear";
        case Tickmode::ARRAY: return "array";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Scene::Xaxis::to_string(Ticks e) {
    switch(e) {
        case Ticks::OUTSIDE: return "outside";
        case Ticks::INSIDE: return "inside";
        case Ticks::EMPTY: return "";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::autorange(std::string f) {
    json["autorange"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::autorangeoptions(Autorangeoptions f) {
    json["autorangeoptions"] = std::move(f.json);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::autotypenumbers(std::string f) {
    json["autotypenumbers"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::backgroundcolor(std::string f) {
    json["backgroundcolor"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::calendar(enum Calendar f) {
    json["calendar"] = to_string(f);
    return *this;
}

template <typename T, typename>
Layout::Scene::Xaxis& Layout::Scene::Xaxis::categoryarray(std::vector<T> f) {
    json["categoryarray"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::categoryarraysrc(std::string f) {
    json["categoryarraysrc"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::categoryorder(std::string f) {
    json["categoryorder"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Scene::Xaxis& Layout::Scene::Xaxis::dtick(T f) {
    json["dtick"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::exponentformat(enum Exponentformat f) {
    json["exponentformat"] = to_string(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::gridcolor(std::string f) {
    json["gridcolor"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::gridwidth(double f) {
    json["gridwidth"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::hoverformat(std::string f) {
    json["hoverformat"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Scene::Xaxis& Layout::Scene::Xaxis::labelalias(T f) {
    json["labelalias"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::linecolor(std::string f) {
    json["linecolor"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::linewidth(double f) {
    json["linewidth"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Scene::Xaxis& Layout::Scene::Xaxis::maxallowed(T f) {
    json["maxallowed"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Scene::Xaxis& Layout::Scene::Xaxis::minallowed(T f) {
    json["minallowed"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::minexponent(double f) {
    json["minexponent"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::mirror(enum Mirror f) {
    json["mirror"] = to_string(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::nticks(int f) {
    json["nticks"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::range(std::vector<double> f) {
    json["range"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::rangemode(enum Rangemode f) {
    json["rangemode"] = to_string(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::separatethousands(bool f) {
    json["separatethousands"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::showaxeslabels(bool f) {
    json["showaxeslabels"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::showbackground(bool f) {
    json["showbackground"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::showexponent(enum Showexponent f) {
    json["showexponent"] = to_string(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::showgrid(bool f) {
    json["showgrid"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::showline(bool f) {
    json["showline"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::showspikes(bool f) {
    json["showspikes"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::showticklabels(bool f) {
    json["showticklabels"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::showtickprefix(enum Showtickprefix f) {
    json["showtickprefix"] = to_string(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::showticksuffix(enum Showticksuffix f) {
    json["showticksuffix"] = to_string(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::spikecolor(std::string f) {
    json["spikecolor"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::spikesides(bool f) {
    json["spikesides"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::spikethickness(double f) {
    json["spikethickness"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Scene::Xaxis& Layout::Scene::Xaxis::tick0(T f) {
    json["tick0"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::tickangle(double f) {
    json["tickangle"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::tickcolor(std::string f) {
    json["tickcolor"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::tickfont(Tickfont f) {
    json["tickfont"] = std::move(f.json);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::tickformat(std::string f) {
    json["tickformat"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::tickformatstops(Tickformatstops f) {
    json["tickformatstops"] = std::move(f.json);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::ticklen(double f) {
    json["ticklen"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::tickmode(enum Tickmode f) {
    json["tickmode"] = to_string(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::tickprefix(std::string f) {
    json["tickprefix"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::ticks(enum Ticks f) {
    json["ticks"] = to_string(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::ticksuffix(std::string f) {
    json["ticksuffix"] = std::move(f);
    return *this;
}

template <typename T, typename>
Layout::Scene::Xaxis& Layout::Scene::Xaxis::ticktext(std::vector<T> f) {
    json["ticktext"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::ticktextsrc(std::string f) {
    json["ticktextsrc"] = std::move(f);
    return *this;
}

template <typename T, typename>
Layout::Scene::Xaxis& Layout::Scene::Xaxis::tickvals(std::vector<T> f) {
    json["tickvals"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::tickvalssrc(std::string f) {
    json["tickvalssrc"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::tickwidth(double f) {
    json["tickwidth"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::title(Title f) {
    json["title"] = std::move(f.json);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::type(std::string f) {
    json["type"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::visible(bool f) {
    json["visible"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::zeroline(bool f) {
    json["zeroline"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::zerolinecolor(std::string f) {
    json["zerolinecolor"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis& Layout::Scene::Xaxis::zerolinewidth(double f) {
    json["zerolinewidth"] = std::move(f);
    return *this;
}


template <typename T>
Layout::Scene::Xaxis::Autorangeoptions& Layout::Scene::Xaxis::Autorangeoptions::clipmax(T f) {
    json["clipmax"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Scene::Xaxis::Autorangeoptions& Layout::Scene::Xaxis::Autorangeoptions::clipmin(T f) {
    json["clipmin"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Scene::Xaxis::Autorangeoptions& Layout::Scene::Xaxis::Autorangeoptions::include(T f) {
    json["include"] = std::move(f);
    return *this;
}
template <typename T>
Layout::Scene::Xaxis::Autorangeoptions& Layout::Scene::Xaxis::Autorangeoptions::include(std::vector<T> f) {
    json["include"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis::Autorangeoptions& Layout::Scene::Xaxis::Autorangeoptions::includesrc(std::string f) {
    json["includesrc"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Scene::Xaxis::Autorangeoptions& Layout::Scene::Xaxis::Autorangeoptions::maxallowed(T f) {
    json["maxallowed"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Scene::Xaxis::Autorangeoptions& Layout::Scene::Xaxis::Autorangeoptions::minallowed(T f) {
    json["minallowed"] = std::move(f);
    return *this;
}

std::string Layout::Scene::Xaxis::Tickfont::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Scene::Xaxis::Tickfont& Layout::Scene::Xaxis::Tickfont::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis::Tickfont& Layout::Scene::Xaxis::Tickfont::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis::Tickfont& Layout::Scene::Xaxis::Tickfont::lineposition(std::string f) {
    json["lineposition"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis::Tickfont& Layout::Scene::Xaxis::Tickfont::shadow(std::string f) {
    json["shadow"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis::Tickfont& Layout::Scene::Xaxis::Tickfont::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis::Tickfont& Layout::Scene::Xaxis::Tickfont::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Scene::Xaxis::Tickfont& Layout::Scene::Xaxis::Tickfont::textcase(std::string f) {
    json["textcase"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis::Tickfont& Layout::Scene::Xaxis::Tickfont::variant(std::string f) {
    json["variant"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis::Tickfont& Layout::Scene::Xaxis::Tickfont::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}


Layout::Scene::Xaxis::Tickformatstops& Layout::Scene::Xaxis::Tickformatstops::tickformatstop(Tickformatstop f) {
    json["tickformatstop"] = std::move(f.json);
    return *this;
}


Layout::Scene::Xaxis::Tickformatstops::Tickformatstop& Layout::Scene::Xaxis::Tickformatstops::Tickformatstop::dtickrange(std::vector<double> f) {
    json["dtickrange"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis::Tickformatstops::Tickformatstop& Layout::Scene::Xaxis::Tickformatstops::Tickformatstop::enabled(bool f) {
    json["enabled"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis::Tickformatstops::Tickformatstop& Layout::Scene::Xaxis::Tickformatstops::Tickformatstop::name(std::string f) {
    json["name"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis::Tickformatstops::Tickformatstop& Layout::Scene::Xaxis::Tickformatstops::Tickformatstop::templateitemname(std::string f) {
    json["templateitemname"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis::Tickformatstops::Tickformatstop& Layout::Scene::Xaxis::Tickformatstops::Tickformatstop::value(std::string f) {
    json["value"] = std::move(f);
    return *this;
}


Layout::Scene::Xaxis::Title& Layout::Scene::Xaxis::Title::font(Font f) {
    json["font"] = std::move(f.json);
    return *this;
}

Layout::Scene::Xaxis::Title& Layout::Scene::Xaxis::Title::text(std::string f) {
    json["text"] = std::move(f);
    return *this;
}

std::string Layout::Scene::Xaxis::Title::Font::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Scene::Xaxis::Title::Font& Layout::Scene::Xaxis::Title::Font::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis::Title::Font& Layout::Scene::Xaxis::Title::Font::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis::Title::Font& Layout::Scene::Xaxis::Title::Font::lineposition(std::string f) {
    json["lineposition"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis::Title::Font& Layout::Scene::Xaxis::Title::Font::shadow(std::string f) {
    json["shadow"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis::Title::Font& Layout::Scene::Xaxis::Title::Font::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis::Title::Font& Layout::Scene::Xaxis::Title::Font::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Scene::Xaxis::Title::Font& Layout::Scene::Xaxis::Title::Font::textcase(std::string f) {
    json["textcase"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis::Title::Font& Layout::Scene::Xaxis::Title::Font::variant(std::string f) {
    json["variant"] = std::move(f);
    return *this;
}

Layout::Scene::Xaxis::Title::Font& Layout::Scene::Xaxis::Title::Font::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}

std::string Layout::Scene::Yaxis::to_string(Calendar e) {
    switch(e) {
        case Calendar::CHINESE: return "chinese";
        case Calendar::COPTIC: return "coptic";
        case Calendar::DISCWORLD: return "discworld";
        case Calendar::ETHIOPIAN: return "ethiopian";
        case Calendar::GREGORIAN: return "gregorian";
        case Calendar::HEBREW: return "hebrew";
        case Calendar::ISLAMIC: return "islamic";
        case Calendar::JALALI: return "jalali";
        case Calendar::JULIAN: return "julian";
        case Calendar::MAYAN: return "mayan";
        case Calendar::NANAKSHAHI: return "nanakshahi";
        case Calendar::NEPALI: return "nepali";
        case Calendar::PERSIAN: return "persian";
        case Calendar::TAIWAN: return "taiwan";
        case Calendar::THAI: return "thai";
        case Calendar::UMMALQURA: return "ummalqura";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Scene::Yaxis::to_string(Exponentformat e) {
    switch(e) {
        case Exponentformat::NONE: return "none";
        case Exponentformat::E: return "E";
        case Exponentformat::POWER: return "power";
        case Exponentformat::SI: return "SI";
        case Exponentformat::B: return "B";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Scene::Yaxis::to_string(Mirror e) {
    switch(e) {
        case Mirror::TRUE: return "True";
        case Mirror::TICKS: return "ticks";
        case Mirror::FALSE: return "False";
        case Mirror::ALL: return "all";
        case Mirror::ALLTICKS: return "allticks";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Scene::Yaxis::to_string(Rangemode e) {
    switch(e) {
        case Rangemode::NORMAL: return "normal";
        case Rangemode::TOZERO: return "tozero";
        case Rangemode::NONNEGATIVE: return "nonnegative";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Scene::Yaxis::to_string(Showexponent e) {
    switch(e) {
        case Showexponent::ALL: return "all";
        case Showexponent::FIRST: return "first";
        case Showexponent::LAST: return "last";
        case Showexponent::NONE: return "none";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Scene::Yaxis::to_string(Showtickprefix e) {
    switch(e) {
        case Showtickprefix::ALL: return "all";
        case Showtickprefix::FIRST: return "first";
        case Showtickprefix::LAST: return "last";
        case Showtickprefix::NONE: return "none";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Scene::Yaxis::to_string(Showticksuffix e) {
    switch(e) {
        case Showticksuffix::ALL: return "all";
        case Showticksuffix::FIRST: return "first";
        case Showticksuffix::LAST: return "last";
        case Showticksuffix::NONE: return "none";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Scene::Yaxis::to_string(Tickmode e) {
    switch(e) {
        case Tickmode::AUTO: return "auto";
        case Tickmode::LINEAR: return "linear";
        case Tickmode::ARRAY: return "array";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Scene::Yaxis::to_string(Ticks e) {
    switch(e) {
        case Ticks::OUTSIDE: return "outside";
        case Ticks::INSIDE: return "inside";
        case Ticks::EMPTY: return "";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::autorange(std::string f) {
    json["autorange"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::autorangeoptions(Autorangeoptions f) {
    json["autorangeoptions"] = std::move(f.json);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::autotypenumbers(std::string f) {
    json["autotypenumbers"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::backgroundcolor(std::string f) {
    json["backgroundcolor"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::calendar(enum Calendar f) {
    json["calendar"] = to_string(f);
    return *this;
}

template <typename T, typename>
Layout::Scene::Yaxis& Layout::Scene::Yaxis::categoryarray(std::vector<T> f) {
    json["categoryarray"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::categoryarraysrc(std::string f) {
    json["categoryarraysrc"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::categoryorder(std::string f) {
    json["categoryorder"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Scene::Yaxis& Layout::Scene::Yaxis::dtick(T f) {
    json["dtick"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::exponentformat(enum Exponentformat f) {
    json["exponentformat"] = to_string(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::gridcolor(std::string f) {
    json["gridcolor"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::gridwidth(double f) {
    json["gridwidth"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::hoverformat(std::string f) {
    json["hoverformat"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Scene::Yaxis& Layout::Scene::Yaxis::labelalias(T f) {
    json["labelalias"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::linecolor(std::string f) {
    json["linecolor"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::linewidth(double f) {
    json["linewidth"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Scene::Yaxis& Layout::Scene::Yaxis::maxallowed(T f) {
    json["maxallowed"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Scene::Yaxis& Layout::Scene::Yaxis::minallowed(T f) {
    json["minallowed"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::minexponent(double f) {
    json["minexponent"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::mirror(enum Mirror f) {
    json["mirror"] = to_string(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::nticks(int f) {
    json["nticks"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::range(std::vector<double> f) {
    json["range"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::rangemode(enum Rangemode f) {
    json["rangemode"] = to_string(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::separatethousands(bool f) {
    json["separatethousands"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::showaxeslabels(bool f) {
    json["showaxeslabels"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::showbackground(bool f) {
    json["showbackground"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::showexponent(enum Showexponent f) {
    json["showexponent"] = to_string(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::showgrid(bool f) {
    json["showgrid"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::showline(bool f) {
    json["showline"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::showspikes(bool f) {
    json["showspikes"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::showticklabels(bool f) {
    json["showticklabels"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::showtickprefix(enum Showtickprefix f) {
    json["showtickprefix"] = to_string(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::showticksuffix(enum Showticksuffix f) {
    json["showticksuffix"] = to_string(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::spikecolor(std::string f) {
    json["spikecolor"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::spikesides(bool f) {
    json["spikesides"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::spikethickness(double f) {
    json["spikethickness"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Scene::Yaxis& Layout::Scene::Yaxis::tick0(T f) {
    json["tick0"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::tickangle(double f) {
    json["tickangle"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::tickcolor(std::string f) {
    json["tickcolor"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::tickfont(Tickfont f) {
    json["tickfont"] = std::move(f.json);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::tickformat(std::string f) {
    json["tickformat"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::tickformatstops(Tickformatstops f) {
    json["tickformatstops"] = std::move(f.json);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::ticklen(double f) {
    json["ticklen"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::tickmode(enum Tickmode f) {
    json["tickmode"] = to_string(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::tickprefix(std::string f) {
    json["tickprefix"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::ticks(enum Ticks f) {
    json["ticks"] = to_string(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::ticksuffix(std::string f) {
    json["ticksuffix"] = std::move(f);
    return *this;
}

template <typename T, typename>
Layout::Scene::Yaxis& Layout::Scene::Yaxis::ticktext(std::vector<T> f) {
    json["ticktext"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::ticktextsrc(std::string f) {
    json["ticktextsrc"] = std::move(f);
    return *this;
}

template <typename T, typename>
Layout::Scene::Yaxis& Layout::Scene::Yaxis::tickvals(std::vector<T> f) {
    json["tickvals"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::tickvalssrc(std::string f) {
    json["tickvalssrc"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::tickwidth(double f) {
    json["tickwidth"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::title(Title f) {
    json["title"] = std::move(f.json);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::type(std::string f) {
    json["type"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::visible(bool f) {
    json["visible"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::zeroline(bool f) {
    json["zeroline"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::zerolinecolor(std::string f) {
    json["zerolinecolor"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis& Layout::Scene::Yaxis::zerolinewidth(double f) {
    json["zerolinewidth"] = std::move(f);
    return *this;
}


template <typename T>
Layout::Scene::Yaxis::Autorangeoptions& Layout::Scene::Yaxis::Autorangeoptions::clipmax(T f) {
    json["clipmax"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Scene::Yaxis::Autorangeoptions& Layout::Scene::Yaxis::Autorangeoptions::clipmin(T f) {
    json["clipmin"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Scene::Yaxis::Autorangeoptions& Layout::Scene::Yaxis::Autorangeoptions::include(T f) {
    json["include"] = std::move(f);
    return *this;
}
template <typename T>
Layout::Scene::Yaxis::Autorangeoptions& Layout::Scene::Yaxis::Autorangeoptions::include(std::vector<T> f) {
    json["include"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis::Autorangeoptions& Layout::Scene::Yaxis::Autorangeoptions::includesrc(std::string f) {
    json["includesrc"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Scene::Yaxis::Autorangeoptions& Layout::Scene::Yaxis::Autorangeoptions::maxallowed(T f) {
    json["maxallowed"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Scene::Yaxis::Autorangeoptions& Layout::Scene::Yaxis::Autorangeoptions::minallowed(T f) {
    json["minallowed"] = std::move(f);
    return *this;
}

std::string Layout::Scene::Yaxis::Tickfont::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Scene::Yaxis::Tickfont& Layout::Scene::Yaxis::Tickfont::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis::Tickfont& Layout::Scene::Yaxis::Tickfont::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis::Tickfont& Layout::Scene::Yaxis::Tickfont::lineposition(std::string f) {
    json["lineposition"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis::Tickfont& Layout::Scene::Yaxis::Tickfont::shadow(std::string f) {
    json["shadow"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis::Tickfont& Layout::Scene::Yaxis::Tickfont::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis::Tickfont& Layout::Scene::Yaxis::Tickfont::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Scene::Yaxis::Tickfont& Layout::Scene::Yaxis::Tickfont::textcase(std::string f) {
    json["textcase"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis::Tickfont& Layout::Scene::Yaxis::Tickfont::variant(std::string f) {
    json["variant"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis::Tickfont& Layout::Scene::Yaxis::Tickfont::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}


Layout::Scene::Yaxis::Tickformatstops& Layout::Scene::Yaxis::Tickformatstops::tickformatstop(Tickformatstop f) {
    json["tickformatstop"] = std::move(f.json);
    return *this;
}


Layout::Scene::Yaxis::Tickformatstops::Tickformatstop& Layout::Scene::Yaxis::Tickformatstops::Tickformatstop::dtickrange(std::vector<double> f) {
    json["dtickrange"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis::Tickformatstops::Tickformatstop& Layout::Scene::Yaxis::Tickformatstops::Tickformatstop::enabled(bool f) {
    json["enabled"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis::Tickformatstops::Tickformatstop& Layout::Scene::Yaxis::Tickformatstops::Tickformatstop::name(std::string f) {
    json["name"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis::Tickformatstops::Tickformatstop& Layout::Scene::Yaxis::Tickformatstops::Tickformatstop::templateitemname(std::string f) {
    json["templateitemname"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis::Tickformatstops::Tickformatstop& Layout::Scene::Yaxis::Tickformatstops::Tickformatstop::value(std::string f) {
    json["value"] = std::move(f);
    return *this;
}


Layout::Scene::Yaxis::Title& Layout::Scene::Yaxis::Title::font(Font f) {
    json["font"] = std::move(f.json);
    return *this;
}

Layout::Scene::Yaxis::Title& Layout::Scene::Yaxis::Title::text(std::string f) {
    json["text"] = std::move(f);
    return *this;
}

std::string Layout::Scene::Yaxis::Title::Font::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Scene::Yaxis::Title::Font& Layout::Scene::Yaxis::Title::Font::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis::Title::Font& Layout::Scene::Yaxis::Title::Font::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis::Title::Font& Layout::Scene::Yaxis::Title::Font::lineposition(std::string f) {
    json["lineposition"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis::Title::Font& Layout::Scene::Yaxis::Title::Font::shadow(std::string f) {
    json["shadow"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis::Title::Font& Layout::Scene::Yaxis::Title::Font::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis::Title::Font& Layout::Scene::Yaxis::Title::Font::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Scene::Yaxis::Title::Font& Layout::Scene::Yaxis::Title::Font::textcase(std::string f) {
    json["textcase"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis::Title::Font& Layout::Scene::Yaxis::Title::Font::variant(std::string f) {
    json["variant"] = std::move(f);
    return *this;
}

Layout::Scene::Yaxis::Title::Font& Layout::Scene::Yaxis::Title::Font::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}

std::string Layout::Scene::Zaxis::to_string(Calendar e) {
    switch(e) {
        case Calendar::CHINESE: return "chinese";
        case Calendar::COPTIC: return "coptic";
        case Calendar::DISCWORLD: return "discworld";
        case Calendar::ETHIOPIAN: return "ethiopian";
        case Calendar::GREGORIAN: return "gregorian";
        case Calendar::HEBREW: return "hebrew";
        case Calendar::ISLAMIC: return "islamic";
        case Calendar::JALALI: return "jalali";
        case Calendar::JULIAN: return "julian";
        case Calendar::MAYAN: return "mayan";
        case Calendar::NANAKSHAHI: return "nanakshahi";
        case Calendar::NEPALI: return "nepali";
        case Calendar::PERSIAN: return "persian";
        case Calendar::TAIWAN: return "taiwan";
        case Calendar::THAI: return "thai";
        case Calendar::UMMALQURA: return "ummalqura";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Scene::Zaxis::to_string(Exponentformat e) {
    switch(e) {
        case Exponentformat::NONE: return "none";
        case Exponentformat::E: return "E";
        case Exponentformat::POWER: return "power";
        case Exponentformat::SI: return "SI";
        case Exponentformat::B: return "B";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Scene::Zaxis::to_string(Mirror e) {
    switch(e) {
        case Mirror::TRUE: return "True";
        case Mirror::TICKS: return "ticks";
        case Mirror::FALSE: return "False";
        case Mirror::ALL: return "all";
        case Mirror::ALLTICKS: return "allticks";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Scene::Zaxis::to_string(Rangemode e) {
    switch(e) {
        case Rangemode::NORMAL: return "normal";
        case Rangemode::TOZERO: return "tozero";
        case Rangemode::NONNEGATIVE: return "nonnegative";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Scene::Zaxis::to_string(Showexponent e) {
    switch(e) {
        case Showexponent::ALL: return "all";
        case Showexponent::FIRST: return "first";
        case Showexponent::LAST: return "last";
        case Showexponent::NONE: return "none";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Scene::Zaxis::to_string(Showtickprefix e) {
    switch(e) {
        case Showtickprefix::ALL: return "all";
        case Showtickprefix::FIRST: return "first";
        case Showtickprefix::LAST: return "last";
        case Showtickprefix::NONE: return "none";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Scene::Zaxis::to_string(Showticksuffix e) {
    switch(e) {
        case Showticksuffix::ALL: return "all";
        case Showticksuffix::FIRST: return "first";
        case Showticksuffix::LAST: return "last";
        case Showticksuffix::NONE: return "none";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Scene::Zaxis::to_string(Tickmode e) {
    switch(e) {
        case Tickmode::AUTO: return "auto";
        case Tickmode::LINEAR: return "linear";
        case Tickmode::ARRAY: return "array";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Scene::Zaxis::to_string(Ticks e) {
    switch(e) {
        case Ticks::OUTSIDE: return "outside";
        case Ticks::INSIDE: return "inside";
        case Ticks::EMPTY: return "";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::autorange(std::string f) {
    json["autorange"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::autorangeoptions(Autorangeoptions f) {
    json["autorangeoptions"] = std::move(f.json);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::autotypenumbers(std::string f) {
    json["autotypenumbers"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::backgroundcolor(std::string f) {
    json["backgroundcolor"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::calendar(enum Calendar f) {
    json["calendar"] = to_string(f);
    return *this;
}

template <typename T, typename>
Layout::Scene::Zaxis& Layout::Scene::Zaxis::categoryarray(std::vector<T> f) {
    json["categoryarray"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::categoryarraysrc(std::string f) {
    json["categoryarraysrc"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::categoryorder(std::string f) {
    json["categoryorder"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Scene::Zaxis& Layout::Scene::Zaxis::dtick(T f) {
    json["dtick"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::exponentformat(enum Exponentformat f) {
    json["exponentformat"] = to_string(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::gridcolor(std::string f) {
    json["gridcolor"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::gridwidth(double f) {
    json["gridwidth"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::hoverformat(std::string f) {
    json["hoverformat"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Scene::Zaxis& Layout::Scene::Zaxis::labelalias(T f) {
    json["labelalias"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::linecolor(std::string f) {
    json["linecolor"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::linewidth(double f) {
    json["linewidth"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Scene::Zaxis& Layout::Scene::Zaxis::maxallowed(T f) {
    json["maxallowed"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Scene::Zaxis& Layout::Scene::Zaxis::minallowed(T f) {
    json["minallowed"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::minexponent(double f) {
    json["minexponent"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::mirror(enum Mirror f) {
    json["mirror"] = to_string(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::nticks(int f) {
    json["nticks"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::range(std::vector<double> f) {
    json["range"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::rangemode(enum Rangemode f) {
    json["rangemode"] = to_string(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::separatethousands(bool f) {
    json["separatethousands"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::showaxeslabels(bool f) {
    json["showaxeslabels"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::showbackground(bool f) {
    json["showbackground"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::showexponent(enum Showexponent f) {
    json["showexponent"] = to_string(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::showgrid(bool f) {
    json["showgrid"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::showline(bool f) {
    json["showline"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::showspikes(bool f) {
    json["showspikes"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::showticklabels(bool f) {
    json["showticklabels"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::showtickprefix(enum Showtickprefix f) {
    json["showtickprefix"] = to_string(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::showticksuffix(enum Showticksuffix f) {
    json["showticksuffix"] = to_string(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::spikecolor(std::string f) {
    json["spikecolor"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::spikesides(bool f) {
    json["spikesides"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::spikethickness(double f) {
    json["spikethickness"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Scene::Zaxis& Layout::Scene::Zaxis::tick0(T f) {
    json["tick0"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::tickangle(double f) {
    json["tickangle"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::tickcolor(std::string f) {
    json["tickcolor"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::tickfont(Tickfont f) {
    json["tickfont"] = std::move(f.json);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::tickformat(std::string f) {
    json["tickformat"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::tickformatstops(Tickformatstops f) {
    json["tickformatstops"] = std::move(f.json);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::ticklen(double f) {
    json["ticklen"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::tickmode(enum Tickmode f) {
    json["tickmode"] = to_string(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::tickprefix(std::string f) {
    json["tickprefix"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::ticks(enum Ticks f) {
    json["ticks"] = to_string(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::ticksuffix(std::string f) {
    json["ticksuffix"] = std::move(f);
    return *this;
}

template <typename T, typename>
Layout::Scene::Zaxis& Layout::Scene::Zaxis::ticktext(std::vector<T> f) {
    json["ticktext"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::ticktextsrc(std::string f) {
    json["ticktextsrc"] = std::move(f);
    return *this;
}

template <typename T, typename>
Layout::Scene::Zaxis& Layout::Scene::Zaxis::tickvals(std::vector<T> f) {
    json["tickvals"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::tickvalssrc(std::string f) {
    json["tickvalssrc"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::tickwidth(double f) {
    json["tickwidth"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::title(Title f) {
    json["title"] = std::move(f.json);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::type(std::string f) {
    json["type"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::visible(bool f) {
    json["visible"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::zeroline(bool f) {
    json["zeroline"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::zerolinecolor(std::string f) {
    json["zerolinecolor"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis& Layout::Scene::Zaxis::zerolinewidth(double f) {
    json["zerolinewidth"] = std::move(f);
    return *this;
}


template <typename T>
Layout::Scene::Zaxis::Autorangeoptions& Layout::Scene::Zaxis::Autorangeoptions::clipmax(T f) {
    json["clipmax"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Scene::Zaxis::Autorangeoptions& Layout::Scene::Zaxis::Autorangeoptions::clipmin(T f) {
    json["clipmin"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Scene::Zaxis::Autorangeoptions& Layout::Scene::Zaxis::Autorangeoptions::include(T f) {
    json["include"] = std::move(f);
    return *this;
}
template <typename T>
Layout::Scene::Zaxis::Autorangeoptions& Layout::Scene::Zaxis::Autorangeoptions::include(std::vector<T> f) {
    json["include"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis::Autorangeoptions& Layout::Scene::Zaxis::Autorangeoptions::includesrc(std::string f) {
    json["includesrc"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Scene::Zaxis::Autorangeoptions& Layout::Scene::Zaxis::Autorangeoptions::maxallowed(T f) {
    json["maxallowed"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Scene::Zaxis::Autorangeoptions& Layout::Scene::Zaxis::Autorangeoptions::minallowed(T f) {
    json["minallowed"] = std::move(f);
    return *this;
}

std::string Layout::Scene::Zaxis::Tickfont::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Scene::Zaxis::Tickfont& Layout::Scene::Zaxis::Tickfont::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis::Tickfont& Layout::Scene::Zaxis::Tickfont::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis::Tickfont& Layout::Scene::Zaxis::Tickfont::lineposition(std::string f) {
    json["lineposition"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis::Tickfont& Layout::Scene::Zaxis::Tickfont::shadow(std::string f) {
    json["shadow"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis::Tickfont& Layout::Scene::Zaxis::Tickfont::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis::Tickfont& Layout::Scene::Zaxis::Tickfont::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Scene::Zaxis::Tickfont& Layout::Scene::Zaxis::Tickfont::textcase(std::string f) {
    json["textcase"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis::Tickfont& Layout::Scene::Zaxis::Tickfont::variant(std::string f) {
    json["variant"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis::Tickfont& Layout::Scene::Zaxis::Tickfont::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}


Layout::Scene::Zaxis::Tickformatstops& Layout::Scene::Zaxis::Tickformatstops::tickformatstop(Tickformatstop f) {
    json["tickformatstop"] = std::move(f.json);
    return *this;
}


Layout::Scene::Zaxis::Tickformatstops::Tickformatstop& Layout::Scene::Zaxis::Tickformatstops::Tickformatstop::dtickrange(std::vector<double> f) {
    json["dtickrange"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis::Tickformatstops::Tickformatstop& Layout::Scene::Zaxis::Tickformatstops::Tickformatstop::enabled(bool f) {
    json["enabled"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis::Tickformatstops::Tickformatstop& Layout::Scene::Zaxis::Tickformatstops::Tickformatstop::name(std::string f) {
    json["name"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis::Tickformatstops::Tickformatstop& Layout::Scene::Zaxis::Tickformatstops::Tickformatstop::templateitemname(std::string f) {
    json["templateitemname"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis::Tickformatstops::Tickformatstop& Layout::Scene::Zaxis::Tickformatstops::Tickformatstop::value(std::string f) {
    json["value"] = std::move(f);
    return *this;
}


Layout::Scene::Zaxis::Title& Layout::Scene::Zaxis::Title::font(Font f) {
    json["font"] = std::move(f.json);
    return *this;
}

Layout::Scene::Zaxis::Title& Layout::Scene::Zaxis::Title::text(std::string f) {
    json["text"] = std::move(f);
    return *this;
}

std::string Layout::Scene::Zaxis::Title::Font::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Scene::Zaxis::Title::Font& Layout::Scene::Zaxis::Title::Font::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis::Title::Font& Layout::Scene::Zaxis::Title::Font::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis::Title::Font& Layout::Scene::Zaxis::Title::Font::lineposition(std::string f) {
    json["lineposition"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis::Title::Font& Layout::Scene::Zaxis::Title::Font::shadow(std::string f) {
    json["shadow"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis::Title::Font& Layout::Scene::Zaxis::Title::Font::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis::Title::Font& Layout::Scene::Zaxis::Title::Font::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Scene::Zaxis::Title::Font& Layout::Scene::Zaxis::Title::Font::textcase(std::string f) {
    json["textcase"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis::Title::Font& Layout::Scene::Zaxis::Title::Font::variant(std::string f) {
    json["variant"] = std::move(f);
    return *this;
}

Layout::Scene::Zaxis::Title::Font& Layout::Scene::Zaxis::Title::Font::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}


Layout::Selections& Layout::Selections::selection(Selection f) {
    json["selection"] = std::move(f.json);
    return *this;
}

std::string Layout::Selections::Selection::to_string(Type e) {
    switch(e) {
        case Type::RECT: return "rect";
        case Type::PATH: return "path";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Selections::Selection& Layout::Selections::Selection::line(Line f) {
    json["line"] = std::move(f.json);
    return *this;
}

Layout::Selections::Selection& Layout::Selections::Selection::name(std::string f) {
    json["name"] = std::move(f);
    return *this;
}

Layout::Selections::Selection& Layout::Selections::Selection::opacity(double f) {
    json["opacity"] = std::move(f);
    return *this;
}

Layout::Selections::Selection& Layout::Selections::Selection::path(std::string f) {
    json["path"] = std::move(f);
    return *this;
}

Layout::Selections::Selection& Layout::Selections::Selection::templateitemname(std::string f) {
    json["templateitemname"] = std::move(f);
    return *this;
}

Layout::Selections::Selection& Layout::Selections::Selection::type(enum Type f) {
    json["type"] = to_string(f);
    return *this;
}

template <typename T>
Layout::Selections::Selection& Layout::Selections::Selection::x0(T f) {
    json["x0"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Selections::Selection& Layout::Selections::Selection::x1(T f) {
    json["x1"] = std::move(f);
    return *this;
}

Layout::Selections::Selection& Layout::Selections::Selection::xref(std::string f) {
    json["xref"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Selections::Selection& Layout::Selections::Selection::y0(T f) {
    json["y0"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Selections::Selection& Layout::Selections::Selection::y1(T f) {
    json["y1"] = std::move(f);
    return *this;
}

Layout::Selections::Selection& Layout::Selections::Selection::yref(std::string f) {
    json["yref"] = std::move(f);
    return *this;
}


Layout::Selections::Selection::Line& Layout::Selections::Selection::Line::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Selections::Selection::Line& Layout::Selections::Selection::Line::dash(std::string f) {
    json["dash"] = std::move(f);
    return *this;
}

Layout::Selections::Selection::Line& Layout::Selections::Selection::Line::width(double f) {
    json["width"] = std::move(f);
    return *this;
}


Layout::Shapes& Layout::Shapes::shape(Shape f) {
    json["shape"] = std::move(f.json);
    return *this;
}

std::string Layout::Shapes::Shape::to_string(Fillrule e) {
    switch(e) {
        case Fillrule::EVENODD: return "evenodd";
        case Fillrule::NONZERO: return "nonzero";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Shapes::Shape::to_string(Layer e) {
    switch(e) {
        case Layer::BELOW: return "below";
        case Layer::ABOVE: return "above";
        case Layer::BETWEEN: return "between";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Shapes::Shape::to_string(Type e) {
    switch(e) {
        case Type::CIRCLE: return "circle";
        case Type::RECT: return "rect";
        case Type::PATH: return "path";
        case Type::LINE: return "line";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Shapes::Shape::to_string(Visible e) {
    switch(e) {
        case Visible::TRUE: return "True";
        case Visible::FALSE: return "False";
        case Visible::LEGENDONLY: return "legendonly";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Shapes::Shape::to_string(Xsizemode e) {
    switch(e) {
        case Xsizemode::SCALED: return "scaled";
        case Xsizemode::PIXEL: return "pixel";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Shapes::Shape::to_string(Ysizemode e) {
    switch(e) {
        case Ysizemode::SCALED: return "scaled";
        case Ysizemode::PIXEL: return "pixel";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Shapes::Shape& Layout::Shapes::Shape::editable(bool f) {
    json["editable"] = std::move(f);
    return *this;
}

Layout::Shapes::Shape& Layout::Shapes::Shape::fillcolor(std::string f) {
    json["fillcolor"] = std::move(f);
    return *this;
}

Layout::Shapes::Shape& Layout::Shapes::Shape::fillrule(enum Fillrule f) {
    json["fillrule"] = to_string(f);
    return *this;
}

Layout::Shapes::Shape& Layout::Shapes::Shape::label(Label f) {
    json["label"] = std::move(f.json);
    return *this;
}

Layout::Shapes::Shape& Layout::Shapes::Shape::layer(enum Layer f) {
    json["layer"] = to_string(f);
    return *this;
}

Layout::Shapes::Shape& Layout::Shapes::Shape::legend(std::string f) {
    json["legend"] = std::move(f);
    return *this;
}

Layout::Shapes::Shape& Layout::Shapes::Shape::legendgroup(std::string f) {
    json["legendgroup"] = std::move(f);
    return *this;
}

Layout::Shapes::Shape& Layout::Shapes::Shape::legendgrouptitle(Legendgrouptitle f) {
    json["legendgrouptitle"] = std::move(f.json);
    return *this;
}

Layout::Shapes::Shape& Layout::Shapes::Shape::legendrank(double f) {
    json["legendrank"] = std::move(f);
    return *this;
}

Layout::Shapes::Shape& Layout::Shapes::Shape::legendwidth(double f) {
    json["legendwidth"] = std::move(f);
    return *this;
}

Layout::Shapes::Shape& Layout::Shapes::Shape::line(Line f) {
    json["line"] = std::move(f.json);
    return *this;
}

Layout::Shapes::Shape& Layout::Shapes::Shape::name(std::string f) {
    json["name"] = std::move(f);
    return *this;
}

Layout::Shapes::Shape& Layout::Shapes::Shape::opacity(double f) {
    json["opacity"] = std::move(f);
    return *this;
}

Layout::Shapes::Shape& Layout::Shapes::Shape::path(std::string f) {
    json["path"] = std::move(f);
    return *this;
}

Layout::Shapes::Shape& Layout::Shapes::Shape::showlegend(bool f) {
    json["showlegend"] = std::move(f);
    return *this;
}

Layout::Shapes::Shape& Layout::Shapes::Shape::templateitemname(std::string f) {
    json["templateitemname"] = std::move(f);
    return *this;
}

Layout::Shapes::Shape& Layout::Shapes::Shape::type(enum Type f) {
    json["type"] = to_string(f);
    return *this;
}

Layout::Shapes::Shape& Layout::Shapes::Shape::visible(enum Visible f) {
    json["visible"] = to_string(f);
    return *this;
}

template <typename T>
Layout::Shapes::Shape& Layout::Shapes::Shape::x0(T f) {
    json["x0"] = std::move(f);
    return *this;
}

Layout::Shapes::Shape& Layout::Shapes::Shape::x0shift(double f) {
    json["x0shift"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Shapes::Shape& Layout::Shapes::Shape::x1(T f) {
    json["x1"] = std::move(f);
    return *this;
}

Layout::Shapes::Shape& Layout::Shapes::Shape::x1shift(double f) {
    json["x1shift"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Shapes::Shape& Layout::Shapes::Shape::xanchor(T f) {
    json["xanchor"] = std::move(f);
    return *this;
}

Layout::Shapes::Shape& Layout::Shapes::Shape::xref(std::string f) {
    json["xref"] = std::move(f);
    return *this;
}

Layout::Shapes::Shape& Layout::Shapes::Shape::xsizemode(enum Xsizemode f) {
    json["xsizemode"] = to_string(f);
    return *this;
}

template <typename T>
Layout::Shapes::Shape& Layout::Shapes::Shape::y0(T f) {
    json["y0"] = std::move(f);
    return *this;
}

Layout::Shapes::Shape& Layout::Shapes::Shape::y0shift(double f) {
    json["y0shift"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Shapes::Shape& Layout::Shapes::Shape::y1(T f) {
    json["y1"] = std::move(f);
    return *this;
}

Layout::Shapes::Shape& Layout::Shapes::Shape::y1shift(double f) {
    json["y1shift"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Shapes::Shape& Layout::Shapes::Shape::yanchor(T f) {
    json["yanchor"] = std::move(f);
    return *this;
}

Layout::Shapes::Shape& Layout::Shapes::Shape::yref(std::string f) {
    json["yref"] = std::move(f);
    return *this;
}

Layout::Shapes::Shape& Layout::Shapes::Shape::ysizemode(enum Ysizemode f) {
    json["ysizemode"] = to_string(f);
    return *this;
}

std::string Layout::Shapes::Shape::Label::to_string(Xanchor e) {
    switch(e) {
        case Xanchor::AUTO: return "auto";
        case Xanchor::LEFT: return "left";
        case Xanchor::CENTER: return "center";
        case Xanchor::RIGHT: return "right";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Shapes::Shape::Label::to_string(Yanchor e) {
    switch(e) {
        case Yanchor::TOP: return "top";
        case Yanchor::MIDDLE: return "middle";
        case Yanchor::BOTTOM: return "bottom";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Shapes::Shape::Label& Layout::Shapes::Shape::Label::font(Font f) {
    json["font"] = std::move(f.json);
    return *this;
}

Layout::Shapes::Shape::Label& Layout::Shapes::Shape::Label::padding(double f) {
    json["padding"] = std::move(f);
    return *this;
}

Layout::Shapes::Shape::Label& Layout::Shapes::Shape::Label::text(std::string f) {
    json["text"] = std::move(f);
    return *this;
}

Layout::Shapes::Shape::Label& Layout::Shapes::Shape::Label::textangle(double f) {
    json["textangle"] = std::move(f);
    return *this;
}

Layout::Shapes::Shape::Label& Layout::Shapes::Shape::Label::textposition(std::string f) {
    json["textposition"] = std::move(f);
    return *this;
}

Layout::Shapes::Shape::Label& Layout::Shapes::Shape::Label::texttemplate(std::string f) {
    json["texttemplate"] = std::move(f);
    return *this;
}

Layout::Shapes::Shape::Label& Layout::Shapes::Shape::Label::xanchor(enum Xanchor f) {
    json["xanchor"] = to_string(f);
    return *this;
}

Layout::Shapes::Shape::Label& Layout::Shapes::Shape::Label::yanchor(enum Yanchor f) {
    json["yanchor"] = to_string(f);
    return *this;
}

std::string Layout::Shapes::Shape::Label::Font::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Shapes::Shape::Label::Font& Layout::Shapes::Shape::Label::Font::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Shapes::Shape::Label::Font& Layout::Shapes::Shape::Label::Font::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Shapes::Shape::Label::Font& Layout::Shapes::Shape::Label::Font::lineposition(std::string f) {
    json["lineposition"] = std::move(f);
    return *this;
}

Layout::Shapes::Shape::Label::Font& Layout::Shapes::Shape::Label::Font::shadow(std::string f) {
    json["shadow"] = std::move(f);
    return *this;
}

Layout::Shapes::Shape::Label::Font& Layout::Shapes::Shape::Label::Font::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Shapes::Shape::Label::Font& Layout::Shapes::Shape::Label::Font::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Shapes::Shape::Label::Font& Layout::Shapes::Shape::Label::Font::textcase(std::string f) {
    json["textcase"] = std::move(f);
    return *this;
}

Layout::Shapes::Shape::Label::Font& Layout::Shapes::Shape::Label::Font::variant(std::string f) {
    json["variant"] = std::move(f);
    return *this;
}

Layout::Shapes::Shape::Label::Font& Layout::Shapes::Shape::Label::Font::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}


Layout::Shapes::Shape::Legendgrouptitle& Layout::Shapes::Shape::Legendgrouptitle::font(Font f) {
    json["font"] = std::move(f.json);
    return *this;
}

Layout::Shapes::Shape::Legendgrouptitle& Layout::Shapes::Shape::Legendgrouptitle::text(std::string f) {
    json["text"] = std::move(f);
    return *this;
}

std::string Layout::Shapes::Shape::Legendgrouptitle::Font::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Shapes::Shape::Legendgrouptitle::Font& Layout::Shapes::Shape::Legendgrouptitle::Font::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Shapes::Shape::Legendgrouptitle::Font& Layout::Shapes::Shape::Legendgrouptitle::Font::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Shapes::Shape::Legendgrouptitle::Font& Layout::Shapes::Shape::Legendgrouptitle::Font::lineposition(std::string f) {
    json["lineposition"] = std::move(f);
    return *this;
}

Layout::Shapes::Shape::Legendgrouptitle::Font& Layout::Shapes::Shape::Legendgrouptitle::Font::shadow(std::string f) {
    json["shadow"] = std::move(f);
    return *this;
}

Layout::Shapes::Shape::Legendgrouptitle::Font& Layout::Shapes::Shape::Legendgrouptitle::Font::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Shapes::Shape::Legendgrouptitle::Font& Layout::Shapes::Shape::Legendgrouptitle::Font::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Shapes::Shape::Legendgrouptitle::Font& Layout::Shapes::Shape::Legendgrouptitle::Font::textcase(std::string f) {
    json["textcase"] = std::move(f);
    return *this;
}

Layout::Shapes::Shape::Legendgrouptitle::Font& Layout::Shapes::Shape::Legendgrouptitle::Font::variant(std::string f) {
    json["variant"] = std::move(f);
    return *this;
}

Layout::Shapes::Shape::Legendgrouptitle::Font& Layout::Shapes::Shape::Legendgrouptitle::Font::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}


Layout::Shapes::Shape::Line& Layout::Shapes::Shape::Line::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Shapes::Shape::Line& Layout::Shapes::Shape::Line::dash(std::string f) {
    json["dash"] = std::move(f);
    return *this;
}

Layout::Shapes::Shape::Line& Layout::Shapes::Shape::Line::width(double f) {
    json["width"] = std::move(f);
    return *this;
}


Layout::Sliders& Layout::Sliders::slider(Slider f) {
    json["slider"] = std::move(f.json);
    return *this;
}

std::string Layout::Sliders::Slider::to_string(Lenmode e) {
    switch(e) {
        case Lenmode::FRACTION: return "fraction";
        case Lenmode::PIXELS: return "pixels";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Sliders::Slider::to_string(Xanchor e) {
    switch(e) {
        case Xanchor::AUTO: return "auto";
        case Xanchor::LEFT: return "left";
        case Xanchor::CENTER: return "center";
        case Xanchor::RIGHT: return "right";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Sliders::Slider::to_string(Yanchor e) {
    switch(e) {
        case Yanchor::AUTO: return "auto";
        case Yanchor::TOP: return "top";
        case Yanchor::MIDDLE: return "middle";
        case Yanchor::BOTTOM: return "bottom";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Sliders::Slider& Layout::Sliders::Slider::active(double f) {
    json["active"] = std::move(f);
    return *this;
}

Layout::Sliders::Slider& Layout::Sliders::Slider::activebgcolor(std::string f) {
    json["activebgcolor"] = std::move(f);
    return *this;
}

Layout::Sliders::Slider& Layout::Sliders::Slider::bgcolor(std::string f) {
    json["bgcolor"] = std::move(f);
    return *this;
}

Layout::Sliders::Slider& Layout::Sliders::Slider::bordercolor(std::string f) {
    json["bordercolor"] = std::move(f);
    return *this;
}

Layout::Sliders::Slider& Layout::Sliders::Slider::borderwidth(double f) {
    json["borderwidth"] = std::move(f);
    return *this;
}

Layout::Sliders::Slider& Layout::Sliders::Slider::currentvalue(Currentvalue f) {
    json["currentvalue"] = std::move(f.json);
    return *this;
}

Layout::Sliders::Slider& Layout::Sliders::Slider::font(Font f) {
    json["font"] = std::move(f.json);
    return *this;
}

Layout::Sliders::Slider& Layout::Sliders::Slider::len(double f) {
    json["len"] = std::move(f);
    return *this;
}

Layout::Sliders::Slider& Layout::Sliders::Slider::lenmode(enum Lenmode f) {
    json["lenmode"] = to_string(f);
    return *this;
}

Layout::Sliders::Slider& Layout::Sliders::Slider::minorticklen(double f) {
    json["minorticklen"] = std::move(f);
    return *this;
}

Layout::Sliders::Slider& Layout::Sliders::Slider::name(std::string f) {
    json["name"] = std::move(f);
    return *this;
}

Layout::Sliders::Slider& Layout::Sliders::Slider::pad(Pad f) {
    json["pad"] = std::move(f.json);
    return *this;
}

Layout::Sliders::Slider& Layout::Sliders::Slider::steps(Steps f) {
    json["steps"] = std::move(f.json);
    return *this;
}

Layout::Sliders::Slider& Layout::Sliders::Slider::templateitemname(std::string f) {
    json["templateitemname"] = std::move(f);
    return *this;
}

Layout::Sliders::Slider& Layout::Sliders::Slider::tickcolor(std::string f) {
    json["tickcolor"] = std::move(f);
    return *this;
}

Layout::Sliders::Slider& Layout::Sliders::Slider::ticklen(double f) {
    json["ticklen"] = std::move(f);
    return *this;
}

Layout::Sliders::Slider& Layout::Sliders::Slider::tickwidth(double f) {
    json["tickwidth"] = std::move(f);
    return *this;
}

Layout::Sliders::Slider& Layout::Sliders::Slider::transition(Transition f) {
    json["transition"] = std::move(f.json);
    return *this;
}

Layout::Sliders::Slider& Layout::Sliders::Slider::visible(bool f) {
    json["visible"] = std::move(f);
    return *this;
}

Layout::Sliders::Slider& Layout::Sliders::Slider::x(double f) {
    json["x"] = std::move(f);
    return *this;
}

Layout::Sliders::Slider& Layout::Sliders::Slider::xanchor(enum Xanchor f) {
    json["xanchor"] = to_string(f);
    return *this;
}

Layout::Sliders::Slider& Layout::Sliders::Slider::y(double f) {
    json["y"] = std::move(f);
    return *this;
}

Layout::Sliders::Slider& Layout::Sliders::Slider::yanchor(enum Yanchor f) {
    json["yanchor"] = to_string(f);
    return *this;
}

std::string Layout::Sliders::Slider::Currentvalue::to_string(Xanchor e) {
    switch(e) {
        case Xanchor::LEFT: return "left";
        case Xanchor::CENTER: return "center";
        case Xanchor::RIGHT: return "right";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Sliders::Slider::Currentvalue& Layout::Sliders::Slider::Currentvalue::font(Font f) {
    json["font"] = std::move(f.json);
    return *this;
}

Layout::Sliders::Slider::Currentvalue& Layout::Sliders::Slider::Currentvalue::offset(double f) {
    json["offset"] = std::move(f);
    return *this;
}

Layout::Sliders::Slider::Currentvalue& Layout::Sliders::Slider::Currentvalue::prefix(std::string f) {
    json["prefix"] = std::move(f);
    return *this;
}

Layout::Sliders::Slider::Currentvalue& Layout::Sliders::Slider::Currentvalue::suffix(std::string f) {
    json["suffix"] = std::move(f);
    return *this;
}

Layout::Sliders::Slider::Currentvalue& Layout::Sliders::Slider::Currentvalue::visible(bool f) {
    json["visible"] = std::move(f);
    return *this;
}

Layout::Sliders::Slider::Currentvalue& Layout::Sliders::Slider::Currentvalue::xanchor(enum Xanchor f) {
    json["xanchor"] = to_string(f);
    return *this;
}

std::string Layout::Sliders::Slider::Currentvalue::Font::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Sliders::Slider::Currentvalue::Font& Layout::Sliders::Slider::Currentvalue::Font::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Sliders::Slider::Currentvalue::Font& Layout::Sliders::Slider::Currentvalue::Font::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Sliders::Slider::Currentvalue::Font& Layout::Sliders::Slider::Currentvalue::Font::lineposition(std::string f) {
    json["lineposition"] = std::move(f);
    return *this;
}

Layout::Sliders::Slider::Currentvalue::Font& Layout::Sliders::Slider::Currentvalue::Font::shadow(std::string f) {
    json["shadow"] = std::move(f);
    return *this;
}

Layout::Sliders::Slider::Currentvalue::Font& Layout::Sliders::Slider::Currentvalue::Font::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Sliders::Slider::Currentvalue::Font& Layout::Sliders::Slider::Currentvalue::Font::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Sliders::Slider::Currentvalue::Font& Layout::Sliders::Slider::Currentvalue::Font::textcase(std::string f) {
    json["textcase"] = std::move(f);
    return *this;
}

Layout::Sliders::Slider::Currentvalue::Font& Layout::Sliders::Slider::Currentvalue::Font::variant(std::string f) {
    json["variant"] = std::move(f);
    return *this;
}

Layout::Sliders::Slider::Currentvalue::Font& Layout::Sliders::Slider::Currentvalue::Font::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}

std::string Layout::Sliders::Slider::Font::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Sliders::Slider::Font& Layout::Sliders::Slider::Font::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Sliders::Slider::Font& Layout::Sliders::Slider::Font::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Sliders::Slider::Font& Layout::Sliders::Slider::Font::lineposition(std::string f) {
    json["lineposition"] = std::move(f);
    return *this;
}

Layout::Sliders::Slider::Font& Layout::Sliders::Slider::Font::shadow(std::string f) {
    json["shadow"] = std::move(f);
    return *this;
}

Layout::Sliders::Slider::Font& Layout::Sliders::Slider::Font::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Sliders::Slider::Font& Layout::Sliders::Slider::Font::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Sliders::Slider::Font& Layout::Sliders::Slider::Font::textcase(std::string f) {
    json["textcase"] = std::move(f);
    return *this;
}

Layout::Sliders::Slider::Font& Layout::Sliders::Slider::Font::variant(std::string f) {
    json["variant"] = std::move(f);
    return *this;
}

Layout::Sliders::Slider::Font& Layout::Sliders::Slider::Font::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}


Layout::Sliders::Slider::Pad& Layout::Sliders::Slider::Pad::b(double f) {
    json["b"] = std::move(f);
    return *this;
}

Layout::Sliders::Slider::Pad& Layout::Sliders::Slider::Pad::l(double f) {
    json["l"] = std::move(f);
    return *this;
}

Layout::Sliders::Slider::Pad& Layout::Sliders::Slider::Pad::r(double f) {
    json["r"] = std::move(f);
    return *this;
}

Layout::Sliders::Slider::Pad& Layout::Sliders::Slider::Pad::t(double f) {
    json["t"] = std::move(f);
    return *this;
}


Layout::Sliders::Slider::Steps& Layout::Sliders::Slider::Steps::step(Step f) {
    json["step"] = std::move(f.json);
    return *this;
}

std::string Layout::Sliders::Slider::Steps::Step::to_string(Method e) {
    switch(e) {
        case Method::RESTYLE: return "restyle";
        case Method::RELAYOUT: return "relayout";
        case Method::ANIMATE: return "animate";
        case Method::UPDATE: return "update";
        case Method::SKIP: return "skip";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Sliders::Slider::Steps::Step& Layout::Sliders::Slider::Steps::Step::args(std::vector<double> f) {
    json["args"] = std::move(f);
    return *this;
}

Layout::Sliders::Slider::Steps::Step& Layout::Sliders::Slider::Steps::Step::execute(bool f) {
    json["execute"] = std::move(f);
    return *this;
}

Layout::Sliders::Slider::Steps::Step& Layout::Sliders::Slider::Steps::Step::label(std::string f) {
    json["label"] = std::move(f);
    return *this;
}

Layout::Sliders::Slider::Steps::Step& Layout::Sliders::Slider::Steps::Step::method(enum Method f) {
    json["method"] = to_string(f);
    return *this;
}

Layout::Sliders::Slider::Steps::Step& Layout::Sliders::Slider::Steps::Step::name(std::string f) {
    json["name"] = std::move(f);
    return *this;
}

Layout::Sliders::Slider::Steps::Step& Layout::Sliders::Slider::Steps::Step::templateitemname(std::string f) {
    json["templateitemname"] = std::move(f);
    return *this;
}

Layout::Sliders::Slider::Steps::Step& Layout::Sliders::Slider::Steps::Step::value(std::string f) {
    json["value"] = std::move(f);
    return *this;
}

Layout::Sliders::Slider::Steps::Step& Layout::Sliders::Slider::Steps::Step::visible(bool f) {
    json["visible"] = std::move(f);
    return *this;
}


Layout::Sliders::Slider::Transition& Layout::Sliders::Slider::Transition::duration(double f) {
    json["duration"] = std::move(f);
    return *this;
}

Layout::Sliders::Slider::Transition& Layout::Sliders::Slider::Transition::easing(std::string f) {
    json["easing"] = std::move(f);
    return *this;
}


Layout::Smith& Layout::Smith::bgcolor(std::string f) {
    json["bgcolor"] = std::move(f);
    return *this;
}

Layout::Smith& Layout::Smith::domain(Domain f) {
    json["domain"] = std::move(f.json);
    return *this;
}

Layout::Smith& Layout::Smith::imaginaryaxis(Imaginaryaxis f) {
    json["imaginaryaxis"] = std::move(f.json);
    return *this;
}

Layout::Smith& Layout::Smith::realaxis(Realaxis f) {
    json["realaxis"] = std::move(f.json);
    return *this;
}


Layout::Smith::Domain& Layout::Smith::Domain::column(int f) {
    json["column"] = std::move(f);
    return *this;
}

Layout::Smith::Domain& Layout::Smith::Domain::row(int f) {
    json["row"] = std::move(f);
    return *this;
}

Layout::Smith::Domain& Layout::Smith::Domain::x(std::vector<double> f) {
    json["x"] = std::move(f);
    return *this;
}

Layout::Smith::Domain& Layout::Smith::Domain::y(std::vector<double> f) {
    json["y"] = std::move(f);
    return *this;
}

std::string Layout::Smith::Imaginaryaxis::to_string(Showtickprefix e) {
    switch(e) {
        case Showtickprefix::ALL: return "all";
        case Showtickprefix::FIRST: return "first";
        case Showtickprefix::LAST: return "last";
        case Showtickprefix::NONE: return "none";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Smith::Imaginaryaxis::to_string(Showticksuffix e) {
    switch(e) {
        case Showticksuffix::ALL: return "all";
        case Showticksuffix::FIRST: return "first";
        case Showticksuffix::LAST: return "last";
        case Showticksuffix::NONE: return "none";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Smith::Imaginaryaxis::to_string(Ticks e) {
    switch(e) {
        case Ticks::OUTSIDE: return "outside";
        case Ticks::INSIDE: return "inside";
        case Ticks::EMPTY: return "";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Smith::Imaginaryaxis& Layout::Smith::Imaginaryaxis::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Smith::Imaginaryaxis& Layout::Smith::Imaginaryaxis::gridcolor(std::string f) {
    json["gridcolor"] = std::move(f);
    return *this;
}

Layout::Smith::Imaginaryaxis& Layout::Smith::Imaginaryaxis::griddash(std::string f) {
    json["griddash"] = std::move(f);
    return *this;
}

Layout::Smith::Imaginaryaxis& Layout::Smith::Imaginaryaxis::gridwidth(double f) {
    json["gridwidth"] = std::move(f);
    return *this;
}

Layout::Smith::Imaginaryaxis& Layout::Smith::Imaginaryaxis::hoverformat(std::string f) {
    json["hoverformat"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Smith::Imaginaryaxis& Layout::Smith::Imaginaryaxis::labelalias(T f) {
    json["labelalias"] = std::move(f);
    return *this;
}

Layout::Smith::Imaginaryaxis& Layout::Smith::Imaginaryaxis::layer(std::string f) {
    json["layer"] = std::move(f);
    return *this;
}

Layout::Smith::Imaginaryaxis& Layout::Smith::Imaginaryaxis::linecolor(std::string f) {
    json["linecolor"] = std::move(f);
    return *this;
}

Layout::Smith::Imaginaryaxis& Layout::Smith::Imaginaryaxis::linewidth(double f) {
    json["linewidth"] = std::move(f);
    return *this;
}

Layout::Smith::Imaginaryaxis& Layout::Smith::Imaginaryaxis::showgrid(bool f) {
    json["showgrid"] = std::move(f);
    return *this;
}

Layout::Smith::Imaginaryaxis& Layout::Smith::Imaginaryaxis::showline(bool f) {
    json["showline"] = std::move(f);
    return *this;
}

Layout::Smith::Imaginaryaxis& Layout::Smith::Imaginaryaxis::showticklabels(bool f) {
    json["showticklabels"] = std::move(f);
    return *this;
}

Layout::Smith::Imaginaryaxis& Layout::Smith::Imaginaryaxis::showtickprefix(enum Showtickprefix f) {
    json["showtickprefix"] = to_string(f);
    return *this;
}

Layout::Smith::Imaginaryaxis& Layout::Smith::Imaginaryaxis::showticksuffix(enum Showticksuffix f) {
    json["showticksuffix"] = to_string(f);
    return *this;
}

Layout::Smith::Imaginaryaxis& Layout::Smith::Imaginaryaxis::tickcolor(std::string f) {
    json["tickcolor"] = std::move(f);
    return *this;
}

Layout::Smith::Imaginaryaxis& Layout::Smith::Imaginaryaxis::tickfont(Tickfont f) {
    json["tickfont"] = std::move(f.json);
    return *this;
}

Layout::Smith::Imaginaryaxis& Layout::Smith::Imaginaryaxis::tickformat(std::string f) {
    json["tickformat"] = std::move(f);
    return *this;
}

Layout::Smith::Imaginaryaxis& Layout::Smith::Imaginaryaxis::ticklen(double f) {
    json["ticklen"] = std::move(f);
    return *this;
}

Layout::Smith::Imaginaryaxis& Layout::Smith::Imaginaryaxis::tickprefix(std::string f) {
    json["tickprefix"] = std::move(f);
    return *this;
}

Layout::Smith::Imaginaryaxis& Layout::Smith::Imaginaryaxis::ticks(enum Ticks f) {
    json["ticks"] = to_string(f);
    return *this;
}

Layout::Smith::Imaginaryaxis& Layout::Smith::Imaginaryaxis::ticksuffix(std::string f) {
    json["ticksuffix"] = std::move(f);
    return *this;
}

template <typename T, typename>
Layout::Smith::Imaginaryaxis& Layout::Smith::Imaginaryaxis::tickvals(std::vector<T> f) {
    json["tickvals"] = std::move(f);
    return *this;
}

Layout::Smith::Imaginaryaxis& Layout::Smith::Imaginaryaxis::tickvalssrc(std::string f) {
    json["tickvalssrc"] = std::move(f);
    return *this;
}

Layout::Smith::Imaginaryaxis& Layout::Smith::Imaginaryaxis::tickwidth(double f) {
    json["tickwidth"] = std::move(f);
    return *this;
}

Layout::Smith::Imaginaryaxis& Layout::Smith::Imaginaryaxis::visible(bool f) {
    json["visible"] = std::move(f);
    return *this;
}

std::string Layout::Smith::Imaginaryaxis::Tickfont::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Smith::Imaginaryaxis::Tickfont& Layout::Smith::Imaginaryaxis::Tickfont::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Smith::Imaginaryaxis::Tickfont& Layout::Smith::Imaginaryaxis::Tickfont::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Smith::Imaginaryaxis::Tickfont& Layout::Smith::Imaginaryaxis::Tickfont::lineposition(std::string f) {
    json["lineposition"] = std::move(f);
    return *this;
}

Layout::Smith::Imaginaryaxis::Tickfont& Layout::Smith::Imaginaryaxis::Tickfont::shadow(std::string f) {
    json["shadow"] = std::move(f);
    return *this;
}

Layout::Smith::Imaginaryaxis::Tickfont& Layout::Smith::Imaginaryaxis::Tickfont::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Smith::Imaginaryaxis::Tickfont& Layout::Smith::Imaginaryaxis::Tickfont::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Smith::Imaginaryaxis::Tickfont& Layout::Smith::Imaginaryaxis::Tickfont::textcase(std::string f) {
    json["textcase"] = std::move(f);
    return *this;
}

Layout::Smith::Imaginaryaxis::Tickfont& Layout::Smith::Imaginaryaxis::Tickfont::variant(std::string f) {
    json["variant"] = std::move(f);
    return *this;
}

Layout::Smith::Imaginaryaxis::Tickfont& Layout::Smith::Imaginaryaxis::Tickfont::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}

std::string Layout::Smith::Realaxis::to_string(Showtickprefix e) {
    switch(e) {
        case Showtickprefix::ALL: return "all";
        case Showtickprefix::FIRST: return "first";
        case Showtickprefix::LAST: return "last";
        case Showtickprefix::NONE: return "none";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Smith::Realaxis::to_string(Showticksuffix e) {
    switch(e) {
        case Showticksuffix::ALL: return "all";
        case Showticksuffix::FIRST: return "first";
        case Showticksuffix::LAST: return "last";
        case Showticksuffix::NONE: return "none";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Smith::Realaxis::to_string(Side e) {
    switch(e) {
        case Side::TOP: return "top";
        case Side::BOTTOM: return "bottom";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Smith::Realaxis::to_string(Ticks e) {
    switch(e) {
        case Ticks::TOP: return "top";
        case Ticks::BOTTOM: return "bottom";
        case Ticks::EMPTY: return "";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Smith::Realaxis& Layout::Smith::Realaxis::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Smith::Realaxis& Layout::Smith::Realaxis::gridcolor(std::string f) {
    json["gridcolor"] = std::move(f);
    return *this;
}

Layout::Smith::Realaxis& Layout::Smith::Realaxis::griddash(std::string f) {
    json["griddash"] = std::move(f);
    return *this;
}

Layout::Smith::Realaxis& Layout::Smith::Realaxis::gridwidth(double f) {
    json["gridwidth"] = std::move(f);
    return *this;
}

Layout::Smith::Realaxis& Layout::Smith::Realaxis::hoverformat(std::string f) {
    json["hoverformat"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Smith::Realaxis& Layout::Smith::Realaxis::labelalias(T f) {
    json["labelalias"] = std::move(f);
    return *this;
}

Layout::Smith::Realaxis& Layout::Smith::Realaxis::layer(std::string f) {
    json["layer"] = std::move(f);
    return *this;
}

Layout::Smith::Realaxis& Layout::Smith::Realaxis::linecolor(std::string f) {
    json["linecolor"] = std::move(f);
    return *this;
}

Layout::Smith::Realaxis& Layout::Smith::Realaxis::linewidth(double f) {
    json["linewidth"] = std::move(f);
    return *this;
}

Layout::Smith::Realaxis& Layout::Smith::Realaxis::showgrid(bool f) {
    json["showgrid"] = std::move(f);
    return *this;
}

Layout::Smith::Realaxis& Layout::Smith::Realaxis::showline(bool f) {
    json["showline"] = std::move(f);
    return *this;
}

Layout::Smith::Realaxis& Layout::Smith::Realaxis::showticklabels(bool f) {
    json["showticklabels"] = std::move(f);
    return *this;
}

Layout::Smith::Realaxis& Layout::Smith::Realaxis::showtickprefix(enum Showtickprefix f) {
    json["showtickprefix"] = to_string(f);
    return *this;
}

Layout::Smith::Realaxis& Layout::Smith::Realaxis::showticksuffix(enum Showticksuffix f) {
    json["showticksuffix"] = to_string(f);
    return *this;
}

Layout::Smith::Realaxis& Layout::Smith::Realaxis::side(enum Side f) {
    json["side"] = to_string(f);
    return *this;
}

Layout::Smith::Realaxis& Layout::Smith::Realaxis::tickangle(double f) {
    json["tickangle"] = std::move(f);
    return *this;
}

Layout::Smith::Realaxis& Layout::Smith::Realaxis::tickcolor(std::string f) {
    json["tickcolor"] = std::move(f);
    return *this;
}

Layout::Smith::Realaxis& Layout::Smith::Realaxis::tickfont(Tickfont f) {
    json["tickfont"] = std::move(f.json);
    return *this;
}

Layout::Smith::Realaxis& Layout::Smith::Realaxis::tickformat(std::string f) {
    json["tickformat"] = std::move(f);
    return *this;
}

Layout::Smith::Realaxis& Layout::Smith::Realaxis::ticklen(double f) {
    json["ticklen"] = std::move(f);
    return *this;
}

Layout::Smith::Realaxis& Layout::Smith::Realaxis::tickprefix(std::string f) {
    json["tickprefix"] = std::move(f);
    return *this;
}

Layout::Smith::Realaxis& Layout::Smith::Realaxis::ticks(enum Ticks f) {
    json["ticks"] = to_string(f);
    return *this;
}

Layout::Smith::Realaxis& Layout::Smith::Realaxis::ticksuffix(std::string f) {
    json["ticksuffix"] = std::move(f);
    return *this;
}

template <typename T, typename>
Layout::Smith::Realaxis& Layout::Smith::Realaxis::tickvals(std::vector<T> f) {
    json["tickvals"] = std::move(f);
    return *this;
}

Layout::Smith::Realaxis& Layout::Smith::Realaxis::tickvalssrc(std::string f) {
    json["tickvalssrc"] = std::move(f);
    return *this;
}

Layout::Smith::Realaxis& Layout::Smith::Realaxis::tickwidth(double f) {
    json["tickwidth"] = std::move(f);
    return *this;
}

Layout::Smith::Realaxis& Layout::Smith::Realaxis::visible(bool f) {
    json["visible"] = std::move(f);
    return *this;
}

std::string Layout::Smith::Realaxis::Tickfont::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Smith::Realaxis::Tickfont& Layout::Smith::Realaxis::Tickfont::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Smith::Realaxis::Tickfont& Layout::Smith::Realaxis::Tickfont::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Smith::Realaxis::Tickfont& Layout::Smith::Realaxis::Tickfont::lineposition(std::string f) {
    json["lineposition"] = std::move(f);
    return *this;
}

Layout::Smith::Realaxis::Tickfont& Layout::Smith::Realaxis::Tickfont::shadow(std::string f) {
    json["shadow"] = std::move(f);
    return *this;
}

Layout::Smith::Realaxis::Tickfont& Layout::Smith::Realaxis::Tickfont::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Smith::Realaxis::Tickfont& Layout::Smith::Realaxis::Tickfont::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Smith::Realaxis::Tickfont& Layout::Smith::Realaxis::Tickfont::textcase(std::string f) {
    json["textcase"] = std::move(f);
    return *this;
}

Layout::Smith::Realaxis::Tickfont& Layout::Smith::Realaxis::Tickfont::variant(std::string f) {
    json["variant"] = std::move(f);
    return *this;
}

Layout::Smith::Realaxis::Tickfont& Layout::Smith::Realaxis::Tickfont::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}


Layout::Ternary& Layout::Ternary::aaxis(Aaxis f) {
    json["aaxis"] = std::move(f.json);
    return *this;
}

Layout::Ternary& Layout::Ternary::baxis(Baxis f) {
    json["baxis"] = std::move(f.json);
    return *this;
}

Layout::Ternary& Layout::Ternary::bgcolor(std::string f) {
    json["bgcolor"] = std::move(f);
    return *this;
}

Layout::Ternary& Layout::Ternary::caxis(Caxis f) {
    json["caxis"] = std::move(f.json);
    return *this;
}

Layout::Ternary& Layout::Ternary::domain(Domain f) {
    json["domain"] = std::move(f.json);
    return *this;
}

Layout::Ternary& Layout::Ternary::sum(double f) {
    json["sum"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Ternary& Layout::Ternary::uirevision(T f) {
    json["uirevision"] = std::move(f);
    return *this;
}

std::string Layout::Ternary::Aaxis::to_string(Exponentformat e) {
    switch(e) {
        case Exponentformat::NONE: return "none";
        case Exponentformat::E: return "E";
        case Exponentformat::POWER: return "power";
        case Exponentformat::SI: return "SI";
        case Exponentformat::B: return "B";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Ternary::Aaxis::to_string(Showexponent e) {
    switch(e) {
        case Showexponent::ALL: return "all";
        case Showexponent::FIRST: return "first";
        case Showexponent::LAST: return "last";
        case Showexponent::NONE: return "none";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Ternary::Aaxis::to_string(Showtickprefix e) {
    switch(e) {
        case Showtickprefix::ALL: return "all";
        case Showtickprefix::FIRST: return "first";
        case Showtickprefix::LAST: return "last";
        case Showtickprefix::NONE: return "none";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Ternary::Aaxis::to_string(Showticksuffix e) {
    switch(e) {
        case Showticksuffix::ALL: return "all";
        case Showticksuffix::FIRST: return "first";
        case Showticksuffix::LAST: return "last";
        case Showticksuffix::NONE: return "none";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Ternary::Aaxis::to_string(Tickmode e) {
    switch(e) {
        case Tickmode::AUTO: return "auto";
        case Tickmode::LINEAR: return "linear";
        case Tickmode::ARRAY: return "array";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Ternary::Aaxis::to_string(Ticks e) {
    switch(e) {
        case Ticks::OUTSIDE: return "outside";
        case Ticks::INSIDE: return "inside";
        case Ticks::EMPTY: return "";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Ternary::Aaxis& Layout::Ternary::Aaxis::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Ternary::Aaxis& Layout::Ternary::Aaxis::dtick(T f) {
    json["dtick"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis& Layout::Ternary::Aaxis::exponentformat(enum Exponentformat f) {
    json["exponentformat"] = to_string(f);
    return *this;
}

Layout::Ternary::Aaxis& Layout::Ternary::Aaxis::gridcolor(std::string f) {
    json["gridcolor"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis& Layout::Ternary::Aaxis::griddash(std::string f) {
    json["griddash"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis& Layout::Ternary::Aaxis::gridwidth(double f) {
    json["gridwidth"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis& Layout::Ternary::Aaxis::hoverformat(std::string f) {
    json["hoverformat"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Ternary::Aaxis& Layout::Ternary::Aaxis::labelalias(T f) {
    json["labelalias"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis& Layout::Ternary::Aaxis::layer(std::string f) {
    json["layer"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis& Layout::Ternary::Aaxis::linecolor(std::string f) {
    json["linecolor"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis& Layout::Ternary::Aaxis::linewidth(double f) {
    json["linewidth"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis& Layout::Ternary::Aaxis::min(double f) {
    json["min"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis& Layout::Ternary::Aaxis::minexponent(double f) {
    json["minexponent"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis& Layout::Ternary::Aaxis::nticks(int f) {
    json["nticks"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis& Layout::Ternary::Aaxis::separatethousands(bool f) {
    json["separatethousands"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis& Layout::Ternary::Aaxis::showexponent(enum Showexponent f) {
    json["showexponent"] = to_string(f);
    return *this;
}

Layout::Ternary::Aaxis& Layout::Ternary::Aaxis::showgrid(bool f) {
    json["showgrid"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis& Layout::Ternary::Aaxis::showline(bool f) {
    json["showline"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis& Layout::Ternary::Aaxis::showticklabels(bool f) {
    json["showticklabels"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis& Layout::Ternary::Aaxis::showtickprefix(enum Showtickprefix f) {
    json["showtickprefix"] = to_string(f);
    return *this;
}

Layout::Ternary::Aaxis& Layout::Ternary::Aaxis::showticksuffix(enum Showticksuffix f) {
    json["showticksuffix"] = to_string(f);
    return *this;
}

template <typename T>
Layout::Ternary::Aaxis& Layout::Ternary::Aaxis::tick0(T f) {
    json["tick0"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis& Layout::Ternary::Aaxis::tickangle(double f) {
    json["tickangle"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis& Layout::Ternary::Aaxis::tickcolor(std::string f) {
    json["tickcolor"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis& Layout::Ternary::Aaxis::tickfont(Tickfont f) {
    json["tickfont"] = std::move(f.json);
    return *this;
}

Layout::Ternary::Aaxis& Layout::Ternary::Aaxis::tickformat(std::string f) {
    json["tickformat"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis& Layout::Ternary::Aaxis::tickformatstops(Tickformatstops f) {
    json["tickformatstops"] = std::move(f.json);
    return *this;
}

Layout::Ternary::Aaxis& Layout::Ternary::Aaxis::ticklabelstep(int f) {
    json["ticklabelstep"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis& Layout::Ternary::Aaxis::ticklen(double f) {
    json["ticklen"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis& Layout::Ternary::Aaxis::tickmode(enum Tickmode f) {
    json["tickmode"] = to_string(f);
    return *this;
}

Layout::Ternary::Aaxis& Layout::Ternary::Aaxis::tickprefix(std::string f) {
    json["tickprefix"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis& Layout::Ternary::Aaxis::ticks(enum Ticks f) {
    json["ticks"] = to_string(f);
    return *this;
}

Layout::Ternary::Aaxis& Layout::Ternary::Aaxis::ticksuffix(std::string f) {
    json["ticksuffix"] = std::move(f);
    return *this;
}

template <typename T, typename>
Layout::Ternary::Aaxis& Layout::Ternary::Aaxis::ticktext(std::vector<T> f) {
    json["ticktext"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis& Layout::Ternary::Aaxis::ticktextsrc(std::string f) {
    json["ticktextsrc"] = std::move(f);
    return *this;
}

template <typename T, typename>
Layout::Ternary::Aaxis& Layout::Ternary::Aaxis::tickvals(std::vector<T> f) {
    json["tickvals"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis& Layout::Ternary::Aaxis::tickvalssrc(std::string f) {
    json["tickvalssrc"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis& Layout::Ternary::Aaxis::tickwidth(double f) {
    json["tickwidth"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis& Layout::Ternary::Aaxis::title(Title f) {
    json["title"] = std::move(f.json);
    return *this;
}

template <typename T>
Layout::Ternary::Aaxis& Layout::Ternary::Aaxis::uirevision(T f) {
    json["uirevision"] = std::move(f);
    return *this;
}

std::string Layout::Ternary::Aaxis::Tickfont::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Ternary::Aaxis::Tickfont& Layout::Ternary::Aaxis::Tickfont::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis::Tickfont& Layout::Ternary::Aaxis::Tickfont::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis::Tickfont& Layout::Ternary::Aaxis::Tickfont::lineposition(std::string f) {
    json["lineposition"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis::Tickfont& Layout::Ternary::Aaxis::Tickfont::shadow(std::string f) {
    json["shadow"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis::Tickfont& Layout::Ternary::Aaxis::Tickfont::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis::Tickfont& Layout::Ternary::Aaxis::Tickfont::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Ternary::Aaxis::Tickfont& Layout::Ternary::Aaxis::Tickfont::textcase(std::string f) {
    json["textcase"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis::Tickfont& Layout::Ternary::Aaxis::Tickfont::variant(std::string f) {
    json["variant"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis::Tickfont& Layout::Ternary::Aaxis::Tickfont::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}


Layout::Ternary::Aaxis::Tickformatstops& Layout::Ternary::Aaxis::Tickformatstops::tickformatstop(Tickformatstop f) {
    json["tickformatstop"] = std::move(f.json);
    return *this;
}


Layout::Ternary::Aaxis::Tickformatstops::Tickformatstop& Layout::Ternary::Aaxis::Tickformatstops::Tickformatstop::dtickrange(std::vector<double> f) {
    json["dtickrange"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis::Tickformatstops::Tickformatstop& Layout::Ternary::Aaxis::Tickformatstops::Tickformatstop::enabled(bool f) {
    json["enabled"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis::Tickformatstops::Tickformatstop& Layout::Ternary::Aaxis::Tickformatstops::Tickformatstop::name(std::string f) {
    json["name"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis::Tickformatstops::Tickformatstop& Layout::Ternary::Aaxis::Tickformatstops::Tickformatstop::templateitemname(std::string f) {
    json["templateitemname"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis::Tickformatstops::Tickformatstop& Layout::Ternary::Aaxis::Tickformatstops::Tickformatstop::value(std::string f) {
    json["value"] = std::move(f);
    return *this;
}


Layout::Ternary::Aaxis::Title& Layout::Ternary::Aaxis::Title::font(Font f) {
    json["font"] = std::move(f.json);
    return *this;
}

Layout::Ternary::Aaxis::Title& Layout::Ternary::Aaxis::Title::text(std::string f) {
    json["text"] = std::move(f);
    return *this;
}

std::string Layout::Ternary::Aaxis::Title::Font::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Ternary::Aaxis::Title::Font& Layout::Ternary::Aaxis::Title::Font::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis::Title::Font& Layout::Ternary::Aaxis::Title::Font::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis::Title::Font& Layout::Ternary::Aaxis::Title::Font::lineposition(std::string f) {
    json["lineposition"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis::Title::Font& Layout::Ternary::Aaxis::Title::Font::shadow(std::string f) {
    json["shadow"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis::Title::Font& Layout::Ternary::Aaxis::Title::Font::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis::Title::Font& Layout::Ternary::Aaxis::Title::Font::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Ternary::Aaxis::Title::Font& Layout::Ternary::Aaxis::Title::Font::textcase(std::string f) {
    json["textcase"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis::Title::Font& Layout::Ternary::Aaxis::Title::Font::variant(std::string f) {
    json["variant"] = std::move(f);
    return *this;
}

Layout::Ternary::Aaxis::Title::Font& Layout::Ternary::Aaxis::Title::Font::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}

std::string Layout::Ternary::Baxis::to_string(Exponentformat e) {
    switch(e) {
        case Exponentformat::NONE: return "none";
        case Exponentformat::E: return "E";
        case Exponentformat::POWER: return "power";
        case Exponentformat::SI: return "SI";
        case Exponentformat::B: return "B";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Ternary::Baxis::to_string(Showexponent e) {
    switch(e) {
        case Showexponent::ALL: return "all";
        case Showexponent::FIRST: return "first";
        case Showexponent::LAST: return "last";
        case Showexponent::NONE: return "none";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Ternary::Baxis::to_string(Showtickprefix e) {
    switch(e) {
        case Showtickprefix::ALL: return "all";
        case Showtickprefix::FIRST: return "first";
        case Showtickprefix::LAST: return "last";
        case Showtickprefix::NONE: return "none";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Ternary::Baxis::to_string(Showticksuffix e) {
    switch(e) {
        case Showticksuffix::ALL: return "all";
        case Showticksuffix::FIRST: return "first";
        case Showticksuffix::LAST: return "last";
        case Showticksuffix::NONE: return "none";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Ternary::Baxis::to_string(Tickmode e) {
    switch(e) {
        case Tickmode::AUTO: return "auto";
        case Tickmode::LINEAR: return "linear";
        case Tickmode::ARRAY: return "array";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Ternary::Baxis::to_string(Ticks e) {
    switch(e) {
        case Ticks::OUTSIDE: return "outside";
        case Ticks::INSIDE: return "inside";
        case Ticks::EMPTY: return "";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Ternary::Baxis& Layout::Ternary::Baxis::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Ternary::Baxis& Layout::Ternary::Baxis::dtick(T f) {
    json["dtick"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis& Layout::Ternary::Baxis::exponentformat(enum Exponentformat f) {
    json["exponentformat"] = to_string(f);
    return *this;
}

Layout::Ternary::Baxis& Layout::Ternary::Baxis::gridcolor(std::string f) {
    json["gridcolor"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis& Layout::Ternary::Baxis::griddash(std::string f) {
    json["griddash"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis& Layout::Ternary::Baxis::gridwidth(double f) {
    json["gridwidth"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis& Layout::Ternary::Baxis::hoverformat(std::string f) {
    json["hoverformat"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Ternary::Baxis& Layout::Ternary::Baxis::labelalias(T f) {
    json["labelalias"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis& Layout::Ternary::Baxis::layer(std::string f) {
    json["layer"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis& Layout::Ternary::Baxis::linecolor(std::string f) {
    json["linecolor"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis& Layout::Ternary::Baxis::linewidth(double f) {
    json["linewidth"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis& Layout::Ternary::Baxis::min(double f) {
    json["min"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis& Layout::Ternary::Baxis::minexponent(double f) {
    json["minexponent"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis& Layout::Ternary::Baxis::nticks(int f) {
    json["nticks"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis& Layout::Ternary::Baxis::separatethousands(bool f) {
    json["separatethousands"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis& Layout::Ternary::Baxis::showexponent(enum Showexponent f) {
    json["showexponent"] = to_string(f);
    return *this;
}

Layout::Ternary::Baxis& Layout::Ternary::Baxis::showgrid(bool f) {
    json["showgrid"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis& Layout::Ternary::Baxis::showline(bool f) {
    json["showline"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis& Layout::Ternary::Baxis::showticklabels(bool f) {
    json["showticklabels"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis& Layout::Ternary::Baxis::showtickprefix(enum Showtickprefix f) {
    json["showtickprefix"] = to_string(f);
    return *this;
}

Layout::Ternary::Baxis& Layout::Ternary::Baxis::showticksuffix(enum Showticksuffix f) {
    json["showticksuffix"] = to_string(f);
    return *this;
}

template <typename T>
Layout::Ternary::Baxis& Layout::Ternary::Baxis::tick0(T f) {
    json["tick0"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis& Layout::Ternary::Baxis::tickangle(double f) {
    json["tickangle"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis& Layout::Ternary::Baxis::tickcolor(std::string f) {
    json["tickcolor"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis& Layout::Ternary::Baxis::tickfont(Tickfont f) {
    json["tickfont"] = std::move(f.json);
    return *this;
}

Layout::Ternary::Baxis& Layout::Ternary::Baxis::tickformat(std::string f) {
    json["tickformat"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis& Layout::Ternary::Baxis::tickformatstops(Tickformatstops f) {
    json["tickformatstops"] = std::move(f.json);
    return *this;
}

Layout::Ternary::Baxis& Layout::Ternary::Baxis::ticklabelstep(int f) {
    json["ticklabelstep"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis& Layout::Ternary::Baxis::ticklen(double f) {
    json["ticklen"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis& Layout::Ternary::Baxis::tickmode(enum Tickmode f) {
    json["tickmode"] = to_string(f);
    return *this;
}

Layout::Ternary::Baxis& Layout::Ternary::Baxis::tickprefix(std::string f) {
    json["tickprefix"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis& Layout::Ternary::Baxis::ticks(enum Ticks f) {
    json["ticks"] = to_string(f);
    return *this;
}

Layout::Ternary::Baxis& Layout::Ternary::Baxis::ticksuffix(std::string f) {
    json["ticksuffix"] = std::move(f);
    return *this;
}

template <typename T, typename>
Layout::Ternary::Baxis& Layout::Ternary::Baxis::ticktext(std::vector<T> f) {
    json["ticktext"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis& Layout::Ternary::Baxis::ticktextsrc(std::string f) {
    json["ticktextsrc"] = std::move(f);
    return *this;
}

template <typename T, typename>
Layout::Ternary::Baxis& Layout::Ternary::Baxis::tickvals(std::vector<T> f) {
    json["tickvals"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis& Layout::Ternary::Baxis::tickvalssrc(std::string f) {
    json["tickvalssrc"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis& Layout::Ternary::Baxis::tickwidth(double f) {
    json["tickwidth"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis& Layout::Ternary::Baxis::title(Title f) {
    json["title"] = std::move(f.json);
    return *this;
}

template <typename T>
Layout::Ternary::Baxis& Layout::Ternary::Baxis::uirevision(T f) {
    json["uirevision"] = std::move(f);
    return *this;
}

std::string Layout::Ternary::Baxis::Tickfont::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Ternary::Baxis::Tickfont& Layout::Ternary::Baxis::Tickfont::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis::Tickfont& Layout::Ternary::Baxis::Tickfont::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis::Tickfont& Layout::Ternary::Baxis::Tickfont::lineposition(std::string f) {
    json["lineposition"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis::Tickfont& Layout::Ternary::Baxis::Tickfont::shadow(std::string f) {
    json["shadow"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis::Tickfont& Layout::Ternary::Baxis::Tickfont::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis::Tickfont& Layout::Ternary::Baxis::Tickfont::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Ternary::Baxis::Tickfont& Layout::Ternary::Baxis::Tickfont::textcase(std::string f) {
    json["textcase"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis::Tickfont& Layout::Ternary::Baxis::Tickfont::variant(std::string f) {
    json["variant"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis::Tickfont& Layout::Ternary::Baxis::Tickfont::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}


Layout::Ternary::Baxis::Tickformatstops& Layout::Ternary::Baxis::Tickformatstops::tickformatstop(Tickformatstop f) {
    json["tickformatstop"] = std::move(f.json);
    return *this;
}


Layout::Ternary::Baxis::Tickformatstops::Tickformatstop& Layout::Ternary::Baxis::Tickformatstops::Tickformatstop::dtickrange(std::vector<double> f) {
    json["dtickrange"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis::Tickformatstops::Tickformatstop& Layout::Ternary::Baxis::Tickformatstops::Tickformatstop::enabled(bool f) {
    json["enabled"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis::Tickformatstops::Tickformatstop& Layout::Ternary::Baxis::Tickformatstops::Tickformatstop::name(std::string f) {
    json["name"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis::Tickformatstops::Tickformatstop& Layout::Ternary::Baxis::Tickformatstops::Tickformatstop::templateitemname(std::string f) {
    json["templateitemname"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis::Tickformatstops::Tickformatstop& Layout::Ternary::Baxis::Tickformatstops::Tickformatstop::value(std::string f) {
    json["value"] = std::move(f);
    return *this;
}


Layout::Ternary::Baxis::Title& Layout::Ternary::Baxis::Title::font(Font f) {
    json["font"] = std::move(f.json);
    return *this;
}

Layout::Ternary::Baxis::Title& Layout::Ternary::Baxis::Title::text(std::string f) {
    json["text"] = std::move(f);
    return *this;
}

std::string Layout::Ternary::Baxis::Title::Font::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Ternary::Baxis::Title::Font& Layout::Ternary::Baxis::Title::Font::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis::Title::Font& Layout::Ternary::Baxis::Title::Font::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis::Title::Font& Layout::Ternary::Baxis::Title::Font::lineposition(std::string f) {
    json["lineposition"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis::Title::Font& Layout::Ternary::Baxis::Title::Font::shadow(std::string f) {
    json["shadow"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis::Title::Font& Layout::Ternary::Baxis::Title::Font::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis::Title::Font& Layout::Ternary::Baxis::Title::Font::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Ternary::Baxis::Title::Font& Layout::Ternary::Baxis::Title::Font::textcase(std::string f) {
    json["textcase"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis::Title::Font& Layout::Ternary::Baxis::Title::Font::variant(std::string f) {
    json["variant"] = std::move(f);
    return *this;
}

Layout::Ternary::Baxis::Title::Font& Layout::Ternary::Baxis::Title::Font::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}

std::string Layout::Ternary::Caxis::to_string(Exponentformat e) {
    switch(e) {
        case Exponentformat::NONE: return "none";
        case Exponentformat::E: return "E";
        case Exponentformat::POWER: return "power";
        case Exponentformat::SI: return "SI";
        case Exponentformat::B: return "B";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Ternary::Caxis::to_string(Showexponent e) {
    switch(e) {
        case Showexponent::ALL: return "all";
        case Showexponent::FIRST: return "first";
        case Showexponent::LAST: return "last";
        case Showexponent::NONE: return "none";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Ternary::Caxis::to_string(Showtickprefix e) {
    switch(e) {
        case Showtickprefix::ALL: return "all";
        case Showtickprefix::FIRST: return "first";
        case Showtickprefix::LAST: return "last";
        case Showtickprefix::NONE: return "none";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Ternary::Caxis::to_string(Showticksuffix e) {
    switch(e) {
        case Showticksuffix::ALL: return "all";
        case Showticksuffix::FIRST: return "first";
        case Showticksuffix::LAST: return "last";
        case Showticksuffix::NONE: return "none";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Ternary::Caxis::to_string(Tickmode e) {
    switch(e) {
        case Tickmode::AUTO: return "auto";
        case Tickmode::LINEAR: return "linear";
        case Tickmode::ARRAY: return "array";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Ternary::Caxis::to_string(Ticks e) {
    switch(e) {
        case Ticks::OUTSIDE: return "outside";
        case Ticks::INSIDE: return "inside";
        case Ticks::EMPTY: return "";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Ternary::Caxis& Layout::Ternary::Caxis::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Ternary::Caxis& Layout::Ternary::Caxis::dtick(T f) {
    json["dtick"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis& Layout::Ternary::Caxis::exponentformat(enum Exponentformat f) {
    json["exponentformat"] = to_string(f);
    return *this;
}

Layout::Ternary::Caxis& Layout::Ternary::Caxis::gridcolor(std::string f) {
    json["gridcolor"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis& Layout::Ternary::Caxis::griddash(std::string f) {
    json["griddash"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis& Layout::Ternary::Caxis::gridwidth(double f) {
    json["gridwidth"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis& Layout::Ternary::Caxis::hoverformat(std::string f) {
    json["hoverformat"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Ternary::Caxis& Layout::Ternary::Caxis::labelalias(T f) {
    json["labelalias"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis& Layout::Ternary::Caxis::layer(std::string f) {
    json["layer"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis& Layout::Ternary::Caxis::linecolor(std::string f) {
    json["linecolor"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis& Layout::Ternary::Caxis::linewidth(double f) {
    json["linewidth"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis& Layout::Ternary::Caxis::min(double f) {
    json["min"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis& Layout::Ternary::Caxis::minexponent(double f) {
    json["minexponent"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis& Layout::Ternary::Caxis::nticks(int f) {
    json["nticks"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis& Layout::Ternary::Caxis::separatethousands(bool f) {
    json["separatethousands"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis& Layout::Ternary::Caxis::showexponent(enum Showexponent f) {
    json["showexponent"] = to_string(f);
    return *this;
}

Layout::Ternary::Caxis& Layout::Ternary::Caxis::showgrid(bool f) {
    json["showgrid"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis& Layout::Ternary::Caxis::showline(bool f) {
    json["showline"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis& Layout::Ternary::Caxis::showticklabels(bool f) {
    json["showticklabels"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis& Layout::Ternary::Caxis::showtickprefix(enum Showtickprefix f) {
    json["showtickprefix"] = to_string(f);
    return *this;
}

Layout::Ternary::Caxis& Layout::Ternary::Caxis::showticksuffix(enum Showticksuffix f) {
    json["showticksuffix"] = to_string(f);
    return *this;
}

template <typename T>
Layout::Ternary::Caxis& Layout::Ternary::Caxis::tick0(T f) {
    json["tick0"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis& Layout::Ternary::Caxis::tickangle(double f) {
    json["tickangle"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis& Layout::Ternary::Caxis::tickcolor(std::string f) {
    json["tickcolor"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis& Layout::Ternary::Caxis::tickfont(Tickfont f) {
    json["tickfont"] = std::move(f.json);
    return *this;
}

Layout::Ternary::Caxis& Layout::Ternary::Caxis::tickformat(std::string f) {
    json["tickformat"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis& Layout::Ternary::Caxis::tickformatstops(Tickformatstops f) {
    json["tickformatstops"] = std::move(f.json);
    return *this;
}

Layout::Ternary::Caxis& Layout::Ternary::Caxis::ticklabelstep(int f) {
    json["ticklabelstep"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis& Layout::Ternary::Caxis::ticklen(double f) {
    json["ticklen"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis& Layout::Ternary::Caxis::tickmode(enum Tickmode f) {
    json["tickmode"] = to_string(f);
    return *this;
}

Layout::Ternary::Caxis& Layout::Ternary::Caxis::tickprefix(std::string f) {
    json["tickprefix"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis& Layout::Ternary::Caxis::ticks(enum Ticks f) {
    json["ticks"] = to_string(f);
    return *this;
}

Layout::Ternary::Caxis& Layout::Ternary::Caxis::ticksuffix(std::string f) {
    json["ticksuffix"] = std::move(f);
    return *this;
}

template <typename T, typename>
Layout::Ternary::Caxis& Layout::Ternary::Caxis::ticktext(std::vector<T> f) {
    json["ticktext"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis& Layout::Ternary::Caxis::ticktextsrc(std::string f) {
    json["ticktextsrc"] = std::move(f);
    return *this;
}

template <typename T, typename>
Layout::Ternary::Caxis& Layout::Ternary::Caxis::tickvals(std::vector<T> f) {
    json["tickvals"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis& Layout::Ternary::Caxis::tickvalssrc(std::string f) {
    json["tickvalssrc"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis& Layout::Ternary::Caxis::tickwidth(double f) {
    json["tickwidth"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis& Layout::Ternary::Caxis::title(Title f) {
    json["title"] = std::move(f.json);
    return *this;
}

template <typename T>
Layout::Ternary::Caxis& Layout::Ternary::Caxis::uirevision(T f) {
    json["uirevision"] = std::move(f);
    return *this;
}

std::string Layout::Ternary::Caxis::Tickfont::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Ternary::Caxis::Tickfont& Layout::Ternary::Caxis::Tickfont::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis::Tickfont& Layout::Ternary::Caxis::Tickfont::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis::Tickfont& Layout::Ternary::Caxis::Tickfont::lineposition(std::string f) {
    json["lineposition"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis::Tickfont& Layout::Ternary::Caxis::Tickfont::shadow(std::string f) {
    json["shadow"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis::Tickfont& Layout::Ternary::Caxis::Tickfont::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis::Tickfont& Layout::Ternary::Caxis::Tickfont::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Ternary::Caxis::Tickfont& Layout::Ternary::Caxis::Tickfont::textcase(std::string f) {
    json["textcase"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis::Tickfont& Layout::Ternary::Caxis::Tickfont::variant(std::string f) {
    json["variant"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis::Tickfont& Layout::Ternary::Caxis::Tickfont::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}


Layout::Ternary::Caxis::Tickformatstops& Layout::Ternary::Caxis::Tickformatstops::tickformatstop(Tickformatstop f) {
    json["tickformatstop"] = std::move(f.json);
    return *this;
}


Layout::Ternary::Caxis::Tickformatstops::Tickformatstop& Layout::Ternary::Caxis::Tickformatstops::Tickformatstop::dtickrange(std::vector<double> f) {
    json["dtickrange"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis::Tickformatstops::Tickformatstop& Layout::Ternary::Caxis::Tickformatstops::Tickformatstop::enabled(bool f) {
    json["enabled"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis::Tickformatstops::Tickformatstop& Layout::Ternary::Caxis::Tickformatstops::Tickformatstop::name(std::string f) {
    json["name"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis::Tickformatstops::Tickformatstop& Layout::Ternary::Caxis::Tickformatstops::Tickformatstop::templateitemname(std::string f) {
    json["templateitemname"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis::Tickformatstops::Tickformatstop& Layout::Ternary::Caxis::Tickformatstops::Tickformatstop::value(std::string f) {
    json["value"] = std::move(f);
    return *this;
}


Layout::Ternary::Caxis::Title& Layout::Ternary::Caxis::Title::font(Font f) {
    json["font"] = std::move(f.json);
    return *this;
}

Layout::Ternary::Caxis::Title& Layout::Ternary::Caxis::Title::text(std::string f) {
    json["text"] = std::move(f);
    return *this;
}

std::string Layout::Ternary::Caxis::Title::Font::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Ternary::Caxis::Title::Font& Layout::Ternary::Caxis::Title::Font::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis::Title::Font& Layout::Ternary::Caxis::Title::Font::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis::Title::Font& Layout::Ternary::Caxis::Title::Font::lineposition(std::string f) {
    json["lineposition"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis::Title::Font& Layout::Ternary::Caxis::Title::Font::shadow(std::string f) {
    json["shadow"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis::Title::Font& Layout::Ternary::Caxis::Title::Font::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis::Title::Font& Layout::Ternary::Caxis::Title::Font::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Ternary::Caxis::Title::Font& Layout::Ternary::Caxis::Title::Font::textcase(std::string f) {
    json["textcase"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis::Title::Font& Layout::Ternary::Caxis::Title::Font::variant(std::string f) {
    json["variant"] = std::move(f);
    return *this;
}

Layout::Ternary::Caxis::Title::Font& Layout::Ternary::Caxis::Title::Font::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}


Layout::Ternary::Domain& Layout::Ternary::Domain::column(int f) {
    json["column"] = std::move(f);
    return *this;
}

Layout::Ternary::Domain& Layout::Ternary::Domain::row(int f) {
    json["row"] = std::move(f);
    return *this;
}

Layout::Ternary::Domain& Layout::Ternary::Domain::x(std::vector<double> f) {
    json["x"] = std::move(f);
    return *this;
}

Layout::Ternary::Domain& Layout::Ternary::Domain::y(std::vector<double> f) {
    json["y"] = std::move(f);
    return *this;
}

std::string Layout::Title::to_string(Xanchor e) {
    switch(e) {
        case Xanchor::AUTO: return "auto";
        case Xanchor::LEFT: return "left";
        case Xanchor::CENTER: return "center";
        case Xanchor::RIGHT: return "right";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Title::to_string(Xref e) {
    switch(e) {
        case Xref::CONTAINER: return "container";
        case Xref::PAPER: return "paper";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Title::to_string(Yanchor e) {
    switch(e) {
        case Yanchor::AUTO: return "auto";
        case Yanchor::TOP: return "top";
        case Yanchor::MIDDLE: return "middle";
        case Yanchor::BOTTOM: return "bottom";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Title::to_string(Yref e) {
    switch(e) {
        case Yref::CONTAINER: return "container";
        case Yref::PAPER: return "paper";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Title& Layout::Title::automargin(bool f) {
    json["automargin"] = std::move(f);
    return *this;
}

Layout::Title& Layout::Title::font(Font f) {
    json["font"] = std::move(f.json);
    return *this;
}

Layout::Title& Layout::Title::pad(Pad f) {
    json["pad"] = std::move(f.json);
    return *this;
}

Layout::Title& Layout::Title::subtitle(Subtitle f) {
    json["subtitle"] = std::move(f.json);
    return *this;
}

Layout::Title& Layout::Title::text(std::string f) {
    json["text"] = std::move(f);
    return *this;
}

Layout::Title& Layout::Title::x(double f) {
    json["x"] = std::move(f);
    return *this;
}

Layout::Title& Layout::Title::xanchor(enum Xanchor f) {
    json["xanchor"] = to_string(f);
    return *this;
}

Layout::Title& Layout::Title::xref(enum Xref f) {
    json["xref"] = to_string(f);
    return *this;
}

Layout::Title& Layout::Title::y(double f) {
    json["y"] = std::move(f);
    return *this;
}

Layout::Title& Layout::Title::yanchor(enum Yanchor f) {
    json["yanchor"] = to_string(f);
    return *this;
}

Layout::Title& Layout::Title::yref(enum Yref f) {
    json["yref"] = to_string(f);
    return *this;
}

std::string Layout::Title::Font::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Title::Font& Layout::Title::Font::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Title::Font& Layout::Title::Font::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Title::Font& Layout::Title::Font::lineposition(std::string f) {
    json["lineposition"] = std::move(f);
    return *this;
}

Layout::Title::Font& Layout::Title::Font::shadow(std::string f) {
    json["shadow"] = std::move(f);
    return *this;
}

Layout::Title::Font& Layout::Title::Font::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Title::Font& Layout::Title::Font::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Title::Font& Layout::Title::Font::textcase(std::string f) {
    json["textcase"] = std::move(f);
    return *this;
}

Layout::Title::Font& Layout::Title::Font::variant(std::string f) {
    json["variant"] = std::move(f);
    return *this;
}

Layout::Title::Font& Layout::Title::Font::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}


Layout::Title::Pad& Layout::Title::Pad::b(double f) {
    json["b"] = std::move(f);
    return *this;
}

Layout::Title::Pad& Layout::Title::Pad::l(double f) {
    json["l"] = std::move(f);
    return *this;
}

Layout::Title::Pad& Layout::Title::Pad::r(double f) {
    json["r"] = std::move(f);
    return *this;
}

Layout::Title::Pad& Layout::Title::Pad::t(double f) {
    json["t"] = std::move(f);
    return *this;
}


Layout::Title::Subtitle& Layout::Title::Subtitle::font(Font f) {
    json["font"] = std::move(f.json);
    return *this;
}

Layout::Title::Subtitle& Layout::Title::Subtitle::text(std::string f) {
    json["text"] = std::move(f);
    return *this;
}

std::string Layout::Title::Subtitle::Font::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Title::Subtitle::Font& Layout::Title::Subtitle::Font::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Title::Subtitle::Font& Layout::Title::Subtitle::Font::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Title::Subtitle::Font& Layout::Title::Subtitle::Font::lineposition(std::string f) {
    json["lineposition"] = std::move(f);
    return *this;
}

Layout::Title::Subtitle::Font& Layout::Title::Subtitle::Font::shadow(std::string f) {
    json["shadow"] = std::move(f);
    return *this;
}

Layout::Title::Subtitle::Font& Layout::Title::Subtitle::Font::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Title::Subtitle::Font& Layout::Title::Subtitle::Font::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Title::Subtitle::Font& Layout::Title::Subtitle::Font::textcase(std::string f) {
    json["textcase"] = std::move(f);
    return *this;
}

Layout::Title::Subtitle::Font& Layout::Title::Subtitle::Font::variant(std::string f) {
    json["variant"] = std::move(f);
    return *this;
}

Layout::Title::Subtitle::Font& Layout::Title::Subtitle::Font::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}


Layout::Transition& Layout::Transition::duration(double f) {
    json["duration"] = std::move(f);
    return *this;
}

Layout::Transition& Layout::Transition::easing(std::string f) {
    json["easing"] = std::move(f);
    return *this;
}

Layout::Transition& Layout::Transition::ordering(std::string f) {
    json["ordering"] = std::move(f);
    return *this;
}

std::string Layout::Uniformtext::to_string(Mode e) {
    switch(e) {
        case Mode::FALSE: return "False";
        case Mode::HIDE: return "hide";
        case Mode::SHOW: return "show";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Uniformtext& Layout::Uniformtext::minsize(double f) {
    json["minsize"] = std::move(f);
    return *this;
}

Layout::Uniformtext& Layout::Uniformtext::mode(enum Mode f) {
    json["mode"] = to_string(f);
    return *this;
}


Layout::Updatemenus& Layout::Updatemenus::updatemenu(Updatemenu f) {
    json["updatemenu"] = std::move(f.json);
    return *this;
}

std::string Layout::Updatemenus::Updatemenu::to_string(Direction e) {
    switch(e) {
        case Direction::LEFT: return "left";
        case Direction::RIGHT: return "right";
        case Direction::UP: return "up";
        case Direction::DOWN: return "down";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Updatemenus::Updatemenu::to_string(Type e) {
    switch(e) {
        case Type::DROPDOWN: return "dropdown";
        case Type::BUTTONS: return "buttons";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Updatemenus::Updatemenu::to_string(Xanchor e) {
    switch(e) {
        case Xanchor::AUTO: return "auto";
        case Xanchor::LEFT: return "left";
        case Xanchor::CENTER: return "center";
        case Xanchor::RIGHT: return "right";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Updatemenus::Updatemenu::to_string(Yanchor e) {
    switch(e) {
        case Yanchor::AUTO: return "auto";
        case Yanchor::TOP: return "top";
        case Yanchor::MIDDLE: return "middle";
        case Yanchor::BOTTOM: return "bottom";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Updatemenus::Updatemenu& Layout::Updatemenus::Updatemenu::active(int f) {
    json["active"] = std::move(f);
    return *this;
}

Layout::Updatemenus::Updatemenu& Layout::Updatemenus::Updatemenu::bgcolor(std::string f) {
    json["bgcolor"] = std::move(f);
    return *this;
}

Layout::Updatemenus::Updatemenu& Layout::Updatemenus::Updatemenu::bordercolor(std::string f) {
    json["bordercolor"] = std::move(f);
    return *this;
}

Layout::Updatemenus::Updatemenu& Layout::Updatemenus::Updatemenu::borderwidth(double f) {
    json["borderwidth"] = std::move(f);
    return *this;
}

Layout::Updatemenus::Updatemenu& Layout::Updatemenus::Updatemenu::buttons(Buttons f) {
    json["buttons"] = std::move(f.json);
    return *this;
}

Layout::Updatemenus::Updatemenu& Layout::Updatemenus::Updatemenu::direction(enum Direction f) {
    json["direction"] = to_string(f);
    return *this;
}

Layout::Updatemenus::Updatemenu& Layout::Updatemenus::Updatemenu::font(Font f) {
    json["font"] = std::move(f.json);
    return *this;
}

Layout::Updatemenus::Updatemenu& Layout::Updatemenus::Updatemenu::name(std::string f) {
    json["name"] = std::move(f);
    return *this;
}

Layout::Updatemenus::Updatemenu& Layout::Updatemenus::Updatemenu::pad(Pad f) {
    json["pad"] = std::move(f.json);
    return *this;
}

Layout::Updatemenus::Updatemenu& Layout::Updatemenus::Updatemenu::showactive(bool f) {
    json["showactive"] = std::move(f);
    return *this;
}

Layout::Updatemenus::Updatemenu& Layout::Updatemenus::Updatemenu::templateitemname(std::string f) {
    json["templateitemname"] = std::move(f);
    return *this;
}

Layout::Updatemenus::Updatemenu& Layout::Updatemenus::Updatemenu::type(enum Type f) {
    json["type"] = to_string(f);
    return *this;
}

Layout::Updatemenus::Updatemenu& Layout::Updatemenus::Updatemenu::visible(bool f) {
    json["visible"] = std::move(f);
    return *this;
}

Layout::Updatemenus::Updatemenu& Layout::Updatemenus::Updatemenu::x(double f) {
    json["x"] = std::move(f);
    return *this;
}

Layout::Updatemenus::Updatemenu& Layout::Updatemenus::Updatemenu::xanchor(enum Xanchor f) {
    json["xanchor"] = to_string(f);
    return *this;
}

Layout::Updatemenus::Updatemenu& Layout::Updatemenus::Updatemenu::y(double f) {
    json["y"] = std::move(f);
    return *this;
}

Layout::Updatemenus::Updatemenu& Layout::Updatemenus::Updatemenu::yanchor(enum Yanchor f) {
    json["yanchor"] = to_string(f);
    return *this;
}


Layout::Updatemenus::Updatemenu::Buttons& Layout::Updatemenus::Updatemenu::Buttons::button(Button f) {
    json["button"] = std::move(f.json);
    return *this;
}

std::string Layout::Updatemenus::Updatemenu::Buttons::Button::to_string(Method e) {
    switch(e) {
        case Method::RESTYLE: return "restyle";
        case Method::RELAYOUT: return "relayout";
        case Method::ANIMATE: return "animate";
        case Method::UPDATE: return "update";
        case Method::SKIP: return "skip";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Updatemenus::Updatemenu::Buttons::Button& Layout::Updatemenus::Updatemenu::Buttons::Button::args(std::vector<double> f) {
    json["args"] = std::move(f);
    return *this;
}

Layout::Updatemenus::Updatemenu::Buttons::Button& Layout::Updatemenus::Updatemenu::Buttons::Button::args2(std::vector<double> f) {
    json["args2"] = std::move(f);
    return *this;
}

Layout::Updatemenus::Updatemenu::Buttons::Button& Layout::Updatemenus::Updatemenu::Buttons::Button::execute(bool f) {
    json["execute"] = std::move(f);
    return *this;
}

Layout::Updatemenus::Updatemenu::Buttons::Button& Layout::Updatemenus::Updatemenu::Buttons::Button::label(std::string f) {
    json["label"] = std::move(f);
    return *this;
}

Layout::Updatemenus::Updatemenu::Buttons::Button& Layout::Updatemenus::Updatemenu::Buttons::Button::method(enum Method f) {
    json["method"] = to_string(f);
    return *this;
}

Layout::Updatemenus::Updatemenu::Buttons::Button& Layout::Updatemenus::Updatemenu::Buttons::Button::name(std::string f) {
    json["name"] = std::move(f);
    return *this;
}

Layout::Updatemenus::Updatemenu::Buttons::Button& Layout::Updatemenus::Updatemenu::Buttons::Button::templateitemname(std::string f) {
    json["templateitemname"] = std::move(f);
    return *this;
}

Layout::Updatemenus::Updatemenu::Buttons::Button& Layout::Updatemenus::Updatemenu::Buttons::Button::visible(bool f) {
    json["visible"] = std::move(f);
    return *this;
}

std::string Layout::Updatemenus::Updatemenu::Font::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Updatemenus::Updatemenu::Font& Layout::Updatemenus::Updatemenu::Font::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Updatemenus::Updatemenu::Font& Layout::Updatemenus::Updatemenu::Font::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Updatemenus::Updatemenu::Font& Layout::Updatemenus::Updatemenu::Font::lineposition(std::string f) {
    json["lineposition"] = std::move(f);
    return *this;
}

Layout::Updatemenus::Updatemenu::Font& Layout::Updatemenus::Updatemenu::Font::shadow(std::string f) {
    json["shadow"] = std::move(f);
    return *this;
}

Layout::Updatemenus::Updatemenu::Font& Layout::Updatemenus::Updatemenu::Font::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Updatemenus::Updatemenu::Font& Layout::Updatemenus::Updatemenu::Font::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Updatemenus::Updatemenu::Font& Layout::Updatemenus::Updatemenu::Font::textcase(std::string f) {
    json["textcase"] = std::move(f);
    return *this;
}

Layout::Updatemenus::Updatemenu::Font& Layout::Updatemenus::Updatemenu::Font::variant(std::string f) {
    json["variant"] = std::move(f);
    return *this;
}

Layout::Updatemenus::Updatemenu::Font& Layout::Updatemenus::Updatemenu::Font::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}


Layout::Updatemenus::Updatemenu::Pad& Layout::Updatemenus::Updatemenu::Pad::b(double f) {
    json["b"] = std::move(f);
    return *this;
}

Layout::Updatemenus::Updatemenu::Pad& Layout::Updatemenus::Updatemenu::Pad::l(double f) {
    json["l"] = std::move(f);
    return *this;
}

Layout::Updatemenus::Updatemenu::Pad& Layout::Updatemenus::Updatemenu::Pad::r(double f) {
    json["r"] = std::move(f);
    return *this;
}

Layout::Updatemenus::Updatemenu::Pad& Layout::Updatemenus::Updatemenu::Pad::t(double f) {
    json["t"] = std::move(f);
    return *this;
}

std::string Layout::Xaxis::to_string(Calendar e) {
    switch(e) {
        case Calendar::CHINESE: return "chinese";
        case Calendar::COPTIC: return "coptic";
        case Calendar::DISCWORLD: return "discworld";
        case Calendar::ETHIOPIAN: return "ethiopian";
        case Calendar::GREGORIAN: return "gregorian";
        case Calendar::HEBREW: return "hebrew";
        case Calendar::ISLAMIC: return "islamic";
        case Calendar::JALALI: return "jalali";
        case Calendar::JULIAN: return "julian";
        case Calendar::MAYAN: return "mayan";
        case Calendar::NANAKSHAHI: return "nanakshahi";
        case Calendar::NEPALI: return "nepali";
        case Calendar::PERSIAN: return "persian";
        case Calendar::TAIWAN: return "taiwan";
        case Calendar::THAI: return "thai";
        case Calendar::UMMALQURA: return "ummalqura";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Xaxis::to_string(Constrain e) {
    switch(e) {
        case Constrain::RANGE: return "range";
        case Constrain::DOMAIN: return "domain";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Xaxis::to_string(Constraintoward e) {
    switch(e) {
        case Constraintoward::LEFT: return "left";
        case Constraintoward::CENTER: return "center";
        case Constraintoward::RIGHT: return "right";
        case Constraintoward::TOP: return "top";
        case Constraintoward::MIDDLE: return "middle";
        case Constraintoward::BOTTOM: return "bottom";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Xaxis::to_string(Exponentformat e) {
    switch(e) {
        case Exponentformat::NONE: return "none";
        case Exponentformat::E: return "E";
        case Exponentformat::POWER: return "power";
        case Exponentformat::SI: return "SI";
        case Exponentformat::B: return "B";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Xaxis::to_string(Mirror e) {
    switch(e) {
        case Mirror::TRUE: return "True";
        case Mirror::TICKS: return "ticks";
        case Mirror::FALSE: return "False";
        case Mirror::ALL: return "all";
        case Mirror::ALLTICKS: return "allticks";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Xaxis::to_string(Rangemode e) {
    switch(e) {
        case Rangemode::NORMAL: return "normal";
        case Rangemode::TOZERO: return "tozero";
        case Rangemode::NONNEGATIVE: return "nonnegative";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Xaxis::to_string(Showexponent e) {
    switch(e) {
        case Showexponent::ALL: return "all";
        case Showexponent::FIRST: return "first";
        case Showexponent::LAST: return "last";
        case Showexponent::NONE: return "none";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Xaxis::to_string(Showtickprefix e) {
    switch(e) {
        case Showtickprefix::ALL: return "all";
        case Showtickprefix::FIRST: return "first";
        case Showtickprefix::LAST: return "last";
        case Showtickprefix::NONE: return "none";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Xaxis::to_string(Showticksuffix e) {
    switch(e) {
        case Showticksuffix::ALL: return "all";
        case Showticksuffix::FIRST: return "first";
        case Showticksuffix::LAST: return "last";
        case Showticksuffix::NONE: return "none";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Xaxis::to_string(Side e) {
    switch(e) {
        case Side::TOP: return "top";
        case Side::BOTTOM: return "bottom";
        case Side::LEFT: return "left";
        case Side::RIGHT: return "right";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Xaxis::to_string(Ticklabelmode e) {
    switch(e) {
        case Ticklabelmode::INSTANT: return "instant";
        case Ticklabelmode::PERIOD: return "period";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Xaxis::to_string(Tickmode e) {
    switch(e) {
        case Tickmode::AUTO: return "auto";
        case Tickmode::LINEAR: return "linear";
        case Tickmode::ARRAY: return "array";
        case Tickmode::SYNC: return "sync";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Xaxis::to_string(Ticks e) {
    switch(e) {
        case Ticks::OUTSIDE: return "outside";
        case Ticks::INSIDE: return "inside";
        case Ticks::EMPTY: return "";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Xaxis::to_string(Tickson e) {
    switch(e) {
        case Tickson::LABELS: return "labels";
        case Tickson::BOUNDARIES: return "boundaries";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Xaxis& Layout::Xaxis::anchor(std::string f) {
    json["anchor"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::automargin(std::string f) {
    json["automargin"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::autorange(std::string f) {
    json["autorange"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::autorangeoptions(Autorangeoptions f) {
    json["autorangeoptions"] = std::move(f.json);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::autotickangles(std::vector<double> f) {
    json["autotickangles"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::autotypenumbers(std::string f) {
    json["autotypenumbers"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::calendar(enum Calendar f) {
    json["calendar"] = to_string(f);
    return *this;
}

template <typename T, typename>
Layout::Xaxis& Layout::Xaxis::categoryarray(std::vector<T> f) {
    json["categoryarray"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::categoryarraysrc(std::string f) {
    json["categoryarraysrc"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::categoryorder(std::string f) {
    json["categoryorder"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::constrain(enum Constrain f) {
    json["constrain"] = to_string(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::constraintoward(enum Constraintoward f) {
    json["constraintoward"] = to_string(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::dividercolor(std::string f) {
    json["dividercolor"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::dividerwidth(double f) {
    json["dividerwidth"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::domain(std::vector<double> f) {
    json["domain"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Xaxis& Layout::Xaxis::dtick(T f) {
    json["dtick"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::exponentformat(enum Exponentformat f) {
    json["exponentformat"] = to_string(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::fixedrange(bool f) {
    json["fixedrange"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::gridcolor(std::string f) {
    json["gridcolor"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::griddash(std::string f) {
    json["griddash"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::gridwidth(double f) {
    json["gridwidth"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::hoverformat(std::string f) {
    json["hoverformat"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::insiderange(std::vector<double> f) {
    json["insiderange"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Xaxis& Layout::Xaxis::labelalias(T f) {
    json["labelalias"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::layer(std::string f) {
    json["layer"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::linecolor(std::string f) {
    json["linecolor"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::linewidth(double f) {
    json["linewidth"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::matches(std::string f) {
    json["matches"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Xaxis& Layout::Xaxis::maxallowed(T f) {
    json["maxallowed"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Xaxis& Layout::Xaxis::minallowed(T f) {
    json["minallowed"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::minexponent(double f) {
    json["minexponent"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::minor(Minor f) {
    json["minor"] = std::move(f.json);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::mirror(enum Mirror f) {
    json["mirror"] = to_string(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::nticks(int f) {
    json["nticks"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::overlaying(std::string f) {
    json["overlaying"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::position(double f) {
    json["position"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::range(std::vector<double> f) {
    json["range"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::rangebreaks(Rangebreaks f) {
    json["rangebreaks"] = std::move(f.json);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::rangemode(enum Rangemode f) {
    json["rangemode"] = to_string(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::rangeselector(Rangeselector f) {
    json["rangeselector"] = std::move(f.json);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::rangeslider(Rangeslider f) {
    json["rangeslider"] = std::move(f.json);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::scaleanchor(std::string f) {
    json["scaleanchor"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::scaleratio(double f) {
    json["scaleratio"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::separatethousands(bool f) {
    json["separatethousands"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::showdividers(bool f) {
    json["showdividers"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::showexponent(enum Showexponent f) {
    json["showexponent"] = to_string(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::showgrid(bool f) {
    json["showgrid"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::showline(bool f) {
    json["showline"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::showspikes(bool f) {
    json["showspikes"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::showticklabels(bool f) {
    json["showticklabels"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::showtickprefix(enum Showtickprefix f) {
    json["showtickprefix"] = to_string(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::showticksuffix(enum Showticksuffix f) {
    json["showticksuffix"] = to_string(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::side(enum Side f) {
    json["side"] = to_string(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::spikecolor(std::string f) {
    json["spikecolor"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::spikedash(std::string f) {
    json["spikedash"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::spikemode(std::string f) {
    json["spikemode"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::spikesnap(std::string f) {
    json["spikesnap"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::spikethickness(double f) {
    json["spikethickness"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Xaxis& Layout::Xaxis::tick0(T f) {
    json["tick0"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::tickangle(double f) {
    json["tickangle"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::tickcolor(std::string f) {
    json["tickcolor"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::tickfont(Tickfont f) {
    json["tickfont"] = std::move(f.json);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::tickformat(std::string f) {
    json["tickformat"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::tickformatstops(Tickformatstops f) {
    json["tickformatstops"] = std::move(f.json);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::ticklabelindex(int f) {
    json["ticklabelindex"] = std::move(f);
    return *this;
}
Layout::Xaxis& Layout::Xaxis::ticklabelindex(std::vector<int> f) {
    json["ticklabelindex"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::ticklabelindexsrc(std::string f) {
    json["ticklabelindexsrc"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::ticklabelmode(enum Ticklabelmode f) {
    json["ticklabelmode"] = to_string(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::ticklabeloverflow(std::string f) {
    json["ticklabeloverflow"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::ticklabelposition(std::string f) {
    json["ticklabelposition"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::ticklabelshift(int f) {
    json["ticklabelshift"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::ticklabelstandoff(int f) {
    json["ticklabelstandoff"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::ticklabelstep(int f) {
    json["ticklabelstep"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::ticklen(double f) {
    json["ticklen"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::tickmode(enum Tickmode f) {
    json["tickmode"] = to_string(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::tickprefix(std::string f) {
    json["tickprefix"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::ticks(enum Ticks f) {
    json["ticks"] = to_string(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::tickson(enum Tickson f) {
    json["tickson"] = to_string(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::ticksuffix(std::string f) {
    json["ticksuffix"] = std::move(f);
    return *this;
}

template <typename T, typename>
Layout::Xaxis& Layout::Xaxis::ticktext(std::vector<T> f) {
    json["ticktext"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::ticktextsrc(std::string f) {
    json["ticktextsrc"] = std::move(f);
    return *this;
}

template <typename T, typename>
Layout::Xaxis& Layout::Xaxis::tickvals(std::vector<T> f) {
    json["tickvals"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::tickvalssrc(std::string f) {
    json["tickvalssrc"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::tickwidth(double f) {
    json["tickwidth"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::title(Title f) {
    json["title"] = std::move(f.json);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::type(std::string f) {
    json["type"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Xaxis& Layout::Xaxis::uirevision(T f) {
    json["uirevision"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::visible(bool f) {
    json["visible"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::zeroline(bool f) {
    json["zeroline"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::zerolinecolor(std::string f) {
    json["zerolinecolor"] = std::move(f);
    return *this;
}

Layout::Xaxis& Layout::Xaxis::zerolinewidth(double f) {
    json["zerolinewidth"] = std::move(f);
    return *this;
}


template <typename T>
Layout::Xaxis::Autorangeoptions& Layout::Xaxis::Autorangeoptions::clipmax(T f) {
    json["clipmax"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Xaxis::Autorangeoptions& Layout::Xaxis::Autorangeoptions::clipmin(T f) {
    json["clipmin"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Xaxis::Autorangeoptions& Layout::Xaxis::Autorangeoptions::include(T f) {
    json["include"] = std::move(f);
    return *this;
}
template <typename T>
Layout::Xaxis::Autorangeoptions& Layout::Xaxis::Autorangeoptions::include(std::vector<T> f) {
    json["include"] = std::move(f);
    return *this;
}

Layout::Xaxis::Autorangeoptions& Layout::Xaxis::Autorangeoptions::includesrc(std::string f) {
    json["includesrc"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Xaxis::Autorangeoptions& Layout::Xaxis::Autorangeoptions::maxallowed(T f) {
    json["maxallowed"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Xaxis::Autorangeoptions& Layout::Xaxis::Autorangeoptions::minallowed(T f) {
    json["minallowed"] = std::move(f);
    return *this;
}

std::string Layout::Xaxis::Minor::to_string(Tickmode e) {
    switch(e) {
        case Tickmode::AUTO: return "auto";
        case Tickmode::LINEAR: return "linear";
        case Tickmode::ARRAY: return "array";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Xaxis::Minor::to_string(Ticks e) {
    switch(e) {
        case Ticks::OUTSIDE: return "outside";
        case Ticks::INSIDE: return "inside";
        case Ticks::EMPTY: return "";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

template <typename T>
Layout::Xaxis::Minor& Layout::Xaxis::Minor::dtick(T f) {
    json["dtick"] = std::move(f);
    return *this;
}

Layout::Xaxis::Minor& Layout::Xaxis::Minor::gridcolor(std::string f) {
    json["gridcolor"] = std::move(f);
    return *this;
}

Layout::Xaxis::Minor& Layout::Xaxis::Minor::griddash(std::string f) {
    json["griddash"] = std::move(f);
    return *this;
}

Layout::Xaxis::Minor& Layout::Xaxis::Minor::gridwidth(double f) {
    json["gridwidth"] = std::move(f);
    return *this;
}

Layout::Xaxis::Minor& Layout::Xaxis::Minor::nticks(int f) {
    json["nticks"] = std::move(f);
    return *this;
}

Layout::Xaxis::Minor& Layout::Xaxis::Minor::showgrid(bool f) {
    json["showgrid"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Xaxis::Minor& Layout::Xaxis::Minor::tick0(T f) {
    json["tick0"] = std::move(f);
    return *this;
}

Layout::Xaxis::Minor& Layout::Xaxis::Minor::tickcolor(std::string f) {
    json["tickcolor"] = std::move(f);
    return *this;
}

Layout::Xaxis::Minor& Layout::Xaxis::Minor::ticklen(double f) {
    json["ticklen"] = std::move(f);
    return *this;
}

Layout::Xaxis::Minor& Layout::Xaxis::Minor::tickmode(enum Tickmode f) {
    json["tickmode"] = to_string(f);
    return *this;
}

Layout::Xaxis::Minor& Layout::Xaxis::Minor::ticks(enum Ticks f) {
    json["ticks"] = to_string(f);
    return *this;
}

template <typename T, typename>
Layout::Xaxis::Minor& Layout::Xaxis::Minor::tickvals(std::vector<T> f) {
    json["tickvals"] = std::move(f);
    return *this;
}

Layout::Xaxis::Minor& Layout::Xaxis::Minor::tickvalssrc(std::string f) {
    json["tickvalssrc"] = std::move(f);
    return *this;
}

Layout::Xaxis::Minor& Layout::Xaxis::Minor::tickwidth(double f) {
    json["tickwidth"] = std::move(f);
    return *this;
}


Layout::Xaxis::Rangebreaks& Layout::Xaxis::Rangebreaks::rangebreak(Rangebreak f) {
    json["rangebreak"] = std::move(f.json);
    return *this;
}


Layout::Xaxis::Rangebreaks::Rangebreak& Layout::Xaxis::Rangebreaks::Rangebreak::bounds(std::vector<double> f) {
    json["bounds"] = std::move(f);
    return *this;
}

Layout::Xaxis::Rangebreaks::Rangebreak& Layout::Xaxis::Rangebreaks::Rangebreak::dvalue(double f) {
    json["dvalue"] = std::move(f);
    return *this;
}

Layout::Xaxis::Rangebreaks::Rangebreak& Layout::Xaxis::Rangebreaks::Rangebreak::enabled(bool f) {
    json["enabled"] = std::move(f);
    return *this;
}

Layout::Xaxis::Rangebreaks::Rangebreak& Layout::Xaxis::Rangebreaks::Rangebreak::name(std::string f) {
    json["name"] = std::move(f);
    return *this;
}

Layout::Xaxis::Rangebreaks::Rangebreak& Layout::Xaxis::Rangebreaks::Rangebreak::pattern(std::string f) {
    json["pattern"] = std::move(f);
    return *this;
}

Layout::Xaxis::Rangebreaks::Rangebreak& Layout::Xaxis::Rangebreaks::Rangebreak::templateitemname(std::string f) {
    json["templateitemname"] = std::move(f);
    return *this;
}

Layout::Xaxis::Rangebreaks::Rangebreak& Layout::Xaxis::Rangebreaks::Rangebreak::values(std::vector<double> f) {
    json["values"] = std::move(f);
    return *this;
}

std::string Layout::Xaxis::Rangeselector::to_string(Xanchor e) {
    switch(e) {
        case Xanchor::AUTO: return "auto";
        case Xanchor::LEFT: return "left";
        case Xanchor::CENTER: return "center";
        case Xanchor::RIGHT: return "right";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Xaxis::Rangeselector::to_string(Yanchor e) {
    switch(e) {
        case Yanchor::AUTO: return "auto";
        case Yanchor::TOP: return "top";
        case Yanchor::MIDDLE: return "middle";
        case Yanchor::BOTTOM: return "bottom";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Xaxis::Rangeselector& Layout::Xaxis::Rangeselector::activecolor(std::string f) {
    json["activecolor"] = std::move(f);
    return *this;
}

Layout::Xaxis::Rangeselector& Layout::Xaxis::Rangeselector::bgcolor(std::string f) {
    json["bgcolor"] = std::move(f);
    return *this;
}

Layout::Xaxis::Rangeselector& Layout::Xaxis::Rangeselector::bordercolor(std::string f) {
    json["bordercolor"] = std::move(f);
    return *this;
}

Layout::Xaxis::Rangeselector& Layout::Xaxis::Rangeselector::borderwidth(double f) {
    json["borderwidth"] = std::move(f);
    return *this;
}

Layout::Xaxis::Rangeselector& Layout::Xaxis::Rangeselector::buttons(Buttons f) {
    json["buttons"] = std::move(f.json);
    return *this;
}

Layout::Xaxis::Rangeselector& Layout::Xaxis::Rangeselector::font(Font f) {
    json["font"] = std::move(f.json);
    return *this;
}

Layout::Xaxis::Rangeselector& Layout::Xaxis::Rangeselector::visible(bool f) {
    json["visible"] = std::move(f);
    return *this;
}

Layout::Xaxis::Rangeselector& Layout::Xaxis::Rangeselector::x(double f) {
    json["x"] = std::move(f);
    return *this;
}

Layout::Xaxis::Rangeselector& Layout::Xaxis::Rangeselector::xanchor(enum Xanchor f) {
    json["xanchor"] = to_string(f);
    return *this;
}

Layout::Xaxis::Rangeselector& Layout::Xaxis::Rangeselector::y(double f) {
    json["y"] = std::move(f);
    return *this;
}

Layout::Xaxis::Rangeselector& Layout::Xaxis::Rangeselector::yanchor(enum Yanchor f) {
    json["yanchor"] = to_string(f);
    return *this;
}


Layout::Xaxis::Rangeselector::Buttons& Layout::Xaxis::Rangeselector::Buttons::button(Button f) {
    json["button"] = std::move(f.json);
    return *this;
}

std::string Layout::Xaxis::Rangeselector::Buttons::Button::to_string(Step e) {
    switch(e) {
        case Step::MONTH: return "month";
        case Step::YEAR: return "year";
        case Step::DAY: return "day";
        case Step::HOUR: return "hour";
        case Step::MINUTE: return "minute";
        case Step::SECOND: return "second";
        case Step::ALL: return "all";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Xaxis::Rangeselector::Buttons::Button::to_string(Stepmode e) {
    switch(e) {
        case Stepmode::BACKWARD: return "backward";
        case Stepmode::TODATE: return "todate";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Xaxis::Rangeselector::Buttons::Button& Layout::Xaxis::Rangeselector::Buttons::Button::count(double f) {
    json["count"] = std::move(f);
    return *this;
}

Layout::Xaxis::Rangeselector::Buttons::Button& Layout::Xaxis::Rangeselector::Buttons::Button::label(std::string f) {
    json["label"] = std::move(f);
    return *this;
}

Layout::Xaxis::Rangeselector::Buttons::Button& Layout::Xaxis::Rangeselector::Buttons::Button::name(std::string f) {
    json["name"] = std::move(f);
    return *this;
}

Layout::Xaxis::Rangeselector::Buttons::Button& Layout::Xaxis::Rangeselector::Buttons::Button::step(enum Step f) {
    json["step"] = to_string(f);
    return *this;
}

Layout::Xaxis::Rangeselector::Buttons::Button& Layout::Xaxis::Rangeselector::Buttons::Button::stepmode(enum Stepmode f) {
    json["stepmode"] = to_string(f);
    return *this;
}

Layout::Xaxis::Rangeselector::Buttons::Button& Layout::Xaxis::Rangeselector::Buttons::Button::templateitemname(std::string f) {
    json["templateitemname"] = std::move(f);
    return *this;
}

Layout::Xaxis::Rangeselector::Buttons::Button& Layout::Xaxis::Rangeselector::Buttons::Button::visible(bool f) {
    json["visible"] = std::move(f);
    return *this;
}

std::string Layout::Xaxis::Rangeselector::Font::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Xaxis::Rangeselector::Font& Layout::Xaxis::Rangeselector::Font::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Xaxis::Rangeselector::Font& Layout::Xaxis::Rangeselector::Font::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Xaxis::Rangeselector::Font& Layout::Xaxis::Rangeselector::Font::lineposition(std::string f) {
    json["lineposition"] = std::move(f);
    return *this;
}

Layout::Xaxis::Rangeselector::Font& Layout::Xaxis::Rangeselector::Font::shadow(std::string f) {
    json["shadow"] = std::move(f);
    return *this;
}

Layout::Xaxis::Rangeselector::Font& Layout::Xaxis::Rangeselector::Font::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Xaxis::Rangeselector::Font& Layout::Xaxis::Rangeselector::Font::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Xaxis::Rangeselector::Font& Layout::Xaxis::Rangeselector::Font::textcase(std::string f) {
    json["textcase"] = std::move(f);
    return *this;
}

Layout::Xaxis::Rangeselector::Font& Layout::Xaxis::Rangeselector::Font::variant(std::string f) {
    json["variant"] = std::move(f);
    return *this;
}

Layout::Xaxis::Rangeselector::Font& Layout::Xaxis::Rangeselector::Font::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}


Layout::Xaxis::Rangeslider& Layout::Xaxis::Rangeslider::autorange(bool f) {
    json["autorange"] = std::move(f);
    return *this;
}

Layout::Xaxis::Rangeslider& Layout::Xaxis::Rangeslider::bgcolor(std::string f) {
    json["bgcolor"] = std::move(f);
    return *this;
}

Layout::Xaxis::Rangeslider& Layout::Xaxis::Rangeslider::bordercolor(std::string f) {
    json["bordercolor"] = std::move(f);
    return *this;
}

Layout::Xaxis::Rangeslider& Layout::Xaxis::Rangeslider::borderwidth(int f) {
    json["borderwidth"] = std::move(f);
    return *this;
}

Layout::Xaxis::Rangeslider& Layout::Xaxis::Rangeslider::range(std::vector<double> f) {
    json["range"] = std::move(f);
    return *this;
}

Layout::Xaxis::Rangeslider& Layout::Xaxis::Rangeslider::thickness(double f) {
    json["thickness"] = std::move(f);
    return *this;
}

Layout::Xaxis::Rangeslider& Layout::Xaxis::Rangeslider::visible(bool f) {
    json["visible"] = std::move(f);
    return *this;
}

Layout::Xaxis::Rangeslider& Layout::Xaxis::Rangeslider::yaxis(Yaxis f) {
    json["yaxis"] = std::move(f.json);
    return *this;
}

std::string Layout::Xaxis::Rangeslider::Yaxis::to_string(Rangemode e) {
    switch(e) {
        case Rangemode::AUTO: return "auto";
        case Rangemode::FIXED: return "fixed";
        case Rangemode::MATCH: return "match";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Xaxis::Rangeslider::Yaxis& Layout::Xaxis::Rangeslider::Yaxis::range(std::vector<double> f) {
    json["range"] = std::move(f);
    return *this;
}

Layout::Xaxis::Rangeslider::Yaxis& Layout::Xaxis::Rangeslider::Yaxis::rangemode(enum Rangemode f) {
    json["rangemode"] = to_string(f);
    return *this;
}

std::string Layout::Xaxis::Tickfont::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Xaxis::Tickfont& Layout::Xaxis::Tickfont::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Xaxis::Tickfont& Layout::Xaxis::Tickfont::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Xaxis::Tickfont& Layout::Xaxis::Tickfont::lineposition(std::string f) {
    json["lineposition"] = std::move(f);
    return *this;
}

Layout::Xaxis::Tickfont& Layout::Xaxis::Tickfont::shadow(std::string f) {
    json["shadow"] = std::move(f);
    return *this;
}

Layout::Xaxis::Tickfont& Layout::Xaxis::Tickfont::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Xaxis::Tickfont& Layout::Xaxis::Tickfont::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Xaxis::Tickfont& Layout::Xaxis::Tickfont::textcase(std::string f) {
    json["textcase"] = std::move(f);
    return *this;
}

Layout::Xaxis::Tickfont& Layout::Xaxis::Tickfont::variant(std::string f) {
    json["variant"] = std::move(f);
    return *this;
}

Layout::Xaxis::Tickfont& Layout::Xaxis::Tickfont::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}


Layout::Xaxis::Tickformatstops& Layout::Xaxis::Tickformatstops::tickformatstop(Tickformatstop f) {
    json["tickformatstop"] = std::move(f.json);
    return *this;
}


Layout::Xaxis::Tickformatstops::Tickformatstop& Layout::Xaxis::Tickformatstops::Tickformatstop::dtickrange(std::vector<double> f) {
    json["dtickrange"] = std::move(f);
    return *this;
}

Layout::Xaxis::Tickformatstops::Tickformatstop& Layout::Xaxis::Tickformatstops::Tickformatstop::enabled(bool f) {
    json["enabled"] = std::move(f);
    return *this;
}

Layout::Xaxis::Tickformatstops::Tickformatstop& Layout::Xaxis::Tickformatstops::Tickformatstop::name(std::string f) {
    json["name"] = std::move(f);
    return *this;
}

Layout::Xaxis::Tickformatstops::Tickformatstop& Layout::Xaxis::Tickformatstops::Tickformatstop::templateitemname(std::string f) {
    json["templateitemname"] = std::move(f);
    return *this;
}

Layout::Xaxis::Tickformatstops::Tickformatstop& Layout::Xaxis::Tickformatstops::Tickformatstop::value(std::string f) {
    json["value"] = std::move(f);
    return *this;
}


Layout::Xaxis::Title& Layout::Xaxis::Title::font(Font f) {
    json["font"] = std::move(f.json);
    return *this;
}

Layout::Xaxis::Title& Layout::Xaxis::Title::standoff(double f) {
    json["standoff"] = std::move(f);
    return *this;
}

Layout::Xaxis::Title& Layout::Xaxis::Title::text(std::string f) {
    json["text"] = std::move(f);
    return *this;
}

std::string Layout::Xaxis::Title::Font::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Xaxis::Title::Font& Layout::Xaxis::Title::Font::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Xaxis::Title::Font& Layout::Xaxis::Title::Font::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Xaxis::Title::Font& Layout::Xaxis::Title::Font::lineposition(std::string f) {
    json["lineposition"] = std::move(f);
    return *this;
}

Layout::Xaxis::Title::Font& Layout::Xaxis::Title::Font::shadow(std::string f) {
    json["shadow"] = std::move(f);
    return *this;
}

Layout::Xaxis::Title::Font& Layout::Xaxis::Title::Font::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Xaxis::Title::Font& Layout::Xaxis::Title::Font::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Xaxis::Title::Font& Layout::Xaxis::Title::Font::textcase(std::string f) {
    json["textcase"] = std::move(f);
    return *this;
}

Layout::Xaxis::Title::Font& Layout::Xaxis::Title::Font::variant(std::string f) {
    json["variant"] = std::move(f);
    return *this;
}

Layout::Xaxis::Title::Font& Layout::Xaxis::Title::Font::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}

std::string Layout::Yaxis::to_string(Calendar e) {
    switch(e) {
        case Calendar::CHINESE: return "chinese";
        case Calendar::COPTIC: return "coptic";
        case Calendar::DISCWORLD: return "discworld";
        case Calendar::ETHIOPIAN: return "ethiopian";
        case Calendar::GREGORIAN: return "gregorian";
        case Calendar::HEBREW: return "hebrew";
        case Calendar::ISLAMIC: return "islamic";
        case Calendar::JALALI: return "jalali";
        case Calendar::JULIAN: return "julian";
        case Calendar::MAYAN: return "mayan";
        case Calendar::NANAKSHAHI: return "nanakshahi";
        case Calendar::NEPALI: return "nepali";
        case Calendar::PERSIAN: return "persian";
        case Calendar::TAIWAN: return "taiwan";
        case Calendar::THAI: return "thai";
        case Calendar::UMMALQURA: return "ummalqura";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Yaxis::to_string(Constrain e) {
    switch(e) {
        case Constrain::RANGE: return "range";
        case Constrain::DOMAIN: return "domain";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Yaxis::to_string(Constraintoward e) {
    switch(e) {
        case Constraintoward::LEFT: return "left";
        case Constraintoward::CENTER: return "center";
        case Constraintoward::RIGHT: return "right";
        case Constraintoward::TOP: return "top";
        case Constraintoward::MIDDLE: return "middle";
        case Constraintoward::BOTTOM: return "bottom";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Yaxis::to_string(Exponentformat e) {
    switch(e) {
        case Exponentformat::NONE: return "none";
        case Exponentformat::E: return "E";
        case Exponentformat::POWER: return "power";
        case Exponentformat::SI: return "SI";
        case Exponentformat::B: return "B";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Yaxis::to_string(Mirror e) {
    switch(e) {
        case Mirror::TRUE: return "True";
        case Mirror::TICKS: return "ticks";
        case Mirror::FALSE: return "False";
        case Mirror::ALL: return "all";
        case Mirror::ALLTICKS: return "allticks";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Yaxis::to_string(Rangemode e) {
    switch(e) {
        case Rangemode::NORMAL: return "normal";
        case Rangemode::TOZERO: return "tozero";
        case Rangemode::NONNEGATIVE: return "nonnegative";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Yaxis::to_string(Showexponent e) {
    switch(e) {
        case Showexponent::ALL: return "all";
        case Showexponent::FIRST: return "first";
        case Showexponent::LAST: return "last";
        case Showexponent::NONE: return "none";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Yaxis::to_string(Showtickprefix e) {
    switch(e) {
        case Showtickprefix::ALL: return "all";
        case Showtickprefix::FIRST: return "first";
        case Showtickprefix::LAST: return "last";
        case Showtickprefix::NONE: return "none";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Yaxis::to_string(Showticksuffix e) {
    switch(e) {
        case Showticksuffix::ALL: return "all";
        case Showticksuffix::FIRST: return "first";
        case Showticksuffix::LAST: return "last";
        case Showticksuffix::NONE: return "none";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Yaxis::to_string(Side e) {
    switch(e) {
        case Side::TOP: return "top";
        case Side::BOTTOM: return "bottom";
        case Side::LEFT: return "left";
        case Side::RIGHT: return "right";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Yaxis::to_string(Ticklabelmode e) {
    switch(e) {
        case Ticklabelmode::INSTANT: return "instant";
        case Ticklabelmode::PERIOD: return "period";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Yaxis::to_string(Tickmode e) {
    switch(e) {
        case Tickmode::AUTO: return "auto";
        case Tickmode::LINEAR: return "linear";
        case Tickmode::ARRAY: return "array";
        case Tickmode::SYNC: return "sync";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Yaxis::to_string(Ticks e) {
    switch(e) {
        case Ticks::OUTSIDE: return "outside";
        case Ticks::INSIDE: return "inside";
        case Ticks::EMPTY: return "";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Yaxis::to_string(Tickson e) {
    switch(e) {
        case Tickson::LABELS: return "labels";
        case Tickson::BOUNDARIES: return "boundaries";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Yaxis& Layout::Yaxis::anchor(std::string f) {
    json["anchor"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::automargin(std::string f) {
    json["automargin"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::autorange(std::string f) {
    json["autorange"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::autorangeoptions(Autorangeoptions f) {
    json["autorangeoptions"] = std::move(f.json);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::autoshift(bool f) {
    json["autoshift"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::autotickangles(std::vector<double> f) {
    json["autotickangles"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::autotypenumbers(std::string f) {
    json["autotypenumbers"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::calendar(enum Calendar f) {
    json["calendar"] = to_string(f);
    return *this;
}

template <typename T, typename>
Layout::Yaxis& Layout::Yaxis::categoryarray(std::vector<T> f) {
    json["categoryarray"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::categoryarraysrc(std::string f) {
    json["categoryarraysrc"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::categoryorder(std::string f) {
    json["categoryorder"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::constrain(enum Constrain f) {
    json["constrain"] = to_string(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::constraintoward(enum Constraintoward f) {
    json["constraintoward"] = to_string(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::dividercolor(std::string f) {
    json["dividercolor"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::dividerwidth(double f) {
    json["dividerwidth"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::domain(std::vector<double> f) {
    json["domain"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Yaxis& Layout::Yaxis::dtick(T f) {
    json["dtick"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::exponentformat(enum Exponentformat f) {
    json["exponentformat"] = to_string(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::fixedrange(bool f) {
    json["fixedrange"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::gridcolor(std::string f) {
    json["gridcolor"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::griddash(std::string f) {
    json["griddash"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::gridwidth(double f) {
    json["gridwidth"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::hoverformat(std::string f) {
    json["hoverformat"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::insiderange(std::vector<double> f) {
    json["insiderange"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Yaxis& Layout::Yaxis::labelalias(T f) {
    json["labelalias"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::layer(std::string f) {
    json["layer"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::linecolor(std::string f) {
    json["linecolor"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::linewidth(double f) {
    json["linewidth"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::matches(std::string f) {
    json["matches"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Yaxis& Layout::Yaxis::maxallowed(T f) {
    json["maxallowed"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Yaxis& Layout::Yaxis::minallowed(T f) {
    json["minallowed"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::minexponent(double f) {
    json["minexponent"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::minor(Minor f) {
    json["minor"] = std::move(f.json);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::mirror(enum Mirror f) {
    json["mirror"] = to_string(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::nticks(int f) {
    json["nticks"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::overlaying(std::string f) {
    json["overlaying"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::position(double f) {
    json["position"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::range(std::vector<double> f) {
    json["range"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::rangebreaks(Rangebreaks f) {
    json["rangebreaks"] = std::move(f.json);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::rangemode(enum Rangemode f) {
    json["rangemode"] = to_string(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::scaleanchor(std::string f) {
    json["scaleanchor"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::scaleratio(double f) {
    json["scaleratio"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::separatethousands(bool f) {
    json["separatethousands"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::shift(double f) {
    json["shift"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::showdividers(bool f) {
    json["showdividers"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::showexponent(enum Showexponent f) {
    json["showexponent"] = to_string(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::showgrid(bool f) {
    json["showgrid"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::showline(bool f) {
    json["showline"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::showspikes(bool f) {
    json["showspikes"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::showticklabels(bool f) {
    json["showticklabels"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::showtickprefix(enum Showtickprefix f) {
    json["showtickprefix"] = to_string(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::showticksuffix(enum Showticksuffix f) {
    json["showticksuffix"] = to_string(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::side(enum Side f) {
    json["side"] = to_string(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::spikecolor(std::string f) {
    json["spikecolor"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::spikedash(std::string f) {
    json["spikedash"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::spikemode(std::string f) {
    json["spikemode"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::spikesnap(std::string f) {
    json["spikesnap"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::spikethickness(double f) {
    json["spikethickness"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Yaxis& Layout::Yaxis::tick0(T f) {
    json["tick0"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::tickangle(double f) {
    json["tickangle"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::tickcolor(std::string f) {
    json["tickcolor"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::tickfont(Tickfont f) {
    json["tickfont"] = std::move(f.json);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::tickformat(std::string f) {
    json["tickformat"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::tickformatstops(Tickformatstops f) {
    json["tickformatstops"] = std::move(f.json);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::ticklabelindex(int f) {
    json["ticklabelindex"] = std::move(f);
    return *this;
}
Layout::Yaxis& Layout::Yaxis::ticklabelindex(std::vector<int> f) {
    json["ticklabelindex"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::ticklabelindexsrc(std::string f) {
    json["ticklabelindexsrc"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::ticklabelmode(enum Ticklabelmode f) {
    json["ticklabelmode"] = to_string(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::ticklabeloverflow(std::string f) {
    json["ticklabeloverflow"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::ticklabelposition(std::string f) {
    json["ticklabelposition"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::ticklabelshift(int f) {
    json["ticklabelshift"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::ticklabelstandoff(int f) {
    json["ticklabelstandoff"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::ticklabelstep(int f) {
    json["ticklabelstep"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::ticklen(double f) {
    json["ticklen"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::tickmode(enum Tickmode f) {
    json["tickmode"] = to_string(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::tickprefix(std::string f) {
    json["tickprefix"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::ticks(enum Ticks f) {
    json["ticks"] = to_string(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::tickson(enum Tickson f) {
    json["tickson"] = to_string(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::ticksuffix(std::string f) {
    json["ticksuffix"] = std::move(f);
    return *this;
}

template <typename T, typename>
Layout::Yaxis& Layout::Yaxis::ticktext(std::vector<T> f) {
    json["ticktext"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::ticktextsrc(std::string f) {
    json["ticktextsrc"] = std::move(f);
    return *this;
}

template <typename T, typename>
Layout::Yaxis& Layout::Yaxis::tickvals(std::vector<T> f) {
    json["tickvals"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::tickvalssrc(std::string f) {
    json["tickvalssrc"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::tickwidth(double f) {
    json["tickwidth"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::title(Title f) {
    json["title"] = std::move(f.json);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::type(std::string f) {
    json["type"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Yaxis& Layout::Yaxis::uirevision(T f) {
    json["uirevision"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::visible(bool f) {
    json["visible"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::zeroline(bool f) {
    json["zeroline"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::zerolinecolor(std::string f) {
    json["zerolinecolor"] = std::move(f);
    return *this;
}

Layout::Yaxis& Layout::Yaxis::zerolinewidth(double f) {
    json["zerolinewidth"] = std::move(f);
    return *this;
}


template <typename T>
Layout::Yaxis::Autorangeoptions& Layout::Yaxis::Autorangeoptions::clipmax(T f) {
    json["clipmax"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Yaxis::Autorangeoptions& Layout::Yaxis::Autorangeoptions::clipmin(T f) {
    json["clipmin"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Yaxis::Autorangeoptions& Layout::Yaxis::Autorangeoptions::include(T f) {
    json["include"] = std::move(f);
    return *this;
}
template <typename T>
Layout::Yaxis::Autorangeoptions& Layout::Yaxis::Autorangeoptions::include(std::vector<T> f) {
    json["include"] = std::move(f);
    return *this;
}

Layout::Yaxis::Autorangeoptions& Layout::Yaxis::Autorangeoptions::includesrc(std::string f) {
    json["includesrc"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Yaxis::Autorangeoptions& Layout::Yaxis::Autorangeoptions::maxallowed(T f) {
    json["maxallowed"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Yaxis::Autorangeoptions& Layout::Yaxis::Autorangeoptions::minallowed(T f) {
    json["minallowed"] = std::move(f);
    return *this;
}

std::string Layout::Yaxis::Minor::to_string(Tickmode e) {
    switch(e) {
        case Tickmode::AUTO: return "auto";
        case Tickmode::LINEAR: return "linear";
        case Tickmode::ARRAY: return "array";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}
std::string Layout::Yaxis::Minor::to_string(Ticks e) {
    switch(e) {
        case Ticks::OUTSIDE: return "outside";
        case Ticks::INSIDE: return "inside";
        case Ticks::EMPTY: return "";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

template <typename T>
Layout::Yaxis::Minor& Layout::Yaxis::Minor::dtick(T f) {
    json["dtick"] = std::move(f);
    return *this;
}

Layout::Yaxis::Minor& Layout::Yaxis::Minor::gridcolor(std::string f) {
    json["gridcolor"] = std::move(f);
    return *this;
}

Layout::Yaxis::Minor& Layout::Yaxis::Minor::griddash(std::string f) {
    json["griddash"] = std::move(f);
    return *this;
}

Layout::Yaxis::Minor& Layout::Yaxis::Minor::gridwidth(double f) {
    json["gridwidth"] = std::move(f);
    return *this;
}

Layout::Yaxis::Minor& Layout::Yaxis::Minor::nticks(int f) {
    json["nticks"] = std::move(f);
    return *this;
}

Layout::Yaxis::Minor& Layout::Yaxis::Minor::showgrid(bool f) {
    json["showgrid"] = std::move(f);
    return *this;
}

template <typename T>
Layout::Yaxis::Minor& Layout::Yaxis::Minor::tick0(T f) {
    json["tick0"] = std::move(f);
    return *this;
}

Layout::Yaxis::Minor& Layout::Yaxis::Minor::tickcolor(std::string f) {
    json["tickcolor"] = std::move(f);
    return *this;
}

Layout::Yaxis::Minor& Layout::Yaxis::Minor::ticklen(double f) {
    json["ticklen"] = std::move(f);
    return *this;
}

Layout::Yaxis::Minor& Layout::Yaxis::Minor::tickmode(enum Tickmode f) {
    json["tickmode"] = to_string(f);
    return *this;
}

Layout::Yaxis::Minor& Layout::Yaxis::Minor::ticks(enum Ticks f) {
    json["ticks"] = to_string(f);
    return *this;
}

template <typename T, typename>
Layout::Yaxis::Minor& Layout::Yaxis::Minor::tickvals(std::vector<T> f) {
    json["tickvals"] = std::move(f);
    return *this;
}

Layout::Yaxis::Minor& Layout::Yaxis::Minor::tickvalssrc(std::string f) {
    json["tickvalssrc"] = std::move(f);
    return *this;
}

Layout::Yaxis::Minor& Layout::Yaxis::Minor::tickwidth(double f) {
    json["tickwidth"] = std::move(f);
    return *this;
}


Layout::Yaxis::Rangebreaks& Layout::Yaxis::Rangebreaks::rangebreak(Rangebreak f) {
    json["rangebreak"] = std::move(f.json);
    return *this;
}


Layout::Yaxis::Rangebreaks::Rangebreak& Layout::Yaxis::Rangebreaks::Rangebreak::bounds(std::vector<double> f) {
    json["bounds"] = std::move(f);
    return *this;
}

Layout::Yaxis::Rangebreaks::Rangebreak& Layout::Yaxis::Rangebreaks::Rangebreak::dvalue(double f) {
    json["dvalue"] = std::move(f);
    return *this;
}

Layout::Yaxis::Rangebreaks::Rangebreak& Layout::Yaxis::Rangebreaks::Rangebreak::enabled(bool f) {
    json["enabled"] = std::move(f);
    return *this;
}

Layout::Yaxis::Rangebreaks::Rangebreak& Layout::Yaxis::Rangebreaks::Rangebreak::name(std::string f) {
    json["name"] = std::move(f);
    return *this;
}

Layout::Yaxis::Rangebreaks::Rangebreak& Layout::Yaxis::Rangebreaks::Rangebreak::pattern(std::string f) {
    json["pattern"] = std::move(f);
    return *this;
}

Layout::Yaxis::Rangebreaks::Rangebreak& Layout::Yaxis::Rangebreaks::Rangebreak::templateitemname(std::string f) {
    json["templateitemname"] = std::move(f);
    return *this;
}

Layout::Yaxis::Rangebreaks::Rangebreak& Layout::Yaxis::Rangebreaks::Rangebreak::values(std::vector<double> f) {
    json["values"] = std::move(f);
    return *this;
}

std::string Layout::Yaxis::Tickfont::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Yaxis::Tickfont& Layout::Yaxis::Tickfont::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Yaxis::Tickfont& Layout::Yaxis::Tickfont::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Yaxis::Tickfont& Layout::Yaxis::Tickfont::lineposition(std::string f) {
    json["lineposition"] = std::move(f);
    return *this;
}

Layout::Yaxis::Tickfont& Layout::Yaxis::Tickfont::shadow(std::string f) {
    json["shadow"] = std::move(f);
    return *this;
}

Layout::Yaxis::Tickfont& Layout::Yaxis::Tickfont::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Yaxis::Tickfont& Layout::Yaxis::Tickfont::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Yaxis::Tickfont& Layout::Yaxis::Tickfont::textcase(std::string f) {
    json["textcase"] = std::move(f);
    return *this;
}

Layout::Yaxis::Tickfont& Layout::Yaxis::Tickfont::variant(std::string f) {
    json["variant"] = std::move(f);
    return *this;
}

Layout::Yaxis::Tickfont& Layout::Yaxis::Tickfont::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}


Layout::Yaxis::Tickformatstops& Layout::Yaxis::Tickformatstops::tickformatstop(Tickformatstop f) {
    json["tickformatstop"] = std::move(f.json);
    return *this;
}


Layout::Yaxis::Tickformatstops::Tickformatstop& Layout::Yaxis::Tickformatstops::Tickformatstop::dtickrange(std::vector<double> f) {
    json["dtickrange"] = std::move(f);
    return *this;
}

Layout::Yaxis::Tickformatstops::Tickformatstop& Layout::Yaxis::Tickformatstops::Tickformatstop::enabled(bool f) {
    json["enabled"] = std::move(f);
    return *this;
}

Layout::Yaxis::Tickformatstops::Tickformatstop& Layout::Yaxis::Tickformatstops::Tickformatstop::name(std::string f) {
    json["name"] = std::move(f);
    return *this;
}

Layout::Yaxis::Tickformatstops::Tickformatstop& Layout::Yaxis::Tickformatstops::Tickformatstop::templateitemname(std::string f) {
    json["templateitemname"] = std::move(f);
    return *this;
}

Layout::Yaxis::Tickformatstops::Tickformatstop& Layout::Yaxis::Tickformatstops::Tickformatstop::value(std::string f) {
    json["value"] = std::move(f);
    return *this;
}


Layout::Yaxis::Title& Layout::Yaxis::Title::font(Font f) {
    json["font"] = std::move(f.json);
    return *this;
}

Layout::Yaxis::Title& Layout::Yaxis::Title::standoff(double f) {
    json["standoff"] = std::move(f);
    return *this;
}

Layout::Yaxis::Title& Layout::Yaxis::Title::text(std::string f) {
    json["text"] = std::move(f);
    return *this;
}

std::string Layout::Yaxis::Title::Font::to_string(Style e) {
    switch(e) {
        case Style::NORMAL: return "normal";
        case Style::ITALIC: return "italic";
    }
    // Should be unreachable.
    throw std::invalid_argument{"Unknown enumerator value " + std::to_string(static_cast<int>(e))};
}

Layout::Yaxis::Title::Font& Layout::Yaxis::Title::Font::color(std::string f) {
    json["color"] = std::move(f);
    return *this;
}

Layout::Yaxis::Title::Font& Layout::Yaxis::Title::Font::family(std::string f) {
    json["family"] = std::move(f);
    return *this;
}

Layout::Yaxis::Title::Font& Layout::Yaxis::Title::Font::lineposition(std::string f) {
    json["lineposition"] = std::move(f);
    return *this;
}

Layout::Yaxis::Title::Font& Layout::Yaxis::Title::Font::shadow(std::string f) {
    json["shadow"] = std::move(f);
    return *this;
}

Layout::Yaxis::Title::Font& Layout::Yaxis::Title::Font::size(double f) {
    json["size"] = std::move(f);
    return *this;
}

Layout::Yaxis::Title::Font& Layout::Yaxis::Title::Font::style(enum Style f) {
    json["style"] = to_string(f);
    return *this;
}

Layout::Yaxis::Title::Font& Layout::Yaxis::Title::Font::textcase(std::string f) {
    json["textcase"] = std::move(f);
    return *this;
}

Layout::Yaxis::Title::Font& Layout::Yaxis::Title::Font::variant(std::string f) {
    json["variant"] = std::move(f);
    return *this;
}

Layout::Yaxis::Title::Font& Layout::Yaxis::Title::Font::weight(int f) {
    json["weight"] = std::move(f);
    return *this;
}

} // namespace plotlypp

