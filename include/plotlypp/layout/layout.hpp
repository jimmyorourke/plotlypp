// Copyright (c) 2025 Jimmy O'Rourke
// Licensed under and subject to the terms of the LICENSE file accompanying this distribution.
// Official repository: https://github.com/jimmyorourke/plotlypp

// Autogenerated by plotlypp/generator, from official Plotly sources.
// See https://plotly.com/graphing-libraries.
// Do not edit, changes may be overwritten!

#pragma once

#include <string>
#include <vector>

#include <plotlypp/json.hpp>
#include <plotlypp/traits.hpp>

namespace plotlypp {

class Layout {
 public:
    Layout() = default;
    Layout(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Autotypenumbers {
        ConvertTypes,
        Strict,
    };
    static std::string to_string(Autotypenumbers e);

    enum class Calendar {
        Chinese,
        Coptic,
        Discworld,
        Ethiopian,
        Gregorian,
        Hebrew,
        Islamic,
        Jalali,
        Julian,
        Mayan,
        Nanakshahi,
        Nepali,
        Persian,
        Taiwan,
        Thai,
        Ummalqura,
    };
    static std::string to_string(Calendar e);

    enum class Dragmode {
        Zoom,
        Pan,
        Select,
        Lasso,
        Drawclosedpath,
        Drawopenpath,
        Drawline,
        Drawrect,
        Drawcircle,
        Orbit,
        Turntable,
        False,
    };
    static std::string to_string(Dragmode e);

    enum class Hovermode {
        X,
        Y,
        Closest,
        False,
        XUnified,
        YUnified,
    };
    static std::string to_string(Hovermode e);

    enum class Hoversubplots {
        Single,
        Overlaying,
        Axis,
    };
    static std::string to_string(Hoversubplots e);

    enum class Selectdirection {
        H,
        V,
        D,
        Any,
    };
    static std::string to_string(Selectdirection e);

    class Activeselection;
    class Activeshape;
    class Annotations;
    class Coloraxis;
    class Colorscale;
    // Sets the global font. Note that fonts used in traces and other layout components inherit from the global font.
    class Font;
    class Geo;
    class Grid;
    class Hoverlabel;
    class Images;
    class Legend;
    class Map;
    class Mapbox;
    class Margin;
    class Modebar;
    class Newselection;
    class Newshape;
    class Polar;
    class Scene;
    class Selections;
    class Shapes;
    class Sliders;
    class Smith;
    class Ternary;
    class Title;
    // Sets transition options used during Plotly.react updates.
    class Transition;
    class Uniformtext;
    class Updatemenus;
    class Xaxis;
    class Yaxis;

    Layout& activeselection(Activeselection f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Activeselection&>>>
    Layout& activeselection(Callable&& c);

    Layout& activeshape(Activeshape f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Activeshape&>>>
    Layout& activeshape(Callable&& c);

    Layout& annotations(Annotations f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Annotations&>>>
    Layout& annotations(Callable&& c);

    // Determines whether or not a layout width or height that has been left undefined by the user is initialized on
    // each relayout. Note that, regardless of this attribute, an undefined layout width or height is always initialized
    // on the first call to plot.
    Layout& autosize(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout& autosize(Callable&& c);

    // Using *strict* a numeric string in trace data is not converted to a number. Using *convert types* a numeric
    // string in trace data may be treated as a number during automatic axis `type` detection. This is the default
    // value; however it could be overridden for individual axes.
    // - Default: convert types
    Layout& autotypenumbers(enum Autotypenumbers f);

    // Sets the default calendar system to use for interpreting and displaying dates throughout the plot.
    // - Default: gregorian
    Layout& calendar(enum Calendar f);

    // Determines the mode of single click interactions. *event* is the default value and emits the `plotly_click`
    // event. In addition this mode emits the `plotly_selected` event in drag modes *lasso* and *select*, but with no
    // event data attached (kept for compatibility reasons). The *select* flag enables selecting single data points via
    // click. This mode also supports persistent selections, meaning that pressing Shift while clicking, adds to /
    // subtracts from an existing selection. *select* with `hovermode`: *x* can be confusing, consider explicitly
    // setting `hovermode`: *closest* when using this feature. Selection events are sent accordingly as long as *event*
    // flag is set as well. When the *event* flag is missing, `plotly_click` and `plotly_selected` events are not fired.
    // - Default: event
    // - Flags: ['event', 'select']
    // - Extras ['none']
    Layout& clickmode(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout& clickmode(Callable&& c);

    Layout& coloraxis(Coloraxis f);
    Layout& coloraxis(int index, Coloraxis f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Coloraxis&>>>
    Layout& coloraxis(Callable&& c);

    Layout& colorscale(Colorscale f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Colorscale&>>>
    Layout& colorscale(Callable&& c);

    // Sets the default trace colors.
    Layout& colorway(const std::vector<std::string>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<std::string>&>>>
    Layout& colorway(Callable&& c);

    // Placeholder for exporting automargin-impacting values namely `margin.t`, `margin.b`, `margin.l` and `margin.r` in
    // *full-json* mode.
    template <typename T>
    Layout& computed(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout& computed(Callable&& c);

    // If provided, a changed value tells `Plotly.react` that one or more data arrays has changed. This way you can
    // modify arrays in-place rather than making a complete new copy for an incremental change. If NOT provided,
    // `Plotly.react` assumes that data arrays are being treated as immutable, thus any data array with a different
    // identity from its predecessor contains new data.
    template <typename T>
    Layout& datarevision(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout& datarevision(Callable&& c);

    // Determines the mode of drag interactions. *select* and *lasso* apply only to scatter traces with markers or text.
    // *orbit* and *turntable* apply only to 3D scenes.
    // - Default: zoom
    Layout& dragmode(enum Dragmode f);

    // Controls persistence of user-driven changes in `editable: true` configuration, other than trace names and axis
    // titles. Defaults to `layout.uirevision`.
    template <typename T>
    Layout& editrevision(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout& editrevision(Callable&& c);

    // Sets the global font. Note that fonts used in traces and other layout components inherit from the global font.
    Layout& font(Font f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Font&>>>
    Layout& font(Callable&& c);

    Layout& geo(Geo f);
    Layout& geo(int index, Geo f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Geo&>>>
    Layout& geo(Callable&& c);

    Layout& grid(Grid f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Grid&>>>
    Layout& grid(Callable&& c);

    // Sets the plot's height (in px).
    Layout& height(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout& height(Callable&& c);

    // Determines whether or not a text link citing the data source is placed at the bottom-right cored of the figure.
    // Has only an effect only on graphs that have been generated via forked graphs from the Chart Studio Cloud (at
    // https://chart-studio.plotly.com or on-premise).
    Layout& hidesources(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout& hidesources(Callable&& c);

    // Sets the default distance (in pixels) to look for data to add hover labels (-1 means no cutoff, 0 means no
    // looking for data). This is only a real distance for hovering on point-like objects, like scatter points. For
    // area-like objects (bars, scatter fills, etc) hovering is on inside the area and off outside, but these objects
    // will not supersede hover on point-like objects in case of conflict.
    Layout& hoverdistance(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout& hoverdistance(Callable&& c);

    Layout& hoverlabel(Hoverlabel f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Hoverlabel&>>>
    Layout& hoverlabel(Callable&& c);

    // Determines the mode of hover interactions. If *closest*, a single hoverlabel will appear for the *closest* point
    // within the `hoverdistance`. If *x* (or *y*), multiple hoverlabels will appear for multiple points at the
    // *closest* x- (or y-) coordinate within the `hoverdistance`, with the caveat that no more than one hoverlabel will
    // appear per trace. If *x unified* (or *y unified*), a single hoverlabel will appear multiple points at the closest
    // x- (or y-) coordinate within the `hoverdistance` with the caveat that no more than one hoverlabel will appear per
    // trace. In this mode, spikelines are enabled by default perpendicular to the specified axis. If false, hover
    // interactions are disabled.
    // - Default: closest
    Layout& hovermode(enum Hovermode f);

    // Determines expansion of hover effects to other subplots If *single* just the axis pair of the primary point is
    // included without overlaying subplots. If *overlaying* all subplots using the main axis and occupying the same
    // space are included. If *axis*, also include stacked subplots using the same axis when `hovermode` is set to *x*,
    // *x unified*, *y* or *y unified*.
    // - Default: overlaying
    Layout& hoversubplots(enum Hoversubplots f);

    Layout& images(Images f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Images&>>>
    Layout& images(Callable&& c);

    Layout& legend(Legend f);
    Layout& legend(int index, Legend f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Legend&>>>
    Layout& legend(Callable&& c);

    Layout& map(Map f);
    Layout& map(int index, Map f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Map&>>>
    Layout& map(Callable&& c);

    Layout& mapbox(Mapbox f);
    Layout& mapbox(int index, Mapbox f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Mapbox&>>>
    Layout& mapbox(Callable&& c);

    Layout& margin(Margin f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Margin&>>>
    Layout& margin(Callable&& c);

    // Assigns extra meta information that can be used in various `text` attributes. Attributes such as the graph, axis
    // and colorbar `title.text`, annotation `text` `trace.name` in legend items, `rangeselector`, `updatemenus` and
    // `sliders` `label` text all support `meta`. One can access `meta` fields using template strings: `%{meta[i]}`
    // where `i` is the index of the `meta` item in question. `meta` can also be an object for example `{key: value}`
    // which can be accessed %{meta[key]}.
    template <typename T>
    Layout& meta(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout& meta(Callable&& c);
    template <typename T>
    Layout& meta(const std::vector<T>& f);

    // Sets the source reference on Chart Studio Cloud for `meta`.
    Layout& metasrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout& metasrc(Callable&& c);

    // Minimum height of the plot with margin.automargin applied (in px)
    Layout& minreducedheight(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout& minreducedheight(Callable&& c);

    // Minimum width of the plot with margin.automargin applied (in px)
    Layout& minreducedwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout& minreducedwidth(Callable&& c);

    Layout& modebar(Modebar f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Modebar&>>>
    Layout& modebar(Callable&& c);

    Layout& newselection(Newselection f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Newselection&>>>
    Layout& newselection(Callable&& c);

    Layout& newshape(Newshape f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Newshape&>>>
    Layout& newshape(Callable&& c);

    // Sets the background color of the paper where the graph is drawn.
    Layout& paper_bgcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout& paper_bgcolor(Callable&& c);

    // Sets the background color of the plotting area in-between x and y axes.
    Layout& plot_bgcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout& plot_bgcolor(Callable&& c);

    Layout& polar(Polar f);
    Layout& polar(int index, Polar f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Polar&>>>
    Layout& polar(Callable&& c);

    Layout& scene(Scene f);
    Layout& scene(int index, Scene f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Scene&>>>
    Layout& scene(Callable&& c);

    // When `dragmode` is set to *select*, this limits the selection of the drag to horizontal, vertical or diagonal.
    // *h* only allows horizontal selection, *v* only vertical, *d* only diagonal and *any* sets no limit.
    // - Default: any
    Layout& selectdirection(enum Selectdirection f);

    // Controls persistence of user-driven changes in selected points from all traces.
    template <typename T>
    Layout& selectionrevision(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout& selectionrevision(Callable&& c);

    Layout& selections(Selections f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Selections&>>>
    Layout& selections(Callable&& c);

    // Sets the decimal and thousand separators. For example, *. * puts a '.' before decimals and a space between
    // thousands. In English locales, dflt is *.,* but other locales may alter this default.
    Layout& separators(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout& separators(Callable&& c);

    Layout& shapes(Shapes f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Shapes&>>>
    Layout& shapes(Callable&& c);

    // Determines whether or not a legend is drawn. Default is `true` if there is a trace to show and any of these: a)
    // Two or more traces would by default be shown in the legend. b) One pie trace is shown in the legend. c) One trace
    // is explicitly given with `showlegend: true`.
    Layout& showlegend(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout& showlegend(Callable&& c);

    Layout& sliders(Sliders f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Sliders&>>>
    Layout& sliders(Callable&& c);

    Layout& smith(Smith f);
    Layout& smith(int index, Smith f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Smith&>>>
    Layout& smith(Callable&& c);

    // Sets the default distance (in pixels) to look for data to draw spikelines to (-1 means no cutoff, 0 means no
    // looking for data). As with hoverdistance, distance does not apply to area-like objects. In addition, some objects
    // can be hovered on but will not generate spikelines, such as scatter fills.
    Layout& spikedistance(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout& spikedistance(Callable&& c);

    // Default attributes to be applied to the plot. Templates can be created from existing plots using
    // `Plotly.makeTemplate`, or created manually. They should be objects with format: `{layout: layoutTemplate, data:
    // {[type]: [traceTemplate, ...]}, ...}` `layoutTemplate` and `traceTemplate` are objects matching the attribute
    // structure of `layout` and a data trace.  Trace templates are applied cyclically to traces of each type. Container
    // arrays (eg `annotations`) have special handling: An object ending in `defaults` (eg `annotationdefaults`) is
    // applied to each array item. But if an item has a `templateitemname` key we look in the template array for an item
    // with matching `name` and apply that instead. If no matching `name` is found we mark the item invisible. Any named
    // template item not referenced is appended to the end of the array, so you can use this for a watermark annotation
    // or a logo image, for example. To omit one of these items on the plot, make an item with matching
    // `templateitemname` and `visible: false`.
    template <typename T>
    Layout& plotly_template(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout& plotly_template(Callable&& c);

    Layout& ternary(Ternary f);
    Layout& ternary(int index, Ternary f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Ternary&>>>
    Layout& ternary(Callable&& c);

    Layout& title(Title f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Title&>>>
    Layout& title(Callable&& c);

    // Sets transition options used during Plotly.react updates.
    Layout& transition(Transition f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Transition&>>>
    Layout& transition(Callable&& c);

    // Used to allow user interactions with the plot to persist after `Plotly.react` calls that are unaware of these
    // interactions. If `uirevision` is omitted, or if it is given and it changed from the previous `Plotly.react` call,
    // the exact new figure is used. If `uirevision` is truthy and did NOT change, any attribute that has been affected
    // by user interactions and did not receive a different value in the new figure will keep the interaction value.
    // `layout.uirevision` attribute serves as the default for `uirevision` attributes in various sub-containers. For
    // finer control you can set these sub-attributes directly. For example, if your app separately controls the data on
    // the x and y axes you might set `xaxis.uirevision=*time*` and `yaxis.uirevision=*cost*`. Then if only the y data
    // is changed, you can update `yaxis.uirevision=*quantity*` and the y axis range will reset but the x axis range
    // will retain any user-driven zoom.
    template <typename T>
    Layout& uirevision(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout& uirevision(Callable&& c);

    Layout& uniformtext(Uniformtext f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Uniformtext&>>>
    Layout& uniformtext(Callable&& c);

    Layout& updatemenus(Updatemenus f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Updatemenus&>>>
    Layout& updatemenus(Callable&& c);

    // Sets the plot's width (in px).
    Layout& width(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout& width(Callable&& c);

    Layout& xaxis(Xaxis f);
    Layout& xaxis(int index, Xaxis f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Xaxis&>>>
    Layout& xaxis(Callable&& c);

    Layout& yaxis(Yaxis f);
    Layout& yaxis(int index, Yaxis f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Yaxis&>>>
    Layout& yaxis(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Activeselection {
 public:
    Activeselection() = default;
    Activeselection(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Sets the color filling the active selection' interior.
    Layout::Activeselection& fillcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Activeselection& fillcolor(Callable&& c);

    // Sets the opacity of the active selection.
    Layout::Activeselection& opacity(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Activeselection& opacity(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Activeshape {
 public:
    Activeshape() = default;
    Activeshape(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Sets the color filling the active shape' interior.
    Layout::Activeshape& fillcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Activeshape& fillcolor(Callable&& c);

    // Sets the opacity of the active shape.
    Layout::Activeshape& opacity(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Activeshape& opacity(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Annotations {
 public:
    Annotations() = default;
    Annotations(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    class Annotation;

    Layout::Annotations& annotation(Annotation f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Annotation&>>>
    Layout::Annotations& annotation(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Annotations::Annotation {
 public:
    Annotation() = default;
    Annotation(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Align {
        Left,
        Center,
        Right,
    };
    static std::string to_string(Align e);

    enum class Clicktoshow {
        False,
        Onoff,
        Onout,
    };
    static std::string to_string(Clicktoshow e);

    enum class Valign {
        Top,
        Middle,
        Bottom,
    };
    static std::string to_string(Valign e);

    enum class Xanchor {
        Auto,
        Left,
        Center,
        Right,
    };
    static std::string to_string(Xanchor e);

    enum class Yanchor {
        Auto,
        Top,
        Middle,
        Bottom,
    };
    static std::string to_string(Yanchor e);

    // Sets the annotation text font.
    class Font;
    class Hoverlabel;

    // Sets the horizontal alignment of the `text` within the box. Has an effect only if `text` spans two or more lines
    // (i.e. `text` contains one or more <br> HTML tags) or if an explicit width is set to override the text width.
    // - Default: center
    Layout::Annotations::Annotation& align(enum Align f);

    // Sets the color of the annotation arrow.
    Layout::Annotations::Annotation& arrowcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Annotations::Annotation& arrowcolor(Callable&& c);

    // Sets the end annotation arrow head style.
    Layout::Annotations::Annotation& arrowhead(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Annotations::Annotation& arrowhead(Callable&& c);

    // Sets the annotation arrow head position.
    // - Default: end
    // - Flags: ['end', 'start']
    // - Extras ['none']
    Layout::Annotations::Annotation& arrowside(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Annotations::Annotation& arrowside(Callable&& c);

    // Sets the size of the end annotation arrow head, relative to `arrowwidth`. A value of 1 (default) gives a head
    // about 3x as wide as the line.
    Layout::Annotations::Annotation& arrowsize(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Annotations::Annotation& arrowsize(Callable&& c);

    // Sets the width (in px) of annotation arrow line.
    Layout::Annotations::Annotation& arrowwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Annotations::Annotation& arrowwidth(Callable&& c);

    // Sets the x component of the arrow tail about the arrow head. If `axref` is `pixel`, a positive (negative)
    // component corresponds to an arrow pointing from right to left (left to right). If `axref` is not `pixel` and is
    // exactly the same as `xref`, this is an absolute value on that axis, like `x`, specified in the same coordinates
    // as `xref`.
    template <typename T>
    Layout::Annotations::Annotation& ax(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Annotations::Annotation& ax(Callable&& c);

    // Indicates in what coordinates the tail of the annotation (ax,ay) is specified. If set to a x axis id (e.g. *x* or
    // *x2*), the `x` position refers to a x coordinate. If set to *paper*, the `x` position refers to the distance from
    // the left of the plotting area in normalized coordinates where *0* (*1*) corresponds to the left (right). If set
    // to a x axis ID followed by *domain* (separated by a space), the position behaves like for *paper*, but refers to
    // the distance in fractions of the domain length from the left of the domain of that axis: e.g., *x2 domain* refers
    // to the domain of the second x  axis and a x position of 0.5 refers to the point between the left and the right of
    // the domain of the second x axis. In order for absolute positioning of the arrow to work, *axref* must be exactly
    // the same as *xref*, otherwise *axref* will revert to *pixel* (explained next). For relative positioning, *axref*
    // can be set to *pixel*, in which case the *ax* value is specified in pixels relative to *x*. Absolute positioning
    // is useful for trendline annotations which should continue to indicate the correct trend when zoomed. Relative
    // positioning is useful for specifying the text offset for an annotated point.
    Layout::Annotations::Annotation& axref(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Annotations::Annotation& axref(Callable&& c);

    // Sets the y component of the arrow tail about the arrow head. If `ayref` is `pixel`, a positive (negative)
    // component corresponds to an arrow pointing from bottom to top (top to bottom). If `ayref` is not `pixel` and is
    // exactly the same as `yref`, this is an absolute value on that axis, like `y`, specified in the same coordinates
    // as `yref`.
    template <typename T>
    Layout::Annotations::Annotation& ay(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Annotations::Annotation& ay(Callable&& c);

    // Indicates in what coordinates the tail of the annotation (ax,ay) is specified. If set to a y axis id (e.g. *y* or
    // *y2*), the `y` position refers to a y coordinate. If set to *paper*, the `y` position refers to the distance from
    // the bottom of the plotting area in normalized coordinates where *0* (*1*) corresponds to the bottom (top). If set
    // to a y axis ID followed by *domain* (separated by a space), the position behaves like for *paper*, but refers to
    // the distance in fractions of the domain length from the bottom of the domain of that axis: e.g., *y2 domain*
    // refers to the domain of the second y  axis and a y position of 0.5 refers to the point between the bottom and the
    // top of the domain of the second y axis. In order for absolute positioning of the arrow to work, *ayref* must be
    // exactly the same as *yref*, otherwise *ayref* will revert to *pixel* (explained next). For relative positioning,
    // *ayref* can be set to *pixel*, in which case the *ay* value is specified in pixels relative to *y*. Absolute
    // positioning is useful for trendline annotations which should continue to indicate the correct trend when zoomed.
    // Relative positioning is useful for specifying the text offset for an annotated point.
    Layout::Annotations::Annotation& ayref(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Annotations::Annotation& ayref(Callable&& c);

    // Sets the background color of the annotation.
    Layout::Annotations::Annotation& bgcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Annotations::Annotation& bgcolor(Callable&& c);

    // Sets the color of the border enclosing the annotation `text`.
    Layout::Annotations::Annotation& bordercolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Annotations::Annotation& bordercolor(Callable&& c);

    // Sets the padding (in px) between the `text` and the enclosing border.
    Layout::Annotations::Annotation& borderpad(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Annotations::Annotation& borderpad(Callable&& c);

    // Sets the width (in px) of the border enclosing the annotation `text`.
    Layout::Annotations::Annotation& borderwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Annotations::Annotation& borderwidth(Callable&& c);

    // Determines whether the annotation text box captures mouse move and click events, or allows those events to pass
    // through to data points in the plot that may be behind the annotation. By default `captureevents` is *false*
    // unless `hovertext` is provided. If you use the event `plotly_clickannotation` without `hovertext` you must
    // explicitly enable `captureevents`.
    Layout::Annotations::Annotation& captureevents(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Annotations::Annotation& captureevents(Callable&& c);

    // Makes this annotation respond to clicks on the plot. If you click a data point that exactly matches the `x` and
    // `y` values of this annotation, and it is hidden (visible: false), it will appear. In *onoff* mode, you must click
    // the same point again to make it disappear, so if you click multiple points, you can show multiple annotations. In
    // *onout* mode, a click anywhere else in the plot (on another data point or not) will hide this annotation. If you
    // need to show/hide this annotation in response to different `x` or `y` values, you can set `xclick` and/or
    // `yclick`. This is useful for example to label the side of a bar. To label markers though, `standoff` is preferred
    // over `xclick` and `yclick`.
    // - Default: False
    Layout::Annotations::Annotation& clicktoshow(enum Clicktoshow f);

    // Sets the annotation text font.
    Layout::Annotations::Annotation& font(Font f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Font&>>>
    Layout::Annotations::Annotation& font(Callable&& c);

    // Sets an explicit height for the text box. null (default) lets the text set the box height. Taller text will be
    // clipped.
    Layout::Annotations::Annotation& height(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Annotations::Annotation& height(Callable&& c);

    Layout::Annotations::Annotation& hoverlabel(Hoverlabel f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Hoverlabel&>>>
    Layout::Annotations::Annotation& hoverlabel(Callable&& c);

    // Sets text to appear when hovering over this annotation. If omitted or blank, no hover label will appear.
    Layout::Annotations::Annotation& hovertext(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Annotations::Annotation& hovertext(Callable&& c);

    // When used in a template, named items are created in the output figure in addition to any items the figure already
    // has in this array. You can modify these items in the output figure by making your own item with
    // `templateitemname` matching this `name` alongside your modifications (including `visible: false` or `enabled:
    // false` to hide it). Has no effect outside of a template.
    Layout::Annotations::Annotation& name(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Annotations::Annotation& name(Callable&& c);

    // Sets the opacity of the annotation (text + arrow).
    Layout::Annotations::Annotation& opacity(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Annotations::Annotation& opacity(Callable&& c);

    // Determines whether or not the annotation is drawn with an arrow. If *true*, `text` is placed near the arrow's
    // tail. If *false*, `text` lines up with the `x` and `y` provided.
    Layout::Annotations::Annotation& showarrow(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Annotations::Annotation& showarrow(Callable&& c);

    // Sets a distance, in pixels, to move the end arrowhead away from the position it is pointing at, for example to
    // point at the edge of a marker independent of zoom. Note that this shortens the arrow from the `ax` / `ay` vector,
    // in contrast to `xshift` / `yshift` which moves everything by this amount.
    Layout::Annotations::Annotation& standoff(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Annotations::Annotation& standoff(Callable&& c);

    // Sets the start annotation arrow head style.
    Layout::Annotations::Annotation& startarrowhead(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Annotations::Annotation& startarrowhead(Callable&& c);

    // Sets the size of the start annotation arrow head, relative to `arrowwidth`. A value of 1 (default) gives a head
    // about 3x as wide as the line.
    Layout::Annotations::Annotation& startarrowsize(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Annotations::Annotation& startarrowsize(Callable&& c);

    // Sets a distance, in pixels, to move the start arrowhead away from the position it is pointing at, for example to
    // point at the edge of a marker independent of zoom. Note that this shortens the arrow from the `ax` / `ay` vector,
    // in contrast to `xshift` / `yshift` which moves everything by this amount.
    Layout::Annotations::Annotation& startstandoff(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Annotations::Annotation& startstandoff(Callable&& c);

    // Used to refer to a named item in this array in the template. Named items from the template will be created even
    // without a matching item in the input figure, but you can modify one by making an item with `templateitemname`
    // matching its `name`, alongside your modifications (including `visible: false` or `enabled: false` to hide it). If
    // there is no template or no matching item, this item will be hidden unless you explicitly show it with `visible:
    // true`.
    Layout::Annotations::Annotation& templateitemname(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Annotations::Annotation& templateitemname(Callable&& c);

    // Sets the text associated with this annotation. Plotly uses a subset of HTML tags to do things like newline
    // (<br>), bold (<b></b>), italics (<i></i>), hyperlinks (<a href='...'></a>). Tags <em>, <sup>, <sub>, <s>, <u>
    // <span> are also supported.
    Layout::Annotations::Annotation& text(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Annotations::Annotation& text(Callable&& c);

    // Sets the angle at which the `text` is drawn with respect to the horizontal.
    Layout::Annotations::Annotation& textangle(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Annotations::Annotation& textangle(Callable&& c);

    // Sets the vertical alignment of the `text` within the box. Has an effect only if an explicit height is set to
    // override the text height.
    // - Default: middle
    Layout::Annotations::Annotation& valign(enum Valign f);

    // Determines whether or not this annotation is visible.
    Layout::Annotations::Annotation& visible(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Annotations::Annotation& visible(Callable&& c);

    // Sets an explicit width for the text box. null (default) lets the text set the box width. Wider text will be
    // clipped. There is no automatic wrapping; use <br> to start a new line.
    Layout::Annotations::Annotation& width(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Annotations::Annotation& width(Callable&& c);

    // Sets the annotation's x position. If the axis `type` is *log*, then you must take the log of your desired range.
    // If the axis `type` is *date*, it should be date strings, like date data, though Date objects and unix
    // milliseconds will be accepted and converted to strings. If the axis `type` is *category*, it should be numbers,
    // using the scale where each category is assigned a serial number from zero in the order it appears.
    template <typename T>
    Layout::Annotations::Annotation& x(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Annotations::Annotation& x(Callable&& c);

    // Sets the text box's horizontal position anchor This anchor binds the `x` position to the *left*, *center* or
    // *right* of the annotation. For example, if `x` is set to 1, `xref` to *paper* and `xanchor` to *right* then the
    // right-most portion of the annotation lines up with the right-most edge of the plotting area. If *auto*, the
    // anchor is equivalent to *center* for data-referenced annotations or if there is an arrow, whereas for
    // paper-referenced with no arrow, the anchor picked corresponds to the closest side.
    // - Default: auto
    Layout::Annotations::Annotation& xanchor(enum Xanchor f);

    // Toggle this annotation when clicking a data point whose `x` value is `xclick` rather than the annotation's `x`
    // value.
    template <typename T>
    Layout::Annotations::Annotation& xclick(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Annotations::Annotation& xclick(Callable&& c);

    // Sets the annotation's x coordinate axis. If set to a x axis id (e.g. *x* or *x2*), the `x` position refers to a x
    // coordinate. If set to *paper*, the `x` position refers to the distance from the left of the plotting area in
    // normalized coordinates where *0* (*1*) corresponds to the left (right). If set to a x axis ID followed by
    // *domain* (separated by a space), the position behaves like for *paper*, but refers to the distance in fractions
    // of the domain length from the left of the domain of that axis: e.g., *x2 domain* refers to the domain of the
    // second x  axis and a x position of 0.5 refers to the point between the left and the right of the domain of the
    // second x axis.
    Layout::Annotations::Annotation& xref(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Annotations::Annotation& xref(Callable&& c);

    // Shifts the position of the whole annotation and arrow to the right (positive) or left (negative) by this many
    // pixels.
    Layout::Annotations::Annotation& xshift(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Annotations::Annotation& xshift(Callable&& c);

    // Sets the annotation's y position. If the axis `type` is *log*, then you must take the log of your desired range.
    // If the axis `type` is *date*, it should be date strings, like date data, though Date objects and unix
    // milliseconds will be accepted and converted to strings. If the axis `type` is *category*, it should be numbers,
    // using the scale where each category is assigned a serial number from zero in the order it appears.
    template <typename T>
    Layout::Annotations::Annotation& y(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Annotations::Annotation& y(Callable&& c);

    // Sets the text box's vertical position anchor This anchor binds the `y` position to the *top*, *middle* or
    // *bottom* of the annotation. For example, if `y` is set to 1, `yref` to *paper* and `yanchor` to *top* then the
    // top-most portion of the annotation lines up with the top-most edge of the plotting area. If *auto*, the anchor is
    // equivalent to *middle* for data-referenced annotations or if there is an arrow, whereas for paper-referenced with
    // no arrow, the anchor picked corresponds to the closest side.
    // - Default: auto
    Layout::Annotations::Annotation& yanchor(enum Yanchor f);

    // Toggle this annotation when clicking a data point whose `y` value is `yclick` rather than the annotation's `y`
    // value.
    template <typename T>
    Layout::Annotations::Annotation& yclick(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Annotations::Annotation& yclick(Callable&& c);

    // Sets the annotation's y coordinate axis. If set to a y axis id (e.g. *y* or *y2*), the `y` position refers to a y
    // coordinate. If set to *paper*, the `y` position refers to the distance from the bottom of the plotting area in
    // normalized coordinates where *0* (*1*) corresponds to the bottom (top). If set to a y axis ID followed by
    // *domain* (separated by a space), the position behaves like for *paper*, but refers to the distance in fractions
    // of the domain length from the bottom of the domain of that axis: e.g., *y2 domain* refers to the domain of the
    // second y  axis and a y position of 0.5 refers to the point between the bottom and the top of the domain of the
    // second y axis.
    Layout::Annotations::Annotation& yref(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Annotations::Annotation& yref(Callable&& c);

    // Shifts the position of the whole annotation and arrow up (positive) or down (negative) by this many pixels.
    Layout::Annotations::Annotation& yshift(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Annotations::Annotation& yshift(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets the annotation text font.
class Layout::Annotations::Annotation::Font {
 public:
    Font() = default;
    Font(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    enum class Textcase {
        Normal,
        WordCaps,
        Upper,
        Lower,
    };
    static std::string to_string(Textcase e);

    enum class Variant {
        Normal,
        SmallCaps,
        AllSmallCaps,
        AllPetiteCaps,
        PetiteCaps,
        Unicase,
    };
    static std::string to_string(Variant e);

    Layout::Annotations::Annotation::Font& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Annotations::Annotation::Font& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Annotations::Annotation::Font& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Annotations::Annotation::Font& family(Callable&& c);

    // Sets the kind of decoration line(s) with text, such as an *under*, *over* or *through* as well as combinations
    // e.g. *under+over*, etc.
    // - Default: none
    // - Flags: ['under', 'over', 'through']
    // - Extras ['none']
    Layout::Annotations::Annotation::Font& lineposition(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Annotations::Annotation::Font& lineposition(Callable&& c);

    // Sets the shape and color of the shadow behind text. *auto* places minimal shadow and applies contrast text font
    // color. See https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow for additional options.
    Layout::Annotations::Annotation::Font& shadow(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Annotations::Annotation::Font& shadow(Callable&& c);

    Layout::Annotations::Annotation::Font& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Annotations::Annotation::Font& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Annotations::Annotation::Font& style(enum Style f);

    // Sets capitalization of text. It can be used to make text appear in all-uppercase or all-lowercase, or with each
    // word capitalized.
    // - Default: normal
    Layout::Annotations::Annotation::Font& textcase(enum Textcase f);

    // Sets the variant of the font.
    // - Default: normal
    Layout::Annotations::Annotation::Font& variant(enum Variant f);

    // Sets the weight (or boldness) of the font.
    Layout::Annotations::Annotation::Font& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Annotations::Annotation::Font& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Annotations::Annotation::Hoverlabel {
 public:
    Hoverlabel() = default;
    Hoverlabel(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Sets the hover label text font. By default uses the global hover font and size, with color from
    // `hoverlabel.bordercolor`.
    class Font;

    // Sets the background color of the hover label. By default uses the annotation's `bgcolor` made opaque, or white if
    // it was transparent.
    Layout::Annotations::Annotation::Hoverlabel& bgcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Annotations::Annotation::Hoverlabel& bgcolor(Callable&& c);

    // Sets the border color of the hover label. By default uses either dark grey or white, for maximum contrast with
    // `hoverlabel.bgcolor`.
    Layout::Annotations::Annotation::Hoverlabel& bordercolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Annotations::Annotation::Hoverlabel& bordercolor(Callable&& c);

    // Sets the hover label text font. By default uses the global hover font and size, with color from
    // `hoverlabel.bordercolor`.
    Layout::Annotations::Annotation::Hoverlabel& font(Font f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Font&>>>
    Layout::Annotations::Annotation::Hoverlabel& font(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets the hover label text font. By default uses the global hover font and size, with color from
// `hoverlabel.bordercolor`.
class Layout::Annotations::Annotation::Hoverlabel::Font {
 public:
    Font() = default;
    Font(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    enum class Textcase {
        Normal,
        WordCaps,
        Upper,
        Lower,
    };
    static std::string to_string(Textcase e);

    enum class Variant {
        Normal,
        SmallCaps,
        AllSmallCaps,
        AllPetiteCaps,
        PetiteCaps,
        Unicase,
    };
    static std::string to_string(Variant e);

    Layout::Annotations::Annotation::Hoverlabel::Font& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Annotations::Annotation::Hoverlabel::Font& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Annotations::Annotation::Hoverlabel::Font& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Annotations::Annotation::Hoverlabel::Font& family(Callable&& c);

    // Sets the kind of decoration line(s) with text, such as an *under*, *over* or *through* as well as combinations
    // e.g. *under+over*, etc.
    // - Default: none
    // - Flags: ['under', 'over', 'through']
    // - Extras ['none']
    Layout::Annotations::Annotation::Hoverlabel::Font& lineposition(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Annotations::Annotation::Hoverlabel::Font& lineposition(Callable&& c);

    // Sets the shape and color of the shadow behind text. *auto* places minimal shadow and applies contrast text font
    // color. See https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow for additional options.
    Layout::Annotations::Annotation::Hoverlabel::Font& shadow(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Annotations::Annotation::Hoverlabel::Font& shadow(Callable&& c);

    Layout::Annotations::Annotation::Hoverlabel::Font& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Annotations::Annotation::Hoverlabel::Font& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Annotations::Annotation::Hoverlabel::Font& style(enum Style f);

    // Sets capitalization of text. It can be used to make text appear in all-uppercase or all-lowercase, or with each
    // word capitalized.
    // - Default: normal
    Layout::Annotations::Annotation::Hoverlabel::Font& textcase(enum Textcase f);

    // Sets the variant of the font.
    // - Default: normal
    Layout::Annotations::Annotation::Hoverlabel::Font& variant(enum Variant f);

    // Sets the weight (or boldness) of the font.
    Layout::Annotations::Annotation::Hoverlabel::Font& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Annotations::Annotation::Hoverlabel::Font& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Coloraxis {
 public:
    Coloraxis() = default;
    Coloraxis(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    class Colorbar;

    // Determines whether the colorscale is a default palette (`autocolorscale: true`) or the palette determined by
    // `colorscale`. In case `colorscale` is unspecified or `autocolorscale` is true, the default palette will be chosen
    // according to whether numbers in the `color` array are all positive, all negative or mixed.
    Layout::Coloraxis& autocolorscale(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Coloraxis& autocolorscale(Callable&& c);

    // Determines whether or not the color domain is computed with respect to the input data (here corresponding trace
    // color array(s)) or the bounds set in `cmin` and `cmax` Defaults to `false` when `cmin` and `cmax` are set by the
    // user.
    Layout::Coloraxis& cauto(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Coloraxis& cauto(Callable&& c);

    // Sets the upper bound of the color domain. Value should have the same units as corresponding trace color array(s)
    // and if set, `cmin` must be set as well.
    Layout::Coloraxis& cmax(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Coloraxis& cmax(Callable&& c);

    // Sets the mid-point of the color domain by scaling `cmin` and/or `cmax` to be equidistant to this point. Value
    // should have the same units as corresponding trace color array(s). Has no effect when `cauto` is `false`.
    Layout::Coloraxis& cmid(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Coloraxis& cmid(Callable&& c);

    // Sets the lower bound of the color domain. Value should have the same units as corresponding trace color array(s)
    // and if set, `cmax` must be set as well.
    Layout::Coloraxis& cmin(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Coloraxis& cmin(Callable&& c);

    Layout::Coloraxis& colorbar(Colorbar f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Colorbar&>>>
    Layout::Coloraxis& colorbar(Callable&& c);

    // Sets the colorscale. The colorscale must be an array containing arrays mapping a normalized value to an rgb,
    // rgba, hex, hsl, hsv, or named color string. At minimum, a mapping for the lowest (0) and highest (1) values are
    // required. For example, `[[0, 'rgb(0,0,255)'], [1, 'rgb(255,0,0)']]`. To control the bounds of the colorscale in
    // color space, use `cmin` and `cmax`. Alternatively, `colorscale` may be a palette name string of the following
    // list:
    // Blackbody,Bluered,Blues,Cividis,Earth,Electric,Greens,Greys,Hot,Jet,Picnic,Portland,Rainbow,RdBu,Reds,Viridis,YlGnBu,YlOrRd.
    Layout::Coloraxis& colorscale(std::string f);
    Layout::Coloraxis& colorscale(const std::vector<std::pair<double, std::string>>& f);
    template <typename Callable,
              typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&> ||
                                          std::is_invocable_v<Callable, std::vector<std::pair<double, std::string>>&>>>
    Layout::Coloraxis& colorscale(Callable&& c);

    // Reverses the color mapping if true. If true, `cmin` will correspond to the last color in the array and `cmax`
    // will correspond to the first color.
    Layout::Coloraxis& reversescale(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Coloraxis& reversescale(Callable&& c);

    // Determines whether or not a colorbar is displayed for this trace.
    Layout::Coloraxis& showscale(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Coloraxis& showscale(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Coloraxis::Colorbar {
 public:
    Colorbar() = default;
    Colorbar(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Exponentformat {
        None,
        E,
        Power,
        Si,
        B,
    };
    static std::string to_string(Exponentformat e);

    enum class Lenmode {
        Fraction,
        Pixels,
    };
    static std::string to_string(Lenmode e);

    enum class Orientation {
        H,
        V,
    };
    static std::string to_string(Orientation e);

    enum class Showexponent {
        All,
        First,
        Last,
        None,
    };
    static std::string to_string(Showexponent e);

    enum class Showtickprefix {
        All,
        First,
        Last,
        None,
    };
    static std::string to_string(Showtickprefix e);

    enum class Showticksuffix {
        All,
        First,
        Last,
        None,
    };
    static std::string to_string(Showticksuffix e);

    enum class Thicknessmode {
        Fraction,
        Pixels,
    };
    static std::string to_string(Thicknessmode e);

    enum class Ticklabeloverflow {
        Allow,
        HidePastDiv,
        HidePastDomain,
    };
    static std::string to_string(Ticklabeloverflow e);

    enum class Ticklabelposition {
        Outside,
        Inside,
        OutsideTop,
        InsideTop,
        OutsideLeft,
        InsideLeft,
        OutsideRight,
        InsideRight,
        OutsideBottom,
        InsideBottom,
    };
    static std::string to_string(Ticklabelposition e);

    enum class Tickmode {
        Auto,
        Linear,
        Array,
    };
    static std::string to_string(Tickmode e);

    enum class Ticks {
        Outside,
        Inside,
        Empty,
    };
    static std::string to_string(Ticks e);

    enum class Xanchor {
        Left,
        Center,
        Right,
    };
    static std::string to_string(Xanchor e);

    enum class Xref {
        Container,
        Paper,
    };
    static std::string to_string(Xref e);

    enum class Yanchor {
        Top,
        Middle,
        Bottom,
    };
    static std::string to_string(Yanchor e);

    enum class Yref {
        Container,
        Paper,
    };
    static std::string to_string(Yref e);

    // Sets the color bar's tick label font
    class Tickfont;
    class Tickformatstops;
    class Title;

    // Sets the color of padded area.
    Layout::Coloraxis::Colorbar& bgcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Coloraxis::Colorbar& bgcolor(Callable&& c);

    // Sets the axis line color.
    Layout::Coloraxis::Colorbar& bordercolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Coloraxis::Colorbar& bordercolor(Callable&& c);

    // Sets the width (in px) or the border enclosing this color bar.
    Layout::Coloraxis::Colorbar& borderwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Coloraxis::Colorbar& borderwidth(Callable&& c);

    // Sets the step in-between ticks on this axis. Use with `tick0`. Must be a positive number, or special strings
    // available to *log* and *date* axes. If the axis `type` is *log*, then ticks are set every 10^(n*dtick) where n is
    // the tick number. For example, to set a tick mark at 1, 10, 100, 1000, ... set dtick to 1. To set tick marks at 1,
    // 100, 10000, ... set dtick to 2. To set tick marks at 1, 5, 25, 125, 625, 3125, ... set dtick to log_10(5), or
    // 0.69897000433. *log* has several special values; *L<f>*, where `f` is a positive number, gives ticks linearly
    // spaced in value (but not position). For example `tick0` = 0.1, `dtick` = *L0.5* will put ticks at 0.1,
    // 0.6, 1.1, 1.6 etc. To show powers of 10 plus small digits between, use *D1* (all digits) or *D2* (only 2 and 5).
    // `tick0` is ignored for *D1* and *D2*. If the axis `type` is *date*, then you must convert the time to
    // milliseconds. For example, to set the interval between ticks to one day, set `dtick` to 86400000.0. *date* also
    // has special values *M<n>* gives ticks spaced by a number of months. `n` must be a positive integer. To set ticks
    // on the 15th of every third month, set `tick0` to *2000-01-15* and `dtick` to *M3*. To set ticks every 4 years,
    // set `dtick` to *M48*
    template <typename T>
    Layout::Coloraxis::Colorbar& dtick(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Coloraxis::Colorbar& dtick(Callable&& c);

    // Determines a formatting rule for the tick exponents. For example, consider the number 1,000,000,000. If *none*,
    // it appears as 1,000,000,000. If *e*, 1e+9. If *E*, 1E+9. If *power*, 1x10^9 (with 9 in a super script). If *SI*,
    // 1G. If *B*, 1B.
    // - Default: B
    Layout::Coloraxis::Colorbar& exponentformat(enum Exponentformat f);

    // Replacement text for specific tick or hover labels. For example using {US: 'USA', CA: 'Canada'} changes US to USA
    // and CA to Canada. The labels we would have shown must match the keys exactly, after adding any tickprefix or
    // ticksuffix. For negative numbers the minus sign symbol used (U+2212) is wider than the regular ascii dash. That
    // means you need to use 1 instead of -1. labelalias can be used with any axis type, and both keys (if needed) and
    // values (if desired) can include html-like tags or MathJax.
    template <typename T>
    Layout::Coloraxis::Colorbar& labelalias(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Coloraxis::Colorbar& labelalias(Callable&& c);

    // Sets the length of the color bar This measure excludes the padding of both ends. That is, the color bar length is
    // this length minus the padding on both ends.
    Layout::Coloraxis::Colorbar& len(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Coloraxis::Colorbar& len(Callable&& c);

    // Determines whether this color bar's length (i.e. the measure in the color variation direction) is set in units of
    // plot *fraction* or in *pixels. Use `len` to set the value.
    // - Default: fraction
    Layout::Coloraxis::Colorbar& lenmode(enum Lenmode f);

    // Hide SI prefix for 10^n if |n| is below this number. This only has an effect when `tickformat` is *SI* or *B*.
    Layout::Coloraxis::Colorbar& minexponent(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Coloraxis::Colorbar& minexponent(Callable&& c);

    // Specifies the maximum number of ticks for the particular axis. The actual number of ticks will be chosen
    // automatically to be less than or equal to `nticks`. Has an effect only if `tickmode` is set to *auto*.
    Layout::Coloraxis::Colorbar& nticks(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Coloraxis::Colorbar& nticks(Callable&& c);

    // Sets the orientation of the colorbar.
    // - Default: v
    Layout::Coloraxis::Colorbar& orientation(enum Orientation f);

    // Sets the axis line color.
    Layout::Coloraxis::Colorbar& outlinecolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Coloraxis::Colorbar& outlinecolor(Callable&& c);

    // Sets the width (in px) of the axis line.
    Layout::Coloraxis::Colorbar& outlinewidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Coloraxis::Colorbar& outlinewidth(Callable&& c);

    // If "true", even 4-digit integers are separated
    Layout::Coloraxis::Colorbar& separatethousands(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Coloraxis::Colorbar& separatethousands(Callable&& c);

    // If *all*, all exponents are shown besides their significands. If *first*, only the exponent of the first tick is
    // shown. If *last*, only the exponent of the last tick is shown. If *none*, no exponents appear.
    // - Default: all
    Layout::Coloraxis::Colorbar& showexponent(enum Showexponent f);

    // Determines whether or not the tick labels are drawn.
    Layout::Coloraxis::Colorbar& showticklabels(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Coloraxis::Colorbar& showticklabels(Callable&& c);

    // If *all*, all tick labels are displayed with a prefix. If *first*, only the first tick is displayed with a
    // prefix. If *last*, only the last tick is displayed with a suffix. If *none*, tick prefixes are hidden.
    // - Default: all
    Layout::Coloraxis::Colorbar& showtickprefix(enum Showtickprefix f);

    // Same as `showtickprefix` but for tick suffixes.
    // - Default: all
    Layout::Coloraxis::Colorbar& showticksuffix(enum Showticksuffix f);

    // Sets the thickness of the color bar This measure excludes the size of the padding, ticks and labels.
    Layout::Coloraxis::Colorbar& thickness(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Coloraxis::Colorbar& thickness(Callable&& c);

    // Determines whether this color bar's thickness (i.e. the measure in the constant color direction) is set in units
    // of plot *fraction* or in *pixels*. Use `thickness` to set the value.
    // - Default: pixels
    Layout::Coloraxis::Colorbar& thicknessmode(enum Thicknessmode f);

    // Sets the placement of the first tick on this axis. Use with `dtick`. If the axis `type` is *log*, then you must
    // take the log of your starting tick (e.g. to set the starting tick to 100, set the `tick0` to 2) except when
    // `dtick`=*L<f>* (see `dtick` for more info). If the axis `type` is *date*, it should be a date string, like date
    // data. If the axis `type` is *category*, it should be a number, using the scale where each category is assigned a
    // serial number from zero in the order it appears.
    template <typename T>
    Layout::Coloraxis::Colorbar& tick0(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Coloraxis::Colorbar& tick0(Callable&& c);

    // Sets the angle of the tick labels with respect to the horizontal. For example, a `tickangle` of -90 draws the
    // tick labels vertically.
    Layout::Coloraxis::Colorbar& tickangle(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Coloraxis::Colorbar& tickangle(Callable&& c);

    // Sets the tick color.
    Layout::Coloraxis::Colorbar& tickcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Coloraxis::Colorbar& tickcolor(Callable&& c);

    // Sets the color bar's tick label font
    Layout::Coloraxis::Colorbar& tickfont(Tickfont f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Tickfont&>>>
    Layout::Coloraxis::Colorbar& tickfont(Callable&& c);

    // Sets the tick label formatting rule using d3 formatting mini-languages which are very similar to those in Python.
    // For numbers, see: https://github.com/d3/d3-format/tree/v1.4.5#d3-format. And for dates see:
    // https://github.com/d3/d3-time-format/tree/v2.2.3#locale_format. We add two items to d3's date formatter: *%h* for
    // half of the year as a decimal number as well as *%{n}f* for fractional seconds with n digits. For example,
    // *2016-10-13 09:15:23.456* with tickformat *%H~%M~%S.%2f* would display *09~15~23.46*
    Layout::Coloraxis::Colorbar& tickformat(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Coloraxis::Colorbar& tickformat(Callable&& c);

    Layout::Coloraxis::Colorbar& tickformatstops(Tickformatstops f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Tickformatstops&>>>
    Layout::Coloraxis::Colorbar& tickformatstops(Callable&& c);

    // Determines how we handle tick labels that would overflow either the graph div or the domain of the axis. The
    // default value for inside tick labels is *hide past domain*. In other cases the default is *hide past div*.
    Layout::Coloraxis::Colorbar& ticklabeloverflow(enum Ticklabeloverflow f);

    // Determines where tick labels are drawn relative to the ticks. Left and right options are used when `orientation`
    // is *h*, top and bottom when `orientation` is *v*.
    // - Default: outside
    Layout::Coloraxis::Colorbar& ticklabelposition(enum Ticklabelposition f);

    // Sets the spacing between tick labels as compared to the spacing between ticks. A value of 1 (default) means each
    // tick gets a label. A value of 2 means shows every 2nd label. A larger value n means only every nth tick is
    // labeled. `tick0` determines which labels are shown. Not implemented for axes with `type` *log* or
    // *multicategory*, or when `tickmode` is *array*.
    Layout::Coloraxis::Colorbar& ticklabelstep(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Coloraxis::Colorbar& ticklabelstep(Callable&& c);

    // Sets the tick length (in px).
    Layout::Coloraxis::Colorbar& ticklen(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Coloraxis::Colorbar& ticklen(Callable&& c);

    // Sets the tick mode for this axis. If *auto*, the number of ticks is set via `nticks`. If *linear*, the placement
    // of the ticks is determined by a starting position `tick0` and a tick step `dtick` (*linear* is the default value
    // if `tick0` and `dtick` are provided). If *array*, the placement of the ticks is set via `tickvals` and the tick
    // text is `ticktext`. (*array* is the default value if `tickvals` is provided).
    Layout::Coloraxis::Colorbar& tickmode(enum Tickmode f);

    // Sets a tick label prefix.
    Layout::Coloraxis::Colorbar& tickprefix(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Coloraxis::Colorbar& tickprefix(Callable&& c);

    // Determines whether ticks are drawn or not. If **, this axis' ticks are not drawn. If *outside* (*inside*), this
    // axis' are drawn outside (inside) the axis lines.
    // - Default:
    Layout::Coloraxis::Colorbar& ticks(enum Ticks f);

    // Sets a tick label suffix.
    Layout::Coloraxis::Colorbar& ticksuffix(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Coloraxis::Colorbar& ticksuffix(Callable&& c);

    // Sets the text displayed at the ticks position via `tickvals`. Only has an effect if `tickmode` is set to *array*.
    // Used with `tickvals`.
    template <typename T, typename = std::enable_if_t<is_data_array_element_v<T>>>
    Layout::Coloraxis::Colorbar& ticktext(const std::vector<T>& f);
    template <
        typename T, typename Callable,
        typename = std::enable_if_t<is_data_array_element_v<T> && (std::is_invocable_v<Callable, std::vector<T>&>)>>
    Layout::Coloraxis::Colorbar& ticktext(Callable&& c);

    // Sets the source reference on Chart Studio Cloud for `ticktext`.
    Layout::Coloraxis::Colorbar& ticktextsrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Coloraxis::Colorbar& ticktextsrc(Callable&& c);

    // Sets the values at which ticks on this axis appear. Only has an effect if `tickmode` is set to *array*. Used with
    // `ticktext`.
    template <typename T, typename = std::enable_if_t<is_data_array_element_v<T>>>
    Layout::Coloraxis::Colorbar& tickvals(const std::vector<T>& f);
    template <
        typename T, typename Callable,
        typename = std::enable_if_t<is_data_array_element_v<T> && (std::is_invocable_v<Callable, std::vector<T>&>)>>
    Layout::Coloraxis::Colorbar& tickvals(Callable&& c);

    // Sets the source reference on Chart Studio Cloud for `tickvals`.
    Layout::Coloraxis::Colorbar& tickvalssrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Coloraxis::Colorbar& tickvalssrc(Callable&& c);

    // Sets the tick width (in px).
    Layout::Coloraxis::Colorbar& tickwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Coloraxis::Colorbar& tickwidth(Callable&& c);

    Layout::Coloraxis::Colorbar& title(Title f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Title&>>>
    Layout::Coloraxis::Colorbar& title(Callable&& c);

    // Sets the x position with respect to `xref` of the color bar (in plot fraction). When `xref` is *paper*, defaults
    // to 1.02 when `orientation` is *v* and 0.5 when `orientation` is *h*. When `xref` is *container*, defaults to *1*
    // when `orientation` is *v* and 0.5 when `orientation` is *h*. Must be between *0* and *1* if `xref` is *container*
    // and between *-2* and *3* if `xref` is *paper*.
    Layout::Coloraxis::Colorbar& x(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Coloraxis::Colorbar& x(Callable&& c);

    // Sets this color bar's horizontal position anchor. This anchor binds the `x` position to the *left*, *center* or
    // *right* of the color bar. Defaults to *left* when `orientation` is *v* and *center* when `orientation` is *h*.
    Layout::Coloraxis::Colorbar& xanchor(enum Xanchor f);

    // Sets the amount of padding (in px) along the x direction.
    Layout::Coloraxis::Colorbar& xpad(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Coloraxis::Colorbar& xpad(Callable&& c);

    // Sets the container `x` refers to. *container* spans the entire `width` of the plot. *paper* refers to the width
    // of the plotting area only.
    // - Default: paper
    Layout::Coloraxis::Colorbar& xref(enum Xref f);

    // Sets the y position with respect to `yref` of the color bar (in plot fraction). When `yref` is *paper*, defaults
    // to 0.5 when `orientation` is *v* and 1.02 when `orientation` is *h*. When `yref` is *container*, defaults to 0.5
    // when `orientation` is *v* and 1 when `orientation` is *h*. Must be between *0* and *1* if `yref` is *container*
    // and between *-2* and *3* if `yref` is *paper*.
    Layout::Coloraxis::Colorbar& y(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Coloraxis::Colorbar& y(Callable&& c);

    // Sets this color bar's vertical position anchor This anchor binds the `y` position to the *top*, *middle* or
    // *bottom* of the color bar. Defaults to *middle* when `orientation` is *v* and *bottom* when `orientation` is *h*.
    Layout::Coloraxis::Colorbar& yanchor(enum Yanchor f);

    // Sets the amount of padding (in px) along the y direction.
    Layout::Coloraxis::Colorbar& ypad(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Coloraxis::Colorbar& ypad(Callable&& c);

    // Sets the container `y` refers to. *container* spans the entire `height` of the plot. *paper* refers to the height
    // of the plotting area only.
    // - Default: paper
    Layout::Coloraxis::Colorbar& yref(enum Yref f);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets the color bar's tick label font
class Layout::Coloraxis::Colorbar::Tickfont {
 public:
    Tickfont() = default;
    Tickfont(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    enum class Textcase {
        Normal,
        WordCaps,
        Upper,
        Lower,
    };
    static std::string to_string(Textcase e);

    enum class Variant {
        Normal,
        SmallCaps,
        AllSmallCaps,
        AllPetiteCaps,
        PetiteCaps,
        Unicase,
    };
    static std::string to_string(Variant e);

    Layout::Coloraxis::Colorbar::Tickfont& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Coloraxis::Colorbar::Tickfont& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Coloraxis::Colorbar::Tickfont& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Coloraxis::Colorbar::Tickfont& family(Callable&& c);

    // Sets the kind of decoration line(s) with text, such as an *under*, *over* or *through* as well as combinations
    // e.g. *under+over*, etc.
    // - Default: none
    // - Flags: ['under', 'over', 'through']
    // - Extras ['none']
    Layout::Coloraxis::Colorbar::Tickfont& lineposition(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Coloraxis::Colorbar::Tickfont& lineposition(Callable&& c);

    // Sets the shape and color of the shadow behind text. *auto* places minimal shadow and applies contrast text font
    // color. See https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow for additional options.
    Layout::Coloraxis::Colorbar::Tickfont& shadow(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Coloraxis::Colorbar::Tickfont& shadow(Callable&& c);

    Layout::Coloraxis::Colorbar::Tickfont& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Coloraxis::Colorbar::Tickfont& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Coloraxis::Colorbar::Tickfont& style(enum Style f);

    // Sets capitalization of text. It can be used to make text appear in all-uppercase or all-lowercase, or with each
    // word capitalized.
    // - Default: normal
    Layout::Coloraxis::Colorbar::Tickfont& textcase(enum Textcase f);

    // Sets the variant of the font.
    // - Default: normal
    Layout::Coloraxis::Colorbar::Tickfont& variant(enum Variant f);

    // Sets the weight (or boldness) of the font.
    Layout::Coloraxis::Colorbar::Tickfont& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Coloraxis::Colorbar::Tickfont& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Coloraxis::Colorbar::Tickformatstops {
 public:
    Tickformatstops() = default;
    Tickformatstops(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    class Tickformatstop;

    Layout::Coloraxis::Colorbar::Tickformatstops& tickformatstop(Tickformatstop f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Tickformatstop&>>>
    Layout::Coloraxis::Colorbar::Tickformatstops& tickformatstop(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Coloraxis::Colorbar::Tickformatstops::Tickformatstop {
 public:
    Tickformatstop() = default;
    Tickformatstop(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // range [*min*, *max*], where *min*, *max* - dtick values which describe some zoom level, it is possible to omit
    // *min* or *max* value by passing *null*
    Layout::Coloraxis::Colorbar::Tickformatstops::Tickformatstop& dtickrange(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Coloraxis::Colorbar::Tickformatstops::Tickformatstop& dtickrange(Callable&& c);

    // Determines whether or not this stop is used. If `false`, this stop is ignored even within its `dtickrange`.
    Layout::Coloraxis::Colorbar::Tickformatstops::Tickformatstop& enabled(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Coloraxis::Colorbar::Tickformatstops::Tickformatstop& enabled(Callable&& c);

    // When used in a template, named items are created in the output figure in addition to any items the figure already
    // has in this array. You can modify these items in the output figure by making your own item with
    // `templateitemname` matching this `name` alongside your modifications (including `visible: false` or `enabled:
    // false` to hide it). Has no effect outside of a template.
    Layout::Coloraxis::Colorbar::Tickformatstops::Tickformatstop& name(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Coloraxis::Colorbar::Tickformatstops::Tickformatstop& name(Callable&& c);

    // Used to refer to a named item in this array in the template. Named items from the template will be created even
    // without a matching item in the input figure, but you can modify one by making an item with `templateitemname`
    // matching its `name`, alongside your modifications (including `visible: false` or `enabled: false` to hide it). If
    // there is no template or no matching item, this item will be hidden unless you explicitly show it with `visible:
    // true`.
    Layout::Coloraxis::Colorbar::Tickformatstops::Tickformatstop& templateitemname(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Coloraxis::Colorbar::Tickformatstops::Tickformatstop& templateitemname(Callable&& c);

    // string - dtickformat for described zoom level, the same as *tickformat*
    Layout::Coloraxis::Colorbar::Tickformatstops::Tickformatstop& value(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Coloraxis::Colorbar::Tickformatstops::Tickformatstop& value(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Coloraxis::Colorbar::Title {
 public:
    Title() = default;
    Title(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Side {
        Right,
        Top,
        Bottom,
    };
    static std::string to_string(Side e);

    // Sets this color bar's title font.
    class Font;

    // Sets this color bar's title font.
    Layout::Coloraxis::Colorbar::Title& font(Font f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Font&>>>
    Layout::Coloraxis::Colorbar::Title& font(Callable&& c);

    // Determines the location of color bar's title with respect to the color bar. Defaults to *top* when `orientation`
    // if *v* and  defaults to *right* when `orientation` if *h*.
    Layout::Coloraxis::Colorbar::Title& side(enum Side f);

    // Sets the title of the color bar.
    Layout::Coloraxis::Colorbar::Title& text(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Coloraxis::Colorbar::Title& text(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets this color bar's title font.
class Layout::Coloraxis::Colorbar::Title::Font {
 public:
    Font() = default;
    Font(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    enum class Textcase {
        Normal,
        WordCaps,
        Upper,
        Lower,
    };
    static std::string to_string(Textcase e);

    enum class Variant {
        Normal,
        SmallCaps,
        AllSmallCaps,
        AllPetiteCaps,
        PetiteCaps,
        Unicase,
    };
    static std::string to_string(Variant e);

    Layout::Coloraxis::Colorbar::Title::Font& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Coloraxis::Colorbar::Title::Font& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Coloraxis::Colorbar::Title::Font& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Coloraxis::Colorbar::Title::Font& family(Callable&& c);

    // Sets the kind of decoration line(s) with text, such as an *under*, *over* or *through* as well as combinations
    // e.g. *under+over*, etc.
    // - Default: none
    // - Flags: ['under', 'over', 'through']
    // - Extras ['none']
    Layout::Coloraxis::Colorbar::Title::Font& lineposition(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Coloraxis::Colorbar::Title::Font& lineposition(Callable&& c);

    // Sets the shape and color of the shadow behind text. *auto* places minimal shadow and applies contrast text font
    // color. See https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow for additional options.
    Layout::Coloraxis::Colorbar::Title::Font& shadow(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Coloraxis::Colorbar::Title::Font& shadow(Callable&& c);

    Layout::Coloraxis::Colorbar::Title::Font& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Coloraxis::Colorbar::Title::Font& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Coloraxis::Colorbar::Title::Font& style(enum Style f);

    // Sets capitalization of text. It can be used to make text appear in all-uppercase or all-lowercase, or with each
    // word capitalized.
    // - Default: normal
    Layout::Coloraxis::Colorbar::Title::Font& textcase(enum Textcase f);

    // Sets the variant of the font.
    // - Default: normal
    Layout::Coloraxis::Colorbar::Title::Font& variant(enum Variant f);

    // Sets the weight (or boldness) of the font.
    Layout::Coloraxis::Colorbar::Title::Font& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Coloraxis::Colorbar::Title::Font& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Colorscale {
 public:
    Colorscale() = default;
    Colorscale(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Sets the default diverging colorscale. Note that `autocolorscale` must be true for this attribute to work.
    Layout::Colorscale& diverging(std::string f);
    Layout::Colorscale& diverging(const std::vector<std::pair<double, std::string>>& f);
    template <typename Callable,
              typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&> ||
                                          std::is_invocable_v<Callable, std::vector<std::pair<double, std::string>>&>>>
    Layout::Colorscale& diverging(Callable&& c);

    // Sets the default sequential colorscale for positive values. Note that `autocolorscale` must be true for this
    // attribute to work.
    Layout::Colorscale& sequential(std::string f);
    Layout::Colorscale& sequential(const std::vector<std::pair<double, std::string>>& f);
    template <typename Callable,
              typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&> ||
                                          std::is_invocable_v<Callable, std::vector<std::pair<double, std::string>>&>>>
    Layout::Colorscale& sequential(Callable&& c);

    // Sets the default sequential colorscale for negative values. Note that `autocolorscale` must be true for this
    // attribute to work.
    Layout::Colorscale& sequentialminus(std::string f);
    Layout::Colorscale& sequentialminus(const std::vector<std::pair<double, std::string>>& f);
    template <typename Callable,
              typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&> ||
                                          std::is_invocable_v<Callable, std::vector<std::pair<double, std::string>>&>>>
    Layout::Colorscale& sequentialminus(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets the global font. Note that fonts used in traces and other layout components inherit from the global font.
class Layout::Font {
 public:
    Font() = default;
    Font(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    enum class Textcase {
        Normal,
        WordCaps,
        Upper,
        Lower,
    };
    static std::string to_string(Textcase e);

    enum class Variant {
        Normal,
        SmallCaps,
        AllSmallCaps,
        AllPetiteCaps,
        PetiteCaps,
        Unicase,
    };
    static std::string to_string(Variant e);

    Layout::Font& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Font& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Font& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Font& family(Callable&& c);

    // Sets the kind of decoration line(s) with text, such as an *under*, *over* or *through* as well as combinations
    // e.g. *under+over*, etc.
    // - Default: none
    // - Flags: ['under', 'over', 'through']
    // - Extras ['none']
    Layout::Font& lineposition(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Font& lineposition(Callable&& c);

    // Sets the shape and color of the shadow behind text. *auto* places minimal shadow and applies contrast text font
    // color. See https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow for additional options.
    Layout::Font& shadow(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Font& shadow(Callable&& c);

    Layout::Font& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Font& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Font& style(enum Style f);

    // Sets capitalization of text. It can be used to make text appear in all-uppercase or all-lowercase, or with each
    // word capitalized.
    // - Default: normal
    Layout::Font& textcase(enum Textcase f);

    // Sets the variant of the font.
    // - Default: normal
    Layout::Font& variant(enum Variant f);

    // Sets the weight (or boldness) of the font.
    Layout::Font& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Font& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Geo {
 public:
    Geo() = default;
    Geo(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Fitbounds {
        False,
        Locations,
        Geojson,
    };
    static std::string to_string(Fitbounds e);

    enum class Resolution {
        Num_110,
        Num_50,
    };
    static std::string to_string(Resolution e);

    enum class Scope {
        Africa,
        Asia,
        Europe,
        NorthAmerica,
        SouthAmerica,
        Usa,
        World,
    };
    static std::string to_string(Scope e);

    class Center;
    class Domain;
    class Lataxis;
    class Lonaxis;
    class Projection;

    // Set the background color of the map
    Layout::Geo& bgcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Geo& bgcolor(Callable&& c);

    Layout::Geo& center(Center f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Center&>>>
    Layout::Geo& center(Callable&& c);

    // Sets the coastline color.
    Layout::Geo& coastlinecolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Geo& coastlinecolor(Callable&& c);

    // Sets the coastline stroke width (in px).
    Layout::Geo& coastlinewidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Geo& coastlinewidth(Callable&& c);

    // Sets line color of the country boundaries.
    Layout::Geo& countrycolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Geo& countrycolor(Callable&& c);

    // Sets line width (in px) of the country boundaries.
    Layout::Geo& countrywidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Geo& countrywidth(Callable&& c);

    Layout::Geo& domain(Domain f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Domain&>>>
    Layout::Geo& domain(Callable&& c);

    // Determines if this subplot's view settings are auto-computed to fit trace data. On scoped maps, setting
    // `fitbounds` leads to `center.lon` and `center.lat` getting auto-filled. On maps with a non-clipped projection,
    // setting `fitbounds` leads to `center.lon`, `center.lat`, and `projection.rotation.lon` getting auto-filled. On
    // maps with a clipped projection, setting `fitbounds` leads to `center.lon`, `center.lat`,
    // `projection.rotation.lon`, `projection.rotation.lat`, `lonaxis.range` and `lataxis.range` getting auto-filled. If
    // *locations*, only the trace's visible locations are considered in the `fitbounds` computations. If *geojson*, the
    // entire trace input `geojson` (if provided) is considered in the `fitbounds` computations, Defaults to *false*.
    // - Default: False
    Layout::Geo& fitbounds(enum Fitbounds f);

    // Sets the color the frame.
    Layout::Geo& framecolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Geo& framecolor(Callable&& c);

    // Sets the stroke width (in px) of the frame.
    Layout::Geo& framewidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Geo& framewidth(Callable&& c);

    // Sets the color of the lakes.
    Layout::Geo& lakecolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Geo& lakecolor(Callable&& c);

    // Sets the land mass color.
    Layout::Geo& landcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Geo& landcolor(Callable&& c);

    Layout::Geo& lataxis(Lataxis f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Lataxis&>>>
    Layout::Geo& lataxis(Callable&& c);

    Layout::Geo& lonaxis(Lonaxis f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Lonaxis&>>>
    Layout::Geo& lonaxis(Callable&& c);

    // Sets the ocean color
    Layout::Geo& oceancolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Geo& oceancolor(Callable&& c);

    Layout::Geo& projection(Projection f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Projection&>>>
    Layout::Geo& projection(Callable&& c);

    // Sets the resolution of the base layers. The values have units of km/mm e.g. 110 corresponds to a scale ratio of
    // 1:110,000,000.
    // - Default: 110
    Layout::Geo& resolution(enum Resolution f);

    // Sets color of the rivers.
    Layout::Geo& rivercolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Geo& rivercolor(Callable&& c);

    // Sets the stroke width (in px) of the rivers.
    Layout::Geo& riverwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Geo& riverwidth(Callable&& c);

    // Set the scope of the map.
    // - Default: world
    Layout::Geo& scope(enum Scope f);

    // Sets whether or not the coastlines are drawn.
    Layout::Geo& showcoastlines(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Geo& showcoastlines(Callable&& c);

    // Sets whether or not country boundaries are drawn.
    Layout::Geo& showcountries(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Geo& showcountries(Callable&& c);

    // Sets whether or not a frame is drawn around the map.
    Layout::Geo& showframe(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Geo& showframe(Callable&& c);

    // Sets whether or not lakes are drawn.
    Layout::Geo& showlakes(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Geo& showlakes(Callable&& c);

    // Sets whether or not land masses are filled in color.
    Layout::Geo& showland(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Geo& showland(Callable&& c);

    // Sets whether or not oceans are filled in color.
    Layout::Geo& showocean(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Geo& showocean(Callable&& c);

    // Sets whether or not rivers are drawn.
    Layout::Geo& showrivers(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Geo& showrivers(Callable&& c);

    // Sets whether or not boundaries of subunits within countries (e.g. states, provinces) are drawn.
    Layout::Geo& showsubunits(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Geo& showsubunits(Callable&& c);

    // Sets the color of the subunits boundaries.
    Layout::Geo& subunitcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Geo& subunitcolor(Callable&& c);

    // Sets the stroke width (in px) of the subunits boundaries.
    Layout::Geo& subunitwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Geo& subunitwidth(Callable&& c);

    // Controls persistence of user-driven changes in the view (projection and center). Defaults to `layout.uirevision`.
    template <typename T>
    Layout::Geo& uirevision(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Geo& uirevision(Callable&& c);

    // Sets the default visibility of the base layers.
    Layout::Geo& visible(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Geo& visible(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Geo::Center {
 public:
    Center() = default;
    Center(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Sets the latitude of the map's center. For all projection types, the map's latitude center lies at the middle of
    // the latitude range by default.
    Layout::Geo::Center& lat(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Geo::Center& lat(Callable&& c);

    // Sets the longitude of the map's center. By default, the map's longitude center lies at the middle of the
    // longitude range for scoped projection and above `projection.rotation.lon` otherwise.
    Layout::Geo::Center& lon(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Geo::Center& lon(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Geo::Domain {
 public:
    Domain() = default;
    Domain(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // If there is a layout grid, use the domain for this column in the grid for this geo subplot . Note that geo
    // subplots are constrained by domain. In general, when `projection.scale` is set to 1. a map will fit either its x
    // or y domain, but not both.
    Layout::Geo::Domain& column(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Geo::Domain& column(Callable&& c);

    // If there is a layout grid, use the domain for this row in the grid for this geo subplot . Note that geo subplots
    // are constrained by domain. In general, when `projection.scale` is set to 1. a map will fit either its x or y
    // domain, but not both.
    Layout::Geo::Domain& row(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Geo::Domain& row(Callable&& c);

    // Sets the horizontal domain of this geo subplot (in plot fraction). Note that geo subplots are constrained by
    // domain. In general, when `projection.scale` is set to 1. a map will fit either its x or y domain, but not both.
    Layout::Geo::Domain& x(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Geo::Domain& x(Callable&& c);

    // Sets the vertical domain of this geo subplot (in plot fraction). Note that geo subplots are constrained by
    // domain. In general, when `projection.scale` is set to 1. a map will fit either its x or y domain, but not both.
    Layout::Geo::Domain& y(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Geo::Domain& y(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Geo::Lataxis {
 public:
    Lataxis() = default;
    Lataxis(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Sets the graticule's longitude/latitude tick step.
    Layout::Geo::Lataxis& dtick(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Geo::Lataxis& dtick(Callable&& c);

    // Sets the graticule's stroke color.
    Layout::Geo::Lataxis& gridcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Geo::Lataxis& gridcolor(Callable&& c);

    // Sets the dash style of lines. Set to a dash type string (*solid*, *dot*, *dash*, *longdash*, *dashdot*, or
    // *longdashdot*) or a dash length list in px (eg *5px,10px,2px,2px*).
    Layout::Geo::Lataxis& griddash(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Geo::Lataxis& griddash(Callable&& c);

    // Sets the graticule's stroke width (in px).
    Layout::Geo::Lataxis& gridwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Geo::Lataxis& gridwidth(Callable&& c);

    // Sets the range of this axis (in degrees), sets the map's clipped coordinates.
    Layout::Geo::Lataxis& range(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Geo::Lataxis& range(Callable&& c);

    // Sets whether or not graticule are shown on the map.
    Layout::Geo::Lataxis& showgrid(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Geo::Lataxis& showgrid(Callable&& c);

    // Sets the graticule's starting tick longitude/latitude.
    Layout::Geo::Lataxis& tick0(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Geo::Lataxis& tick0(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Geo::Lonaxis {
 public:
    Lonaxis() = default;
    Lonaxis(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Sets the graticule's longitude/latitude tick step.
    Layout::Geo::Lonaxis& dtick(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Geo::Lonaxis& dtick(Callable&& c);

    // Sets the graticule's stroke color.
    Layout::Geo::Lonaxis& gridcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Geo::Lonaxis& gridcolor(Callable&& c);

    // Sets the dash style of lines. Set to a dash type string (*solid*, *dot*, *dash*, *longdash*, *dashdot*, or
    // *longdashdot*) or a dash length list in px (eg *5px,10px,2px,2px*).
    Layout::Geo::Lonaxis& griddash(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Geo::Lonaxis& griddash(Callable&& c);

    // Sets the graticule's stroke width (in px).
    Layout::Geo::Lonaxis& gridwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Geo::Lonaxis& gridwidth(Callable&& c);

    // Sets the range of this axis (in degrees), sets the map's clipped coordinates.
    Layout::Geo::Lonaxis& range(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Geo::Lonaxis& range(Callable&& c);

    // Sets whether or not graticule are shown on the map.
    Layout::Geo::Lonaxis& showgrid(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Geo::Lonaxis& showgrid(Callable&& c);

    // Sets the graticule's starting tick longitude/latitude.
    Layout::Geo::Lonaxis& tick0(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Geo::Lonaxis& tick0(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Geo::Projection {
 public:
    Projection() = default;
    Projection(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Type {
        Airy,
        Aitoff,
        Albers,
        AlbersUsa,
        August,
        AzimuthalEqualArea,
        AzimuthalEquidistant,
        Baker,
        Bertin1953,
        Boggs,
        Bonne,
        Bottomley,
        Bromley,
        Collignon,
        ConicConformal,
        ConicEqualArea,
        ConicEquidistant,
        Craig,
        Craster,
        CylindricalEqualArea,
        CylindricalStereographic,
        Eckert1,
        Eckert2,
        Eckert3,
        Eckert4,
        Eckert5,
        Eckert6,
        Eisenlohr,
        EqualEarth,
        Equirectangular,
        Fahey,
        Foucaut,
        FoucautSinusoidal,
        Ginzburg4,
        Ginzburg5,
        Ginzburg6,
        Ginzburg8,
        Ginzburg9,
        Gnomonic,
        Gringorten,
        GringortenQuincuncial,
        Guyou,
        Hammer,
        Hill,
        Homolosine,
        Hufnagel,
        Hyperelliptical,
        Kavrayskiy7,
        Lagrange,
        Larrivee,
        Laskowski,
        Loximuthal,
        Mercator,
        Miller,
        Mollweide,
        MtFlatPolarParabolic,
        MtFlatPolarQuartic,
        MtFlatPolarSinusoidal,
        NaturalEarth,
        NaturalEarth1,
        NaturalEarth2,
        NellHammer,
        Nicolosi,
        Orthographic,
        Patterson,
        PeirceQuincuncial,
        Polyconic,
        RectangularPolyconic,
        Robinson,
        Satellite,
        SinuMollweide,
        Sinusoidal,
        Stereographic,
        Times,
        TransverseMercator,
        VanDerGrinten,
        VanDerGrinten2,
        VanDerGrinten3,
        VanDerGrinten4,
        Wagner4,
        Wagner6,
        Wiechel,
        WinkelTripel,
        Winkel3,
    };
    static std::string to_string(Type e);

    class Rotation;

    // For satellite projection type only. Sets the distance from the center of the sphere to the point of view as a
    // proportion of the spheres radius.
    Layout::Geo::Projection& distance(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Geo::Projection& distance(Callable&& c);

    // For conic projection types only. Sets the parallels (tangent, secant) where the cone intersects the sphere.
    Layout::Geo::Projection& parallels(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Geo::Projection& parallels(Callable&& c);

    Layout::Geo::Projection& rotation(Rotation f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Rotation&>>>
    Layout::Geo::Projection& rotation(Callable&& c);

    // Zooms in or out on the map view. A scale of *1* corresponds to the largest zoom level that fits the map's lon and
    // lat ranges.
    Layout::Geo::Projection& scale(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Geo::Projection& scale(Callable&& c);

    // For satellite projection type only. Sets the tilt angle of perspective projection.
    Layout::Geo::Projection& tilt(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Geo::Projection& tilt(Callable&& c);

    // Sets the projection type.
    Layout::Geo::Projection& type(enum Type f);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Geo::Projection::Rotation {
 public:
    Rotation() = default;
    Rotation(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Rotates the map along meridians (in degrees North).
    Layout::Geo::Projection::Rotation& lat(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Geo::Projection::Rotation& lat(Callable&& c);

    // Rotates the map along parallels (in degrees East). Defaults to the center of the `lonaxis.range` values.
    Layout::Geo::Projection::Rotation& lon(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Geo::Projection::Rotation& lon(Callable&& c);

    // Roll the map (in degrees) For example, a roll of *180* makes the map appear upside down.
    Layout::Geo::Projection::Rotation& roll(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Geo::Projection::Rotation& roll(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Grid {
 public:
    Grid() = default;
    Grid(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Pattern {
        Independent,
        Coupled,
    };
    static std::string to_string(Pattern e);

    enum class Roworder {
        TopToBottom,
        BottomToTop,
    };
    static std::string to_string(Roworder e);

    enum class Xside {
        Bottom,
        BottomPlot,
        TopPlot,
        Top,
    };
    static std::string to_string(Xside e);

    enum class Yside {
        Left,
        LeftPlot,
        RightPlot,
        Right,
    };
    static std::string to_string(Yside e);

    class Domain;

    // The number of columns in the grid. If you provide a 2D `subplots` array, the length of its longest row is used as
    // the default. If you give an `xaxes` array, its length is used as the default. But it's also possible to have a
    // different length, if you want to leave a row at the end for non-cartesian subplots.
    Layout::Grid& columns(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Grid& columns(Callable&& c);

    Layout::Grid& domain(Domain f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Domain&>>>
    Layout::Grid& domain(Callable&& c);

    // If no `subplots`, `xaxes`, or `yaxes` are given but we do have `rows` and `columns`, we can generate defaults
    // using consecutive axis IDs, in two ways: *coupled* gives one x axis per column and one y axis per row.
    // *independent* uses a new xy pair for each cell, left-to-right across each row then iterating rows according to
    // `roworder`.
    // - Default: coupled
    Layout::Grid& pattern(enum Pattern f);

    // Is the first row the top or the bottom? Note that columns are always enumerated from left to right.
    // - Default: top to bottom
    Layout::Grid& roworder(enum Roworder f);

    // The number of rows in the grid. If you provide a 2D `subplots` array or a `yaxes` array, its length is used as
    // the default. But it's also possible to have a different length, if you want to leave a row at the end for
    // non-cartesian subplots.
    Layout::Grid& rows(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Grid& rows(Callable&& c);

    // Used for freeform grids, where some axes may be shared across subplots but others are not. Each entry should be a
    // cartesian subplot id, like *xy* or *x3y2*, or ** to leave that cell empty. You may reuse x axes within the same
    // column, and y axes within the same row. Non-cartesian subplots and traces that support `domain` can place
    // themselves in this grid separately using the `gridcell` attribute.
    Layout::Grid& subplots(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Grid& subplots(Callable&& c);

    // Used with `yaxes` when the x and y axes are shared across columns and rows. Each entry should be an x axis id
    // like *x*, *x2*, etc., or ** to not put an x axis in that column. Entries other than ** must be unique. Ignored if
    // `subplots` is present. If missing but `yaxes` is present, will generate consecutive IDs.
    Layout::Grid& xaxes(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Grid& xaxes(Callable&& c);

    // Horizontal space between grid cells, expressed as a fraction of the total width available to one cell. Defaults
    // to 0.1 for coupled-axes grids and 0.2 for independent grids.
    Layout::Grid& xgap(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Grid& xgap(Callable&& c);

    // Sets where the x axis labels and titles go. *bottom* means the very bottom of the grid. *bottom plot* is the
    // lowest plot that each x axis is used in. *top* and *top plot* are similar.
    // - Default: bottom plot
    Layout::Grid& xside(enum Xside f);

    // Used with `yaxes` when the x and y axes are shared across columns and rows. Each entry should be an y axis id
    // like *y*, *y2*, etc., or ** to not put a y axis in that row. Entries other than ** must be unique. Ignored if
    // `subplots` is present. If missing but `xaxes` is present, will generate consecutive IDs.
    Layout::Grid& yaxes(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Grid& yaxes(Callable&& c);

    // Vertical space between grid cells, expressed as a fraction of the total height available to one cell. Defaults to
    // 0.1 for coupled-axes grids and 0.3 for independent grids.
    Layout::Grid& ygap(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Grid& ygap(Callable&& c);

    // Sets where the y axis labels and titles go. *left* means the very left edge of the grid. *left plot* is the
    // leftmost plot that each y axis is used in. *right* and *right plot* are similar.
    // - Default: left plot
    Layout::Grid& yside(enum Yside f);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Grid::Domain {
 public:
    Domain() = default;
    Domain(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Sets the horizontal domain of this grid subplot (in plot fraction). The first and last cells end exactly at the
    // domain edges, with no grout around the edges.
    Layout::Grid::Domain& x(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Grid::Domain& x(Callable&& c);

    // Sets the vertical domain of this grid subplot (in plot fraction). The first and last cells end exactly at the
    // domain edges, with no grout around the edges.
    Layout::Grid::Domain& y(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Grid::Domain& y(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Hoverlabel {
 public:
    Hoverlabel() = default;
    Hoverlabel(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Align {
        Left,
        Right,
        Auto,
    };
    static std::string to_string(Align e);

    // Sets the default hover label font used by all traces on the graph.
    class Font;
    // Sets the font for group titles in hover (unified modes). Defaults to `hoverlabel.font`.
    class Grouptitlefont;

    // Sets the horizontal alignment of the text content within hover label box. Has an effect only if the hover label
    // text spans more two or more lines
    // - Default: auto
    Layout::Hoverlabel& align(enum Align f);

    // Sets the background color of all hover labels on graph
    Layout::Hoverlabel& bgcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Hoverlabel& bgcolor(Callable&& c);

    // Sets the border color of all hover labels on graph.
    Layout::Hoverlabel& bordercolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Hoverlabel& bordercolor(Callable&& c);

    // Sets the default hover label font used by all traces on the graph.
    Layout::Hoverlabel& font(Font f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Font&>>>
    Layout::Hoverlabel& font(Callable&& c);

    // Sets the font for group titles in hover (unified modes). Defaults to `hoverlabel.font`.
    Layout::Hoverlabel& grouptitlefont(Grouptitlefont f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Grouptitlefont&>>>
    Layout::Hoverlabel& grouptitlefont(Callable&& c);

    // Sets the default length (in number of characters) of the trace name in the hover labels for all traces. -1 shows
    // the whole name regardless of length. 0-3 shows the first 0-3 characters, and an integer >3 will show the whole
    // name if it is less than that many characters, but if it is longer, will truncate to `namelength - 3` characters
    // and add an ellipsis.
    Layout::Hoverlabel& namelength(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Hoverlabel& namelength(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets the default hover label font used by all traces on the graph.
class Layout::Hoverlabel::Font {
 public:
    Font() = default;
    Font(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    enum class Textcase {
        Normal,
        WordCaps,
        Upper,
        Lower,
    };
    static std::string to_string(Textcase e);

    enum class Variant {
        Normal,
        SmallCaps,
        AllSmallCaps,
        AllPetiteCaps,
        PetiteCaps,
        Unicase,
    };
    static std::string to_string(Variant e);

    Layout::Hoverlabel::Font& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Hoverlabel::Font& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Hoverlabel::Font& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Hoverlabel::Font& family(Callable&& c);

    // Sets the kind of decoration line(s) with text, such as an *under*, *over* or *through* as well as combinations
    // e.g. *under+over*, etc.
    // - Default: none
    // - Flags: ['under', 'over', 'through']
    // - Extras ['none']
    Layout::Hoverlabel::Font& lineposition(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Hoverlabel::Font& lineposition(Callable&& c);

    // Sets the shape and color of the shadow behind text. *auto* places minimal shadow and applies contrast text font
    // color. See https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow for additional options.
    Layout::Hoverlabel::Font& shadow(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Hoverlabel::Font& shadow(Callable&& c);

    Layout::Hoverlabel::Font& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Hoverlabel::Font& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Hoverlabel::Font& style(enum Style f);

    // Sets capitalization of text. It can be used to make text appear in all-uppercase or all-lowercase, or with each
    // word capitalized.
    // - Default: normal
    Layout::Hoverlabel::Font& textcase(enum Textcase f);

    // Sets the variant of the font.
    // - Default: normal
    Layout::Hoverlabel::Font& variant(enum Variant f);

    // Sets the weight (or boldness) of the font.
    Layout::Hoverlabel::Font& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Hoverlabel::Font& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets the font for group titles in hover (unified modes). Defaults to `hoverlabel.font`.
class Layout::Hoverlabel::Grouptitlefont {
 public:
    Grouptitlefont() = default;
    Grouptitlefont(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    enum class Textcase {
        Normal,
        WordCaps,
        Upper,
        Lower,
    };
    static std::string to_string(Textcase e);

    enum class Variant {
        Normal,
        SmallCaps,
        AllSmallCaps,
        AllPetiteCaps,
        PetiteCaps,
        Unicase,
    };
    static std::string to_string(Variant e);

    Layout::Hoverlabel::Grouptitlefont& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Hoverlabel::Grouptitlefont& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Hoverlabel::Grouptitlefont& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Hoverlabel::Grouptitlefont& family(Callable&& c);

    // Sets the kind of decoration line(s) with text, such as an *under*, *over* or *through* as well as combinations
    // e.g. *under+over*, etc.
    // - Default: none
    // - Flags: ['under', 'over', 'through']
    // - Extras ['none']
    Layout::Hoverlabel::Grouptitlefont& lineposition(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Hoverlabel::Grouptitlefont& lineposition(Callable&& c);

    // Sets the shape and color of the shadow behind text. *auto* places minimal shadow and applies contrast text font
    // color. See https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow for additional options.
    Layout::Hoverlabel::Grouptitlefont& shadow(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Hoverlabel::Grouptitlefont& shadow(Callable&& c);

    Layout::Hoverlabel::Grouptitlefont& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Hoverlabel::Grouptitlefont& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Hoverlabel::Grouptitlefont& style(enum Style f);

    // Sets capitalization of text. It can be used to make text appear in all-uppercase or all-lowercase, or with each
    // word capitalized.
    // - Default: normal
    Layout::Hoverlabel::Grouptitlefont& textcase(enum Textcase f);

    // Sets the variant of the font.
    // - Default: normal
    Layout::Hoverlabel::Grouptitlefont& variant(enum Variant f);

    // Sets the weight (or boldness) of the font.
    Layout::Hoverlabel::Grouptitlefont& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Hoverlabel::Grouptitlefont& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Images {
 public:
    Images() = default;
    Images(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    class Image;

    Layout::Images& image(Image f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Image&>>>
    Layout::Images& image(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Images::Image {
 public:
    Image() = default;
    Image(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Layer {
        Below,
        Above,
    };
    static std::string to_string(Layer e);

    enum class Sizing {
        Fill,
        Contain,
        Stretch,
    };
    static std::string to_string(Sizing e);

    enum class Xanchor {
        Left,
        Center,
        Right,
    };
    static std::string to_string(Xanchor e);

    enum class Yanchor {
        Top,
        Middle,
        Bottom,
    };
    static std::string to_string(Yanchor e);

    // Specifies whether images are drawn below or above traces. When `xref` and `yref` are both set to `paper`, image
    // is drawn below the entire plot area.
    // - Default: above
    Layout::Images::Image& layer(enum Layer f);

    // When used in a template, named items are created in the output figure in addition to any items the figure already
    // has in this array. You can modify these items in the output figure by making your own item with
    // `templateitemname` matching this `name` alongside your modifications (including `visible: false` or `enabled:
    // false` to hide it). Has no effect outside of a template.
    Layout::Images::Image& name(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Images::Image& name(Callable&& c);

    // Sets the opacity of the image.
    Layout::Images::Image& opacity(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Images::Image& opacity(Callable&& c);

    // Sets the image container size horizontally. The image will be sized based on the `position` value. When `xref` is
    // set to `paper`, units are sized relative to the plot width. When `xref` ends with ` domain`, units are sized
    // relative to the axis width.
    Layout::Images::Image& sizex(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Images::Image& sizex(Callable&& c);

    // Sets the image container size vertically. The image will be sized based on the `position` value. When `yref` is
    // set to `paper`, units are sized relative to the plot height. When `yref` ends with ` domain`, units are sized
    // relative to the axis height.
    Layout::Images::Image& sizey(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Images::Image& sizey(Callable&& c);

    // Specifies which dimension of the image to constrain.
    // - Default: contain
    Layout::Images::Image& sizing(enum Sizing f);

    // Specifies the URL of the image to be used. The URL must be accessible from the domain where the plot code is run,
    // and can be either relative or absolute.
    Layout::Images::Image& source(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Images::Image& source(Callable&& c);

    // Used to refer to a named item in this array in the template. Named items from the template will be created even
    // without a matching item in the input figure, but you can modify one by making an item with `templateitemname`
    // matching its `name`, alongside your modifications (including `visible: false` or `enabled: false` to hide it). If
    // there is no template or no matching item, this item will be hidden unless you explicitly show it with `visible:
    // true`.
    Layout::Images::Image& templateitemname(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Images::Image& templateitemname(Callable&& c);

    // Determines whether or not this image is visible.
    Layout::Images::Image& visible(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Images::Image& visible(Callable&& c);

    // Sets the image's x position. When `xref` is set to `paper`, units are sized relative to the plot height. See
    // `xref` for more info
    template <typename T>
    Layout::Images::Image& x(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Images::Image& x(Callable&& c);

    // Sets the anchor for the x position
    // - Default: left
    Layout::Images::Image& xanchor(enum Xanchor f);

    // Sets the images's x coordinate axis. If set to a x axis id (e.g. *x* or *x2*), the `x` position refers to a x
    // coordinate. If set to *paper*, the `x` position refers to the distance from the left of the plotting area in
    // normalized coordinates where *0* (*1*) corresponds to the left (right). If set to a x axis ID followed by
    // *domain* (separated by a space), the position behaves like for *paper*, but refers to the distance in fractions
    // of the domain length from the left of the domain of that axis: e.g., *x2 domain* refers to the domain of the
    // second x  axis and a x position of 0.5 refers to the point between the left and the right of the domain of the
    // second x axis.
    Layout::Images::Image& xref(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Images::Image& xref(Callable&& c);

    // Sets the image's y position. When `yref` is set to `paper`, units are sized relative to the plot height. See
    // `yref` for more info
    template <typename T>
    Layout::Images::Image& y(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Images::Image& y(Callable&& c);

    // Sets the anchor for the y position.
    // - Default: top
    Layout::Images::Image& yanchor(enum Yanchor f);

    // Sets the images's y coordinate axis. If set to a y axis id (e.g. *y* or *y2*), the `y` position refers to a y
    // coordinate. If set to *paper*, the `y` position refers to the distance from the bottom of the plotting area in
    // normalized coordinates where *0* (*1*) corresponds to the bottom (top). If set to a y axis ID followed by
    // *domain* (separated by a space), the position behaves like for *paper*, but refers to the distance in fractions
    // of the domain length from the bottom of the domain of that axis: e.g., *y2 domain* refers to the domain of the
    // second y  axis and a y position of 0.5 refers to the point between the bottom and the top of the domain of the
    // second y axis.
    Layout::Images::Image& yref(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Images::Image& yref(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Legend {
 public:
    Legend() = default;
    Legend(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Entrywidthmode {
        Fraction,
        Pixels,
    };
    static std::string to_string(Entrywidthmode e);

    enum class Groupclick {
        Toggleitem,
        Togglegroup,
    };
    static std::string to_string(Groupclick e);

    enum class Itemclick {
        Toggle,
        Toggleothers,
        False,
    };
    static std::string to_string(Itemclick e);

    enum class Itemdoubleclick {
        Toggle,
        Toggleothers,
        False,
    };
    static std::string to_string(Itemdoubleclick e);

    enum class Itemsizing {
        Trace,
        Constant,
    };
    static std::string to_string(Itemsizing e);

    enum class Orientation {
        V,
        H,
    };
    static std::string to_string(Orientation e);

    enum class Valign {
        Top,
        Middle,
        Bottom,
    };
    static std::string to_string(Valign e);

    enum class Xanchor {
        Auto,
        Left,
        Center,
        Right,
    };
    static std::string to_string(Xanchor e);

    enum class Xref {
        Container,
        Paper,
    };
    static std::string to_string(Xref e);

    enum class Yanchor {
        Auto,
        Top,
        Middle,
        Bottom,
    };
    static std::string to_string(Yanchor e);

    enum class Yref {
        Container,
        Paper,
    };
    static std::string to_string(Yref e);

    // Sets the font used to text the legend items.
    class Font;
    // Sets the font for group titles in legend. Defaults to `legend.font` with its size increased about 10%.
    class Grouptitlefont;
    class Title;

    // Sets the legend background color. Defaults to `layout.paper_bgcolor`.
    Layout::Legend& bgcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Legend& bgcolor(Callable&& c);

    // Sets the color of the border enclosing the legend.
    Layout::Legend& bordercolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Legend& bordercolor(Callable&& c);

    // Sets the width (in px) of the border enclosing the legend.
    Layout::Legend& borderwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Legend& borderwidth(Callable&& c);

    // Sets the width (in px or fraction) of the legend. Use 0 to size the entry based on the text width, when
    // `entrywidthmode` is set to *pixels*.
    Layout::Legend& entrywidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Legend& entrywidth(Callable&& c);

    // Determines what entrywidth means.
    // - Default: pixels
    Layout::Legend& entrywidthmode(enum Entrywidthmode f);

    // Sets the font used to text the legend items.
    Layout::Legend& font(Font f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Font&>>>
    Layout::Legend& font(Callable&& c);

    // Determines the behavior on legend group item click. *toggleitem* toggles the visibility of the individual item
    // clicked on the graph. *togglegroup* toggles the visibility of all items in the same legendgroup as the item
    // clicked on the graph.
    // - Default: togglegroup
    Layout::Legend& groupclick(enum Groupclick f);

    // Sets the font for group titles in legend. Defaults to `legend.font` with its size increased about 10%.
    Layout::Legend& grouptitlefont(Grouptitlefont f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Grouptitlefont&>>>
    Layout::Legend& grouptitlefont(Callable&& c);

    // Sets the indentation (in px) of the legend entries.
    Layout::Legend& indentation(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Legend& indentation(Callable&& c);

    // Determines the behavior on legend item click. *toggle* toggles the visibility of the item clicked on the graph.
    // *toggleothers* makes the clicked item the sole visible item on the graph. *false* disables legend item click
    // interactions.
    // - Default: toggle
    Layout::Legend& itemclick(enum Itemclick f);

    // Determines the behavior on legend item double-click. *toggle* toggles the visibility of the item clicked on the
    // graph. *toggleothers* makes the clicked item the sole visible item on the graph. *false* disables legend item
    // double-click interactions.
    // - Default: toggleothers
    Layout::Legend& itemdoubleclick(enum Itemdoubleclick f);

    // Determines if the legend items symbols scale with their corresponding *trace* attributes or remain *constant*
    // independent of the symbol size on the graph.
    // - Default: trace
    Layout::Legend& itemsizing(enum Itemsizing f);

    // Sets the width (in px) of the legend item symbols (the part other than the title.text).
    Layout::Legend& itemwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Legend& itemwidth(Callable&& c);

    // Sets the orientation of the legend.
    // - Default: v
    Layout::Legend& orientation(enum Orientation f);

    Layout::Legend& title(Title f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Title&>>>
    Layout::Legend& title(Callable&& c);

    // Sets the amount of vertical space (in px) between legend groups.
    Layout::Legend& tracegroupgap(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Legend& tracegroupgap(Callable&& c);

    // Determines the order at which the legend items are displayed. If *normal*, the items are displayed top-to-bottom
    // in the same order as the input data. If *reversed*, the items are displayed in the opposite order as *normal*. If
    // *grouped*, the items are displayed in groups (when a trace `legendgroup` is provided). if *grouped+reversed*, the
    // items are displayed in the opposite order as *grouped*.
    // - Flags: ['reversed', 'grouped']
    // - Extras ['normal']
    Layout::Legend& traceorder(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Legend& traceorder(Callable&& c);

    // Controls persistence of legend-driven changes in trace and pie label visibility. Defaults to `layout.uirevision`.
    template <typename T>
    Layout::Legend& uirevision(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Legend& uirevision(Callable&& c);

    // Sets the vertical alignment of the symbols with respect to their associated text.
    // - Default: middle
    Layout::Legend& valign(enum Valign f);

    // Determines whether or not this legend is visible.
    Layout::Legend& visible(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Legend& visible(Callable&& c);

    // Sets the x position with respect to `xref` (in normalized coordinates) of the legend. When `xref` is *paper*,
    // defaults to *1.02* for vertical legends and defaults to *0* for horizontal legends. When `xref` is *container*,
    // defaults to *1* for vertical legends and defaults to *0* for horizontal legends. Must be between *0* and *1* if
    // `xref` is *container*. and between *-2* and *3* if `xref` is *paper*.
    Layout::Legend& x(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Legend& x(Callable&& c);

    // Sets the legend's horizontal position anchor. This anchor binds the `x` position to the *left*, *center* or
    // *right* of the legend. Value *auto* anchors legends to the right for `x` values greater than or equal to 2/3,
    // anchors legends to the left for `x` values less than or equal to 1/3 and anchors legends with respect to their
    // center otherwise.
    // - Default: left
    Layout::Legend& xanchor(enum Xanchor f);

    // Sets the container `x` refers to. *container* spans the entire `width` of the plot. *paper* refers to the width
    // of the plotting area only.
    // - Default: paper
    Layout::Legend& xref(enum Xref f);

    // Sets the y position with respect to `yref` (in normalized coordinates) of the legend. When `yref` is *paper*,
    // defaults to *1* for vertical legends, defaults to *-0.1* for horizontal legends on graphs w/o range sliders and
    // defaults to *1.1* for horizontal legends on graph with one or multiple range sliders. When `yref` is *container*,
    // defaults to *1*. Must be between *0* and *1* if `yref` is *container* and between *-2* and *3* if `yref` is
    // *paper*.
    Layout::Legend& y(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Legend& y(Callable&& c);

    // Sets the legend's vertical position anchor This anchor binds the `y` position to the *top*, *middle* or *bottom*
    // of the legend. Value *auto* anchors legends at their bottom for `y` values less than or equal to 1/3, anchors
    // legends to at their top for `y` values greater than or equal to 2/3 and anchors legends with respect to their
    // middle otherwise.
    Layout::Legend& yanchor(enum Yanchor f);

    // Sets the container `y` refers to. *container* spans the entire `height` of the plot. *paper* refers to the height
    // of the plotting area only.
    // - Default: paper
    Layout::Legend& yref(enum Yref f);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets the font used to text the legend items.
class Layout::Legend::Font {
 public:
    Font() = default;
    Font(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    enum class Textcase {
        Normal,
        WordCaps,
        Upper,
        Lower,
    };
    static std::string to_string(Textcase e);

    enum class Variant {
        Normal,
        SmallCaps,
        AllSmallCaps,
        AllPetiteCaps,
        PetiteCaps,
        Unicase,
    };
    static std::string to_string(Variant e);

    Layout::Legend::Font& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Legend::Font& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Legend::Font& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Legend::Font& family(Callable&& c);

    // Sets the kind of decoration line(s) with text, such as an *under*, *over* or *through* as well as combinations
    // e.g. *under+over*, etc.
    // - Default: none
    // - Flags: ['under', 'over', 'through']
    // - Extras ['none']
    Layout::Legend::Font& lineposition(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Legend::Font& lineposition(Callable&& c);

    // Sets the shape and color of the shadow behind text. *auto* places minimal shadow and applies contrast text font
    // color. See https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow for additional options.
    Layout::Legend::Font& shadow(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Legend::Font& shadow(Callable&& c);

    Layout::Legend::Font& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Legend::Font& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Legend::Font& style(enum Style f);

    // Sets capitalization of text. It can be used to make text appear in all-uppercase or all-lowercase, or with each
    // word capitalized.
    // - Default: normal
    Layout::Legend::Font& textcase(enum Textcase f);

    // Sets the variant of the font.
    // - Default: normal
    Layout::Legend::Font& variant(enum Variant f);

    // Sets the weight (or boldness) of the font.
    Layout::Legend::Font& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Legend::Font& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets the font for group titles in legend. Defaults to `legend.font` with its size increased about 10%.
class Layout::Legend::Grouptitlefont {
 public:
    Grouptitlefont() = default;
    Grouptitlefont(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    enum class Textcase {
        Normal,
        WordCaps,
        Upper,
        Lower,
    };
    static std::string to_string(Textcase e);

    enum class Variant {
        Normal,
        SmallCaps,
        AllSmallCaps,
        AllPetiteCaps,
        PetiteCaps,
        Unicase,
    };
    static std::string to_string(Variant e);

    Layout::Legend::Grouptitlefont& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Legend::Grouptitlefont& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Legend::Grouptitlefont& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Legend::Grouptitlefont& family(Callable&& c);

    // Sets the kind of decoration line(s) with text, such as an *under*, *over* or *through* as well as combinations
    // e.g. *under+over*, etc.
    // - Default: none
    // - Flags: ['under', 'over', 'through']
    // - Extras ['none']
    Layout::Legend::Grouptitlefont& lineposition(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Legend::Grouptitlefont& lineposition(Callable&& c);

    // Sets the shape and color of the shadow behind text. *auto* places minimal shadow and applies contrast text font
    // color. See https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow for additional options.
    Layout::Legend::Grouptitlefont& shadow(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Legend::Grouptitlefont& shadow(Callable&& c);

    Layout::Legend::Grouptitlefont& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Legend::Grouptitlefont& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Legend::Grouptitlefont& style(enum Style f);

    // Sets capitalization of text. It can be used to make text appear in all-uppercase or all-lowercase, or with each
    // word capitalized.
    // - Default: normal
    Layout::Legend::Grouptitlefont& textcase(enum Textcase f);

    // Sets the variant of the font.
    // - Default: normal
    Layout::Legend::Grouptitlefont& variant(enum Variant f);

    // Sets the weight (or boldness) of the font.
    Layout::Legend::Grouptitlefont& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Legend::Grouptitlefont& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Legend::Title {
 public:
    Title() = default;
    Title(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Side {
        Top,
        Left,
        TopLeft,
        TopCenter,
        TopRight,
    };
    static std::string to_string(Side e);

    // Sets this legend's title font. Defaults to `legend.font` with its size increased about 20%.
    class Font;

    // Sets this legend's title font. Defaults to `legend.font` with its size increased about 20%.
    Layout::Legend::Title& font(Font f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Font&>>>
    Layout::Legend::Title& font(Callable&& c);

    // Determines the location of legend's title with respect to the legend items. Defaulted to *top* with `orientation`
    // is *h*. Defaulted to *left* with `orientation` is *v*. The *top left* options could be used to expand top center
    // and top right are for horizontal alignment legend area in both x and y sides.
    Layout::Legend::Title& side(enum Side f);

    // Sets the title of the legend.
    Layout::Legend::Title& text(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Legend::Title& text(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets this legend's title font. Defaults to `legend.font` with its size increased about 20%.
class Layout::Legend::Title::Font {
 public:
    Font() = default;
    Font(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    enum class Textcase {
        Normal,
        WordCaps,
        Upper,
        Lower,
    };
    static std::string to_string(Textcase e);

    enum class Variant {
        Normal,
        SmallCaps,
        AllSmallCaps,
        AllPetiteCaps,
        PetiteCaps,
        Unicase,
    };
    static std::string to_string(Variant e);

    Layout::Legend::Title::Font& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Legend::Title::Font& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Legend::Title::Font& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Legend::Title::Font& family(Callable&& c);

    // Sets the kind of decoration line(s) with text, such as an *under*, *over* or *through* as well as combinations
    // e.g. *under+over*, etc.
    // - Default: none
    // - Flags: ['under', 'over', 'through']
    // - Extras ['none']
    Layout::Legend::Title::Font& lineposition(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Legend::Title::Font& lineposition(Callable&& c);

    // Sets the shape and color of the shadow behind text. *auto* places minimal shadow and applies contrast text font
    // color. See https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow for additional options.
    Layout::Legend::Title::Font& shadow(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Legend::Title::Font& shadow(Callable&& c);

    Layout::Legend::Title::Font& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Legend::Title::Font& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Legend::Title::Font& style(enum Style f);

    // Sets capitalization of text. It can be used to make text appear in all-uppercase or all-lowercase, or with each
    // word capitalized.
    // - Default: normal
    Layout::Legend::Title::Font& textcase(enum Textcase f);

    // Sets the variant of the font.
    // - Default: normal
    Layout::Legend::Title::Font& variant(enum Variant f);

    // Sets the weight (or boldness) of the font.
    Layout::Legend::Title::Font& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Legend::Title::Font& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Map {
 public:
    Map() = default;
    Map(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    class Bounds;
    class Center;
    class Domain;
    class Layers;

    // Sets the bearing angle of the map in degrees counter-clockwise from North (map.bearing).
    Layout::Map& bearing(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Map& bearing(Callable&& c);

    Layout::Map& bounds(Bounds f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Bounds&>>>
    Layout::Map& bounds(Callable&& c);

    Layout::Map& center(Center f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Center&>>>
    Layout::Map& center(Callable&& c);

    Layout::Map& domain(Domain f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Domain&>>>
    Layout::Map& domain(Callable&& c);

    Layout::Map& layers(Layers f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Layers&>>>
    Layout::Map& layers(Callable&& c);

    // Sets the pitch angle of the map (in degrees, where *0* means perpendicular to the surface of the map)
    // (map.pitch).
    Layout::Map& pitch(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Map& pitch(Callable&& c);

    // Defines the map layers that are rendered by default below the trace layers defined in `data`, which are
    // themselves by default rendered below the layers defined in `layout.map.layers`.  These layers can be defined
    // either explicitly as a Map Style object which can contain multiple layer definitions that load data from any
    // public or private Tile Map Service (TMS or XYZ) or Web Map Service (WMS) or implicitly by using one of the
    // built-in style objects which use WMSes or by using a custom style URL  Map Style objects are of the form
    // described in the MapLibre GL JS documentation available at https://maplibre.org/maplibre-style-spec/  The
    // built-in plotly.js styles objects are: basic, carto-darkmatter, carto-darkmatter-nolabels, carto-positron,
    // carto-positron-nolabels, carto-voyager, carto-voyager-nolabels, dark, light, open-street-map, outdoors,
    // satellite, satellite-streets, streets, white-bg.
    template <typename T>
    Layout::Map& style(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Map& style(Callable&& c);

    // Controls persistence of user-driven changes in the view: `center`, `zoom`, `bearing`, `pitch`. Defaults to
    // `layout.uirevision`.
    template <typename T>
    Layout::Map& uirevision(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Map& uirevision(Callable&& c);

    // Sets the zoom level of the map (map.zoom).
    Layout::Map& zoom(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Map& zoom(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Map::Bounds {
 public:
    Bounds() = default;
    Bounds(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Sets the maximum longitude of the map (in degrees East) if `west`, `south` and `north` are declared.
    Layout::Map::Bounds& east(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Map::Bounds& east(Callable&& c);

    // Sets the maximum latitude of the map (in degrees North) if `east`, `west` and `south` are declared.
    Layout::Map::Bounds& north(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Map::Bounds& north(Callable&& c);

    // Sets the minimum latitude of the map (in degrees North) if `east`, `west` and `north` are declared.
    Layout::Map::Bounds& south(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Map::Bounds& south(Callable&& c);

    // Sets the minimum longitude of the map (in degrees East) if `east`, `south` and `north` are declared.
    Layout::Map::Bounds& west(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Map::Bounds& west(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Map::Center {
 public:
    Center() = default;
    Center(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Sets the latitude of the center of the map (in degrees North).
    Layout::Map::Center& lat(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Map::Center& lat(Callable&& c);

    // Sets the longitude of the center of the map (in degrees East).
    Layout::Map::Center& lon(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Map::Center& lon(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Map::Domain {
 public:
    Domain() = default;
    Domain(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // If there is a layout grid, use the domain for this column in the grid for this map subplot .
    Layout::Map::Domain& column(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Map::Domain& column(Callable&& c);

    // If there is a layout grid, use the domain for this row in the grid for this map subplot .
    Layout::Map::Domain& row(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Map::Domain& row(Callable&& c);

    // Sets the horizontal domain of this map subplot (in plot fraction).
    Layout::Map::Domain& x(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Map::Domain& x(Callable&& c);

    // Sets the vertical domain of this map subplot (in plot fraction).
    Layout::Map::Domain& y(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Map::Domain& y(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Map::Layers {
 public:
    Layers() = default;
    Layers(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    class Layer;

    Layout::Map::Layers& layer(Layer f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Layer&>>>
    Layout::Map::Layers& layer(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Map::Layers::Layer {
 public:
    Layer() = default;
    Layer(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Sourcetype {
        Geojson,
        Vector,
        Raster,
        Image,
    };
    static std::string to_string(Sourcetype e);

    enum class Type {
        Circle,
        Line,
        Fill,
        Symbol,
        Raster,
    };
    static std::string to_string(Type e);

    class Circle;
    class Fill;
    class Line;
    class Symbol;

    // Determines if the layer will be inserted before the layer with the specified ID. If omitted or set to '', the
    // layer will be inserted above every existing layer.
    Layout::Map::Layers::Layer& below(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Map::Layers::Layer& below(Callable&& c);

    Layout::Map::Layers::Layer& circle(Circle f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Circle&>>>
    Layout::Map::Layers::Layer& circle(Callable&& c);

    // Sets the primary layer color. If `type` is *circle*, color corresponds to the circle color
    // (map.layer.paint.circle-color) If `type` is *line*, color corresponds to the line color
    // (map.layer.paint.line-color) If `type` is *fill*, color corresponds to the fill color
    // (map.layer.paint.fill-color) If `type` is *symbol*, color corresponds to the icon color
    // (map.layer.paint.icon-color)
    Layout::Map::Layers::Layer& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Map::Layers::Layer& color(Callable&& c);

    // Sets the coordinates array contains [longitude, latitude] pairs for the image corners listed in clockwise order:
    // top left, top right, bottom right, bottom left. Only has an effect for *image* `sourcetype`.
    template <typename T>
    Layout::Map::Layers::Layer& coordinates(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Map::Layers::Layer& coordinates(Callable&& c);

    Layout::Map::Layers::Layer& fill(Fill f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Fill&>>>
    Layout::Map::Layers::Layer& fill(Callable&& c);

    Layout::Map::Layers::Layer& line(Line f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Line&>>>
    Layout::Map::Layers::Layer& line(Callable&& c);

    // Sets the maximum zoom level (map.layer.maxzoom). At zoom levels equal to or greater than the maxzoom, the layer
    // will be hidden.
    Layout::Map::Layers::Layer& maxzoom(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Map::Layers::Layer& maxzoom(Callable&& c);

    // Sets the minimum zoom level (map.layer.minzoom). At zoom levels less than the minzoom, the layer will be hidden.
    Layout::Map::Layers::Layer& minzoom(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Map::Layers::Layer& minzoom(Callable&& c);

    // When used in a template, named items are created in the output figure in addition to any items the figure already
    // has in this array. You can modify these items in the output figure by making your own item with
    // `templateitemname` matching this `name` alongside your modifications (including `visible: false` or `enabled:
    // false` to hide it). Has no effect outside of a template.
    Layout::Map::Layers::Layer& name(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Map::Layers::Layer& name(Callable&& c);

    // Sets the opacity of the layer. If `type` is *circle*, opacity corresponds to the circle opacity
    // (map.layer.paint.circle-opacity) If `type` is *line*, opacity corresponds to the line opacity
    // (map.layer.paint.line-opacity) If `type` is *fill*, opacity corresponds to the fill opacity
    // (map.layer.paint.fill-opacity) If `type` is *symbol*, opacity corresponds to the icon/text opacity
    // (map.layer.paint.text-opacity)
    Layout::Map::Layers::Layer& opacity(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Map::Layers::Layer& opacity(Callable&& c);

    // Sets the source data for this layer (map.layer.source). When `sourcetype` is set to *geojson*, `source` can be a
    // URL to a GeoJSON or a GeoJSON object. When `sourcetype` is set to *vector* or *raster*, `source` can be a URL or
    // an array of tile URLs. When `sourcetype` is set to *image*, `source` can be a URL to an image.
    template <typename T>
    Layout::Map::Layers::Layer& source(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Map::Layers::Layer& source(Callable&& c);

    // Sets the attribution for this source.
    Layout::Map::Layers::Layer& sourceattribution(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Map::Layers::Layer& sourceattribution(Callable&& c);

    // Specifies the layer to use from a vector tile source (map.layer.source-layer). Required for *vector* source type
    // that supports multiple layers.
    Layout::Map::Layers::Layer& sourcelayer(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Map::Layers::Layer& sourcelayer(Callable&& c);

    // Sets the source type for this layer, that is the type of the layer data.
    // - Default: geojson
    Layout::Map::Layers::Layer& sourcetype(enum Sourcetype f);

    Layout::Map::Layers::Layer& symbol(Symbol f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Symbol&>>>
    Layout::Map::Layers::Layer& symbol(Callable&& c);

    // Used to refer to a named item in this array in the template. Named items from the template will be created even
    // without a matching item in the input figure, but you can modify one by making an item with `templateitemname`
    // matching its `name`, alongside your modifications (including `visible: false` or `enabled: false` to hide it). If
    // there is no template or no matching item, this item will be hidden unless you explicitly show it with `visible:
    // true`.
    Layout::Map::Layers::Layer& templateitemname(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Map::Layers::Layer& templateitemname(Callable&& c);

    // Sets the layer type, that is the how the layer data set in `source` will be rendered With `sourcetype` set to
    // *geojson*, the following values are allowed: *circle*, *line*, *fill* and *symbol*. but note that *line* and
    // *fill* are not compatible with Point GeoJSON geometries. With `sourcetype` set to *vector*, the following values
    // are allowed:  *circle*, *line*, *fill* and *symbol*. With `sourcetype` set to *raster* or `*image*`, only the
    // *raster* value is allowed.
    // - Default: circle
    Layout::Map::Layers::Layer& type(enum Type f);

    // Determines whether this layer is displayed
    Layout::Map::Layers::Layer& visible(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Map::Layers::Layer& visible(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Map::Layers::Layer::Circle {
 public:
    Circle() = default;
    Circle(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Sets the circle radius (map.layer.paint.circle-radius). Has an effect only when `type` is set to *circle*.
    Layout::Map::Layers::Layer::Circle& radius(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Map::Layers::Layer::Circle& radius(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Map::Layers::Layer::Fill {
 public:
    Fill() = default;
    Fill(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Sets the fill outline color (map.layer.paint.fill-outline-color). Has an effect only when `type` is set to
    // *fill*.
    Layout::Map::Layers::Layer::Fill& outlinecolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Map::Layers::Layer::Fill& outlinecolor(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Map::Layers::Layer::Line {
 public:
    Line() = default;
    Line(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Sets the length of dashes and gaps (map.layer.paint.line-dasharray). Has an effect only when `type` is set to
    // *line*.
    template <typename T, typename = std::enable_if_t<is_data_array_element_v<T>>>
    Layout::Map::Layers::Layer::Line& dash(const std::vector<T>& f);
    template <
        typename T, typename Callable,
        typename = std::enable_if_t<is_data_array_element_v<T> && (std::is_invocable_v<Callable, std::vector<T>&>)>>
    Layout::Map::Layers::Layer::Line& dash(Callable&& c);

    // Sets the source reference on Chart Studio Cloud for `dash`.
    Layout::Map::Layers::Layer::Line& dashsrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Map::Layers::Layer::Line& dashsrc(Callable&& c);

    // Sets the line width (map.layer.paint.line-width). Has an effect only when `type` is set to *line*.
    Layout::Map::Layers::Layer::Line& width(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Map::Layers::Layer::Line& width(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Map::Layers::Layer::Symbol {
 public:
    Symbol() = default;
    Symbol(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Placement {
        Point,
        Line,
        LineCenter,
    };
    static std::string to_string(Placement e);

    enum class Textposition {
        TopLeft,
        TopCenter,
        TopRight,
        MiddleLeft,
        MiddleCenter,
        MiddleRight,
        BottomLeft,
        BottomCenter,
        BottomRight,
    };
    static std::string to_string(Textposition e);

    // Sets the icon text font (color=map.layer.paint.text-color, size=map.layer.layout.text-size). Has an effect only
    // when `type` is set to *symbol*.
    class Textfont;

    // Sets the symbol icon image (map.layer.layout.icon-image). Full list: https://www.map.com/maki-icons/
    Layout::Map::Layers::Layer::Symbol& icon(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Map::Layers::Layer::Symbol& icon(Callable&& c);

    // Sets the symbol icon size (map.layer.layout.icon-size). Has an effect only when `type` is set to *symbol*.
    Layout::Map::Layers::Layer::Symbol& iconsize(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Map::Layers::Layer::Symbol& iconsize(Callable&& c);

    // Sets the symbol and/or text placement (map.layer.layout.symbol-placement). If `placement` is *point*, the label
    // is placed where the geometry is located If `placement` is *line*, the label is placed along the line of the
    // geometry If `placement` is *line-center*, the label is placed on the center of the geometry
    // - Default: point
    Layout::Map::Layers::Layer::Symbol& placement(enum Placement f);

    // Sets the symbol text (map.layer.layout.text-field).
    Layout::Map::Layers::Layer::Symbol& text(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Map::Layers::Layer::Symbol& text(Callable&& c);

    // Sets the icon text font (color=map.layer.paint.text-color, size=map.layer.layout.text-size). Has an effect only
    // when `type` is set to *symbol*.
    Layout::Map::Layers::Layer::Symbol& textfont(Textfont f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Textfont&>>>
    Layout::Map::Layers::Layer::Symbol& textfont(Callable&& c);

    // Sets the positions of the `text` elements with respects to the (x,y) coordinates.
    // - Default: middle center
    Layout::Map::Layers::Layer::Symbol& textposition(enum Textposition f);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets the icon text font (color=map.layer.paint.text-color, size=map.layer.layout.text-size). Has an effect only when
// `type` is set to *symbol*.
class Layout::Map::Layers::Layer::Symbol::Textfont {
 public:
    Textfont() = default;
    Textfont(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    Layout::Map::Layers::Layer::Symbol::Textfont& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Map::Layers::Layer::Symbol::Textfont& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Map::Layers::Layer::Symbol::Textfont& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Map::Layers::Layer::Symbol::Textfont& family(Callable&& c);

    Layout::Map::Layers::Layer::Symbol::Textfont& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Map::Layers::Layer::Symbol::Textfont& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Map::Layers::Layer::Symbol::Textfont& style(enum Style f);

    // Sets the weight (or boldness) of the font.
    Layout::Map::Layers::Layer::Symbol::Textfont& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Map::Layers::Layer::Symbol::Textfont& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Mapbox {
 public:
    Mapbox() = default;
    Mapbox(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    class Bounds;
    class Center;
    class Domain;
    class Layers;

    // Sets the mapbox access token to be used for this mapbox map. Alternatively, the mapbox access token can be set in
    // the configuration options under `mapboxAccessToken`. Note that accessToken are only required when `style` (e.g
    // with values : basic, streets, outdoors, light, dark, satellite, satellite-streets ) and/or a layout layer
    // references the Mapbox server.
    Layout::Mapbox& accesstoken(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Mapbox& accesstoken(Callable&& c);

    // Sets the bearing angle of the map in degrees counter-clockwise from North (mapbox.bearing).
    Layout::Mapbox& bearing(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Mapbox& bearing(Callable&& c);

    Layout::Mapbox& bounds(Bounds f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Bounds&>>>
    Layout::Mapbox& bounds(Callable&& c);

    Layout::Mapbox& center(Center f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Center&>>>
    Layout::Mapbox& center(Callable&& c);

    Layout::Mapbox& domain(Domain f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Domain&>>>
    Layout::Mapbox& domain(Callable&& c);

    Layout::Mapbox& layers(Layers f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Layers&>>>
    Layout::Mapbox& layers(Callable&& c);

    // Sets the pitch angle of the map (in degrees, where *0* means perpendicular to the surface of the map)
    // (mapbox.pitch).
    Layout::Mapbox& pitch(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Mapbox& pitch(Callable&& c);

    // Defines the map layers that are rendered by default below the trace layers defined in `data`, which are
    // themselves by default rendered below the layers defined in `layout.mapbox.layers`.  These layers can be defined
    // either explicitly as a Mapbox Style object which can contain multiple layer definitions that load data from any
    // public or private Tile Map Service (TMS or XYZ) or Web Map Service (WMS) or implicitly by using one of the
    // built-in style objects which use WMSes which do not require any access tokens, or by using a default Mapbox style
    // or custom Mapbox style URL, both of which require a Mapbox access token  Note that Mapbox access token can be set
    // in the `accesstoken` attribute or in the `mapboxAccessToken` config option.  Mapbox Style objects are of the form
    // described in the Mapbox GL JS documentation available at https://docs.mapbox.com/mapbox-gl-js/style-spec  The
    // built-in plotly.js styles objects are: carto-darkmatter, carto-positron, open-street-map, stamen-terrain,
    // stamen-toner, stamen-watercolor, white-bg  The built-in Mapbox styles are: basic, streets, outdoors, light, dark,
    // satellite, satellite-streets  Mapbox style URLs are of the form: mapbox://mapbox.mapbox-<name>-<version>
    template <typename T>
    Layout::Mapbox& style(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Mapbox& style(Callable&& c);

    // Controls persistence of user-driven changes in the view: `center`, `zoom`, `bearing`, `pitch`. Defaults to
    // `layout.uirevision`.
    template <typename T>
    Layout::Mapbox& uirevision(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Mapbox& uirevision(Callable&& c);

    // Sets the zoom level of the map (mapbox.zoom).
    Layout::Mapbox& zoom(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Mapbox& zoom(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Mapbox::Bounds {
 public:
    Bounds() = default;
    Bounds(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Sets the maximum longitude of the map (in degrees East) if `west`, `south` and `north` are declared.
    Layout::Mapbox::Bounds& east(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Mapbox::Bounds& east(Callable&& c);

    // Sets the maximum latitude of the map (in degrees North) if `east`, `west` and `south` are declared.
    Layout::Mapbox::Bounds& north(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Mapbox::Bounds& north(Callable&& c);

    // Sets the minimum latitude of the map (in degrees North) if `east`, `west` and `north` are declared.
    Layout::Mapbox::Bounds& south(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Mapbox::Bounds& south(Callable&& c);

    // Sets the minimum longitude of the map (in degrees East) if `east`, `south` and `north` are declared.
    Layout::Mapbox::Bounds& west(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Mapbox::Bounds& west(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Mapbox::Center {
 public:
    Center() = default;
    Center(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Sets the latitude of the center of the map (in degrees North).
    Layout::Mapbox::Center& lat(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Mapbox::Center& lat(Callable&& c);

    // Sets the longitude of the center of the map (in degrees East).
    Layout::Mapbox::Center& lon(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Mapbox::Center& lon(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Mapbox::Domain {
 public:
    Domain() = default;
    Domain(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // If there is a layout grid, use the domain for this column in the grid for this mapbox subplot .
    Layout::Mapbox::Domain& column(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Mapbox::Domain& column(Callable&& c);

    // If there is a layout grid, use the domain for this row in the grid for this mapbox subplot .
    Layout::Mapbox::Domain& row(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Mapbox::Domain& row(Callable&& c);

    // Sets the horizontal domain of this mapbox subplot (in plot fraction).
    Layout::Mapbox::Domain& x(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Mapbox::Domain& x(Callable&& c);

    // Sets the vertical domain of this mapbox subplot (in plot fraction).
    Layout::Mapbox::Domain& y(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Mapbox::Domain& y(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Mapbox::Layers {
 public:
    Layers() = default;
    Layers(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    class Layer;

    Layout::Mapbox::Layers& layer(Layer f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Layer&>>>
    Layout::Mapbox::Layers& layer(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Mapbox::Layers::Layer {
 public:
    Layer() = default;
    Layer(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Sourcetype {
        Geojson,
        Vector,
        Raster,
        Image,
    };
    static std::string to_string(Sourcetype e);

    enum class Type {
        Circle,
        Line,
        Fill,
        Symbol,
        Raster,
    };
    static std::string to_string(Type e);

    class Circle;
    class Fill;
    class Line;
    class Symbol;

    // Determines if the layer will be inserted before the layer with the specified ID. If omitted or set to '', the
    // layer will be inserted above every existing layer.
    Layout::Mapbox::Layers::Layer& below(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Mapbox::Layers::Layer& below(Callable&& c);

    Layout::Mapbox::Layers::Layer& circle(Circle f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Circle&>>>
    Layout::Mapbox::Layers::Layer& circle(Callable&& c);

    // Sets the primary layer color. If `type` is *circle*, color corresponds to the circle color
    // (mapbox.layer.paint.circle-color) If `type` is *line*, color corresponds to the line color
    // (mapbox.layer.paint.line-color) If `type` is *fill*, color corresponds to the fill color
    // (mapbox.layer.paint.fill-color) If `type` is *symbol*, color corresponds to the icon color
    // (mapbox.layer.paint.icon-color)
    Layout::Mapbox::Layers::Layer& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Mapbox::Layers::Layer& color(Callable&& c);

    // Sets the coordinates array contains [longitude, latitude] pairs for the image corners listed in clockwise order:
    // top left, top right, bottom right, bottom left. Only has an effect for *image* `sourcetype`.
    template <typename T>
    Layout::Mapbox::Layers::Layer& coordinates(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Mapbox::Layers::Layer& coordinates(Callable&& c);

    Layout::Mapbox::Layers::Layer& fill(Fill f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Fill&>>>
    Layout::Mapbox::Layers::Layer& fill(Callable&& c);

    Layout::Mapbox::Layers::Layer& line(Line f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Line&>>>
    Layout::Mapbox::Layers::Layer& line(Callable&& c);

    // Sets the maximum zoom level (mapbox.layer.maxzoom). At zoom levels equal to or greater than the maxzoom, the
    // layer will be hidden.
    Layout::Mapbox::Layers::Layer& maxzoom(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Mapbox::Layers::Layer& maxzoom(Callable&& c);

    // Sets the minimum zoom level (mapbox.layer.minzoom). At zoom levels less than the minzoom, the layer will be
    // hidden.
    Layout::Mapbox::Layers::Layer& minzoom(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Mapbox::Layers::Layer& minzoom(Callable&& c);

    // When used in a template, named items are created in the output figure in addition to any items the figure already
    // has in this array. You can modify these items in the output figure by making your own item with
    // `templateitemname` matching this `name` alongside your modifications (including `visible: false` or `enabled:
    // false` to hide it). Has no effect outside of a template.
    Layout::Mapbox::Layers::Layer& name(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Mapbox::Layers::Layer& name(Callable&& c);

    // Sets the opacity of the layer. If `type` is *circle*, opacity corresponds to the circle opacity
    // (mapbox.layer.paint.circle-opacity) If `type` is *line*, opacity corresponds to the line opacity
    // (mapbox.layer.paint.line-opacity) If `type` is *fill*, opacity corresponds to the fill opacity
    // (mapbox.layer.paint.fill-opacity) If `type` is *symbol*, opacity corresponds to the icon/text opacity
    // (mapbox.layer.paint.text-opacity)
    Layout::Mapbox::Layers::Layer& opacity(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Mapbox::Layers::Layer& opacity(Callable&& c);

    // Sets the source data for this layer (mapbox.layer.source). When `sourcetype` is set to *geojson*, `source` can be
    // a URL to a GeoJSON or a GeoJSON object. When `sourcetype` is set to *vector* or *raster*, `source` can be a URL
    // or an array of tile URLs. When `sourcetype` is set to *image*, `source` can be a URL to an image.
    template <typename T>
    Layout::Mapbox::Layers::Layer& source(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Mapbox::Layers::Layer& source(Callable&& c);

    // Sets the attribution for this source.
    Layout::Mapbox::Layers::Layer& sourceattribution(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Mapbox::Layers::Layer& sourceattribution(Callable&& c);

    // Specifies the layer to use from a vector tile source (mapbox.layer.source-layer). Required for *vector* source
    // type that supports multiple layers.
    Layout::Mapbox::Layers::Layer& sourcelayer(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Mapbox::Layers::Layer& sourcelayer(Callable&& c);

    // Sets the source type for this layer, that is the type of the layer data.
    // - Default: geojson
    Layout::Mapbox::Layers::Layer& sourcetype(enum Sourcetype f);

    Layout::Mapbox::Layers::Layer& symbol(Symbol f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Symbol&>>>
    Layout::Mapbox::Layers::Layer& symbol(Callable&& c);

    // Used to refer to a named item in this array in the template. Named items from the template will be created even
    // without a matching item in the input figure, but you can modify one by making an item with `templateitemname`
    // matching its `name`, alongside your modifications (including `visible: false` or `enabled: false` to hide it). If
    // there is no template or no matching item, this item will be hidden unless you explicitly show it with `visible:
    // true`.
    Layout::Mapbox::Layers::Layer& templateitemname(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Mapbox::Layers::Layer& templateitemname(Callable&& c);

    // Sets the layer type, that is the how the layer data set in `source` will be rendered With `sourcetype` set to
    // *geojson*, the following values are allowed: *circle*, *line*, *fill* and *symbol*. but note that *line* and
    // *fill* are not compatible with Point GeoJSON geometries. With `sourcetype` set to *vector*, the following values
    // are allowed:  *circle*, *line*, *fill* and *symbol*. With `sourcetype` set to *raster* or `*image*`, only the
    // *raster* value is allowed.
    // - Default: circle
    Layout::Mapbox::Layers::Layer& type(enum Type f);

    // Determines whether this layer is displayed
    Layout::Mapbox::Layers::Layer& visible(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Mapbox::Layers::Layer& visible(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Mapbox::Layers::Layer::Circle {
 public:
    Circle() = default;
    Circle(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Sets the circle radius (mapbox.layer.paint.circle-radius). Has an effect only when `type` is set to *circle*.
    Layout::Mapbox::Layers::Layer::Circle& radius(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Mapbox::Layers::Layer::Circle& radius(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Mapbox::Layers::Layer::Fill {
 public:
    Fill() = default;
    Fill(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Sets the fill outline color (mapbox.layer.paint.fill-outline-color). Has an effect only when `type` is set to
    // *fill*.
    Layout::Mapbox::Layers::Layer::Fill& outlinecolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Mapbox::Layers::Layer::Fill& outlinecolor(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Mapbox::Layers::Layer::Line {
 public:
    Line() = default;
    Line(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Sets the length of dashes and gaps (mapbox.layer.paint.line-dasharray). Has an effect only when `type` is set to
    // *line*.
    template <typename T, typename = std::enable_if_t<is_data_array_element_v<T>>>
    Layout::Mapbox::Layers::Layer::Line& dash(const std::vector<T>& f);
    template <
        typename T, typename Callable,
        typename = std::enable_if_t<is_data_array_element_v<T> && (std::is_invocable_v<Callable, std::vector<T>&>)>>
    Layout::Mapbox::Layers::Layer::Line& dash(Callable&& c);

    // Sets the source reference on Chart Studio Cloud for `dash`.
    Layout::Mapbox::Layers::Layer::Line& dashsrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Mapbox::Layers::Layer::Line& dashsrc(Callable&& c);

    // Sets the line width (mapbox.layer.paint.line-width). Has an effect only when `type` is set to *line*.
    Layout::Mapbox::Layers::Layer::Line& width(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Mapbox::Layers::Layer::Line& width(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Mapbox::Layers::Layer::Symbol {
 public:
    Symbol() = default;
    Symbol(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Placement {
        Point,
        Line,
        LineCenter,
    };
    static std::string to_string(Placement e);

    enum class Textposition {
        TopLeft,
        TopCenter,
        TopRight,
        MiddleLeft,
        MiddleCenter,
        MiddleRight,
        BottomLeft,
        BottomCenter,
        BottomRight,
    };
    static std::string to_string(Textposition e);

    // Sets the icon text font (color=mapbox.layer.paint.text-color, size=mapbox.layer.layout.text-size). Has an effect
    // only when `type` is set to *symbol*.
    class Textfont;

    // Sets the symbol icon image (mapbox.layer.layout.icon-image). Full list: https://www.mapbox.com/maki-icons/
    Layout::Mapbox::Layers::Layer::Symbol& icon(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Mapbox::Layers::Layer::Symbol& icon(Callable&& c);

    // Sets the symbol icon size (mapbox.layer.layout.icon-size). Has an effect only when `type` is set to *symbol*.
    Layout::Mapbox::Layers::Layer::Symbol& iconsize(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Mapbox::Layers::Layer::Symbol& iconsize(Callable&& c);

    // Sets the symbol and/or text placement (mapbox.layer.layout.symbol-placement). If `placement` is *point*, the
    // label is placed where the geometry is located If `placement` is *line*, the label is placed along the line of the
    // geometry If `placement` is *line-center*, the label is placed on the center of the geometry
    // - Default: point
    Layout::Mapbox::Layers::Layer::Symbol& placement(enum Placement f);

    // Sets the symbol text (mapbox.layer.layout.text-field).
    Layout::Mapbox::Layers::Layer::Symbol& text(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Mapbox::Layers::Layer::Symbol& text(Callable&& c);

    // Sets the icon text font (color=mapbox.layer.paint.text-color, size=mapbox.layer.layout.text-size). Has an effect
    // only when `type` is set to *symbol*.
    Layout::Mapbox::Layers::Layer::Symbol& textfont(Textfont f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Textfont&>>>
    Layout::Mapbox::Layers::Layer::Symbol& textfont(Callable&& c);

    // Sets the positions of the `text` elements with respects to the (x,y) coordinates.
    // - Default: middle center
    Layout::Mapbox::Layers::Layer::Symbol& textposition(enum Textposition f);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets the icon text font (color=mapbox.layer.paint.text-color, size=mapbox.layer.layout.text-size). Has an effect only
// when `type` is set to *symbol*.
class Layout::Mapbox::Layers::Layer::Symbol::Textfont {
 public:
    Textfont() = default;
    Textfont(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    Layout::Mapbox::Layers::Layer::Symbol::Textfont& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Mapbox::Layers::Layer::Symbol::Textfont& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Mapbox::Layers::Layer::Symbol::Textfont& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Mapbox::Layers::Layer::Symbol::Textfont& family(Callable&& c);

    Layout::Mapbox::Layers::Layer::Symbol::Textfont& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Mapbox::Layers::Layer::Symbol::Textfont& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Mapbox::Layers::Layer::Symbol::Textfont& style(enum Style f);

    // Sets the weight (or boldness) of the font.
    Layout::Mapbox::Layers::Layer::Symbol::Textfont& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Mapbox::Layers::Layer::Symbol::Textfont& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Margin {
 public:
    Margin() = default;
    Margin(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Turns on/off margin expansion computations. Legends, colorbars, updatemenus, sliders, axis rangeselector and
    // rangeslider are allowed to push the margins by defaults.
    Layout::Margin& autoexpand(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Margin& autoexpand(Callable&& c);

    // Sets the bottom margin (in px).
    Layout::Margin& b(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Margin& b(Callable&& c);

    // Sets the left margin (in px).
    Layout::Margin& l(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Margin& l(Callable&& c);

    // Sets the amount of padding (in px) between the plotting area and the axis lines
    Layout::Margin& pad(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Margin& pad(Callable&& c);

    // Sets the right margin (in px).
    Layout::Margin& r(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Margin& r(Callable&& c);

    // Sets the top margin (in px).
    Layout::Margin& t(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Margin& t(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Modebar {
 public:
    Modebar() = default;
    Modebar(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Orientation {
        V,
        H,
    };
    static std::string to_string(Orientation e);

    // Sets the color of the active or hovered on icons in the modebar.
    Layout::Modebar& activecolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Modebar& activecolor(Callable&& c);

    // Determines which predefined modebar buttons to add. Please note that these buttons will only be shown if they are
    // compatible with all trace types used in a graph. Similar to `config.modeBarButtonsToAdd` option. This may include
    // *v1hovermode*, *hoverclosest*, *hovercompare*, *togglehover*, *togglespikelines*, *drawline*, *drawopenpath*,
    // *drawclosedpath*, *drawcircle*, *drawrect*, *eraseshape*.
    Layout::Modebar& add(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Modebar& add(Callable&& c);
    Layout::Modebar& add(const std::vector<std::string>& f);

    // Sets the source reference on Chart Studio Cloud for `add`.
    Layout::Modebar& addsrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Modebar& addsrc(Callable&& c);

    // Sets the background color of the modebar.
    Layout::Modebar& bgcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Modebar& bgcolor(Callable&& c);

    // Sets the color of the icons in the modebar.
    Layout::Modebar& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Modebar& color(Callable&& c);

    // Sets the orientation of the modebar.
    // - Default: h
    Layout::Modebar& orientation(enum Orientation f);

    // Determines which predefined modebar buttons to remove. Similar to `config.modeBarButtonsToRemove` option. This
    // may include *autoScale2d*, *autoscale*, *editInChartStudio*, *editinchartstudio*, *hoverCompareCartesian*,
    // *hovercompare*, *lasso*, *lasso2d*, *orbitRotation*, *orbitrotation*, *pan*, *pan2d*, *pan3d*, *reset*,
    // *resetCameraDefault3d*, *resetCameraLastSave3d*, *resetGeo*, *resetSankeyGroup*, *resetScale2d*, *resetViewMap*,
    // *resetViewMapbox*, *resetViews*, *resetcameradefault*, *resetcameralastsave*, *resetsankeygroup*, *resetscale*,
    // *resetview*, *resetviews*, *select*, *select2d*, *sendDataToCloud*, *senddatatocloud*, *tableRotation*,
    // *tablerotation*, *toImage*, *toggleHover*, *toggleSpikelines*, *togglehover*, *togglespikelines*, *toimage*,
    // *zoom*, *zoom2d*, *zoom3d*, *zoomIn2d*, *zoomInGeo*, *zoomInMap*, *zoomInMapbox*, *zoomOut2d*, *zoomOutGeo*,
    // *zoomOutMap*, *zoomOutMapbox*, *zoomin*, *zoomout*.
    Layout::Modebar& remove(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Modebar& remove(Callable&& c);
    Layout::Modebar& remove(const std::vector<std::string>& f);

    // Sets the source reference on Chart Studio Cloud for `remove`.
    Layout::Modebar& removesrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Modebar& removesrc(Callable&& c);

    // Controls persistence of user-driven changes related to the modebar, including `hovermode`, `dragmode`, and
    // `showspikes` at both the root level and inside subplots. Defaults to `layout.uirevision`.
    template <typename T>
    Layout::Modebar& uirevision(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Modebar& uirevision(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Newselection {
 public:
    Newselection() = default;
    Newselection(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Mode {
        Immediate,
        Gradual,
    };
    static std::string to_string(Mode e);

    class Line;

    Layout::Newselection& line(Line f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Line&>>>
    Layout::Newselection& line(Callable&& c);

    // Describes how a new selection is created. If `immediate`, a new selection is created after first mouse up. If
    // `gradual`, a new selection is not created after first mouse. By adding to and subtracting from the initial
    // selection, this option allows declaring extra outlines of the selection.
    // - Default: immediate
    Layout::Newselection& mode(enum Mode f);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Newselection::Line {
 public:
    Line() = default;
    Line(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Sets the line color. By default uses either dark grey or white to increase contrast with background color.
    Layout::Newselection::Line& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Newselection::Line& color(Callable&& c);

    // Sets the dash style of lines. Set to a dash type string (*solid*, *dot*, *dash*, *longdash*, *dashdot*, or
    // *longdashdot*) or a dash length list in px (eg *5px,10px,2px,2px*).
    Layout::Newselection::Line& dash(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Newselection::Line& dash(Callable&& c);

    // Sets the line width (in px).
    Layout::Newselection::Line& width(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Newselection::Line& width(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Newshape {
 public:
    Newshape() = default;
    Newshape(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Drawdirection {
        Ortho,
        Horizontal,
        Vertical,
        Diagonal,
    };
    static std::string to_string(Drawdirection e);

    enum class Fillrule {
        Evenodd,
        Nonzero,
    };
    static std::string to_string(Fillrule e);

    enum class Layer {
        Below,
        Above,
        Between,
    };
    static std::string to_string(Layer e);

    enum class Visible {
        True,
        False,
        Legendonly,
    };
    static std::string to_string(Visible e);

    class Label;
    class Legendgrouptitle;
    class Line;

    // When `dragmode` is set to *drawrect*, *drawline* or *drawcircle* this limits the drag to be horizontal, vertical
    // or diagonal. Using *diagonal* there is no limit e.g. in drawing lines in any direction. *ortho* limits the draw
    // to be either horizontal or vertical. *horizontal* allows horizontal extend. *vertical* allows vertical extend.
    // - Default: diagonal
    Layout::Newshape& drawdirection(enum Drawdirection f);

    // Sets the color filling new shapes' interior. Please note that if using a fillcolor with alpha greater than half,
    // drag inside the active shape starts moving the shape underneath, otherwise a new shape could be started over.
    Layout::Newshape& fillcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Newshape& fillcolor(Callable&& c);

    // Determines the path's interior. For more info please visit
    // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-rule
    // - Default: evenodd
    Layout::Newshape& fillrule(enum Fillrule f);

    Layout::Newshape& label(Label f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Label&>>>
    Layout::Newshape& label(Callable&& c);

    // Specifies whether new shapes are drawn below gridlines (*below*), between gridlines and traces (*between*) or
    // above traces (*above*).
    // - Default: above
    Layout::Newshape& layer(enum Layer f);

    // Sets the reference to a legend to show new shape in. References to these legends are *legend*, *legend2*,
    // *legend3*, etc. Settings for these legends are set in the layout, under `layout.legend`, `layout.legend2`, etc.
    Layout::Newshape& legend(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Newshape& legend(Callable&& c);

    // Sets the legend group for new shape. Traces and shapes part of the same legend group hide/show at the same time
    // when toggling legend items.
    Layout::Newshape& legendgroup(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Newshape& legendgroup(Callable&& c);

    Layout::Newshape& legendgrouptitle(Legendgrouptitle f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Legendgrouptitle&>>>
    Layout::Newshape& legendgrouptitle(Callable&& c);

    // Sets the legend rank for new shape. Items and groups with smaller ranks are presented on top/left side while with
    // *reversed* `legend.traceorder` they are on bottom/right side. The default legendrank is 1000, so that you can use
    // ranks less than 1000 to place certain items before all unranked items, and ranks greater than 1000 to go after
    // all unranked items.
    Layout::Newshape& legendrank(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Newshape& legendrank(Callable&& c);

    // Sets the width (in px or fraction) of the legend for new shape.
    Layout::Newshape& legendwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Newshape& legendwidth(Callable&& c);

    Layout::Newshape& line(Line f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Line&>>>
    Layout::Newshape& line(Callable&& c);

    // Sets new shape name. The name appears as the legend item.
    Layout::Newshape& name(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Newshape& name(Callable&& c);

    // Sets the opacity of new shapes.
    Layout::Newshape& opacity(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Newshape& opacity(Callable&& c);

    // Determines whether or not new shape is shown in the legend.
    Layout::Newshape& showlegend(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Newshape& showlegend(Callable&& c);

    // Determines whether or not new shape is visible. If *legendonly*, the shape is not drawn, but can appear as a
    // legend item (provided that the legend itself is visible).
    // - Default: True
    Layout::Newshape& visible(enum Visible f);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Newshape::Label {
 public:
    Label() = default;
    Label(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Textposition {
        TopLeft,
        TopCenter,
        TopRight,
        MiddleLeft,
        MiddleCenter,
        MiddleRight,
        BottomLeft,
        BottomCenter,
        BottomRight,
        Start,
        Middle,
        End,
    };
    static std::string to_string(Textposition e);

    enum class Xanchor {
        Auto,
        Left,
        Center,
        Right,
    };
    static std::string to_string(Xanchor e);

    enum class Yanchor {
        Top,
        Middle,
        Bottom,
    };
    static std::string to_string(Yanchor e);

    // Sets the new shape label text font.
    class Font;

    // Sets the new shape label text font.
    Layout::Newshape::Label& font(Font f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Font&>>>
    Layout::Newshape::Label& font(Callable&& c);

    // Sets padding (in px) between edge of label and edge of new shape.
    Layout::Newshape::Label& padding(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Newshape::Label& padding(Callable&& c);

    // Sets the text to display with the new shape. It is also used for legend item if `name` is not provided.
    Layout::Newshape::Label& text(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Newshape::Label& text(Callable&& c);

    // Sets the angle at which the label text is drawn with respect to the horizontal. For lines, angle *auto* is the
    // same angle as the line. For all other shapes, angle *auto* is horizontal.
    Layout::Newshape::Label& textangle(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Newshape::Label& textangle(Callable&& c);

    // Sets the position of the label text relative to the new shape. Supported values for rectangles, circles and paths
    // are *top left*, *top center*, *top right*, *middle left*, *middle center*, *middle right*, *bottom left*, *bottom
    // center*, and *bottom right*. Supported values for lines are *start*, *middle*, and *end*. Default: *middle
    // center* for rectangles, circles, and paths; *middle* for lines.
    Layout::Newshape::Label& textposition(enum Textposition f);

    // Template string used for rendering the new shape's label. Note that this will override `text`. Variables are
    // inserted using %{variable}, for example "x0: %{x0}". Numbers are formatted using d3-format's syntax
    // %{variable:d3-format}, for example "Price: %{x0:$.2f}". See https://github.com/d3/d3-format/tree/v1.4.5#d3-format
    // for details on the formatting syntax. Dates are formatted using d3-time-format's syntax
    // %{variable|d3-time-format}, for example "Day: %{x0|%m %b %Y}". See
    // https://github.com/d3/d3-time-format/tree/v2.2.3#locale_format for details on the date formatting syntax. A
    // single multiplication or division operation may be applied to numeric variables, and combined with d3 number
    // formatting, for example "Length in cm: %{x0*2.54}", "%{slope*60:.1f} meters per second." For log axes, variable
    // values are given in log units. For date axes, x/y coordinate variables and center variables use datetimes, while
    // all other variable values use values in ms. Finally, the template string has access to variables `x0`, `x1`,
    // `y0`, `y1`, `slope`, `dx`, `dy`, `width`, `height`, `length`, `xcenter` and `ycenter`.
    Layout::Newshape::Label& texttemplate(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Newshape::Label& texttemplate(Callable&& c);

    // Sets the label's horizontal position anchor This anchor binds the specified `textposition` to the *left*,
    // *center* or *right* of the label text. For example, if `textposition` is set to *top right* and `xanchor` to
    // *right* then the right-most portion of the label text lines up with the right-most edge of the new shape.
    // - Default: auto
    Layout::Newshape::Label& xanchor(enum Xanchor f);

    // Sets the label's vertical position anchor This anchor binds the specified `textposition` to the *top*, *middle*
    // or *bottom* of the label text. For example, if `textposition` is set to *top right* and `yanchor` to *top* then
    // the top-most portion of the label text lines up with the top-most edge of the new shape.
    Layout::Newshape::Label& yanchor(enum Yanchor f);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets the new shape label text font.
class Layout::Newshape::Label::Font {
 public:
    Font() = default;
    Font(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    enum class Textcase {
        Normal,
        WordCaps,
        Upper,
        Lower,
    };
    static std::string to_string(Textcase e);

    enum class Variant {
        Normal,
        SmallCaps,
        AllSmallCaps,
        AllPetiteCaps,
        PetiteCaps,
        Unicase,
    };
    static std::string to_string(Variant e);

    Layout::Newshape::Label::Font& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Newshape::Label::Font& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Newshape::Label::Font& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Newshape::Label::Font& family(Callable&& c);

    // Sets the kind of decoration line(s) with text, such as an *under*, *over* or *through* as well as combinations
    // e.g. *under+over*, etc.
    // - Default: none
    // - Flags: ['under', 'over', 'through']
    // - Extras ['none']
    Layout::Newshape::Label::Font& lineposition(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Newshape::Label::Font& lineposition(Callable&& c);

    // Sets the shape and color of the shadow behind text. *auto* places minimal shadow and applies contrast text font
    // color. See https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow for additional options.
    Layout::Newshape::Label::Font& shadow(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Newshape::Label::Font& shadow(Callable&& c);

    Layout::Newshape::Label::Font& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Newshape::Label::Font& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Newshape::Label::Font& style(enum Style f);

    // Sets capitalization of text. It can be used to make text appear in all-uppercase or all-lowercase, or with each
    // word capitalized.
    // - Default: normal
    Layout::Newshape::Label::Font& textcase(enum Textcase f);

    // Sets the variant of the font.
    // - Default: normal
    Layout::Newshape::Label::Font& variant(enum Variant f);

    // Sets the weight (or boldness) of the font.
    Layout::Newshape::Label::Font& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Newshape::Label::Font& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Newshape::Legendgrouptitle {
 public:
    Legendgrouptitle() = default;
    Legendgrouptitle(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Sets this legend group's title font.
    class Font;

    // Sets this legend group's title font.
    Layout::Newshape::Legendgrouptitle& font(Font f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Font&>>>
    Layout::Newshape::Legendgrouptitle& font(Callable&& c);

    // Sets the title of the legend group.
    Layout::Newshape::Legendgrouptitle& text(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Newshape::Legendgrouptitle& text(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets this legend group's title font.
class Layout::Newshape::Legendgrouptitle::Font {
 public:
    Font() = default;
    Font(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    enum class Textcase {
        Normal,
        WordCaps,
        Upper,
        Lower,
    };
    static std::string to_string(Textcase e);

    enum class Variant {
        Normal,
        SmallCaps,
        AllSmallCaps,
        AllPetiteCaps,
        PetiteCaps,
        Unicase,
    };
    static std::string to_string(Variant e);

    Layout::Newshape::Legendgrouptitle::Font& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Newshape::Legendgrouptitle::Font& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Newshape::Legendgrouptitle::Font& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Newshape::Legendgrouptitle::Font& family(Callable&& c);

    // Sets the kind of decoration line(s) with text, such as an *under*, *over* or *through* as well as combinations
    // e.g. *under+over*, etc.
    // - Default: none
    // - Flags: ['under', 'over', 'through']
    // - Extras ['none']
    Layout::Newshape::Legendgrouptitle::Font& lineposition(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Newshape::Legendgrouptitle::Font& lineposition(Callable&& c);

    // Sets the shape and color of the shadow behind text. *auto* places minimal shadow and applies contrast text font
    // color. See https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow for additional options.
    Layout::Newshape::Legendgrouptitle::Font& shadow(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Newshape::Legendgrouptitle::Font& shadow(Callable&& c);

    Layout::Newshape::Legendgrouptitle::Font& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Newshape::Legendgrouptitle::Font& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Newshape::Legendgrouptitle::Font& style(enum Style f);

    // Sets capitalization of text. It can be used to make text appear in all-uppercase or all-lowercase, or with each
    // word capitalized.
    // - Default: normal
    Layout::Newshape::Legendgrouptitle::Font& textcase(enum Textcase f);

    // Sets the variant of the font.
    // - Default: normal
    Layout::Newshape::Legendgrouptitle::Font& variant(enum Variant f);

    // Sets the weight (or boldness) of the font.
    Layout::Newshape::Legendgrouptitle::Font& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Newshape::Legendgrouptitle::Font& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Newshape::Line {
 public:
    Line() = default;
    Line(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Sets the line color. By default uses either dark grey or white to increase contrast with background color.
    Layout::Newshape::Line& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Newshape::Line& color(Callable&& c);

    // Sets the dash style of lines. Set to a dash type string (*solid*, *dot*, *dash*, *longdash*, *dashdot*, or
    // *longdashdot*) or a dash length list in px (eg *5px,10px,2px,2px*).
    Layout::Newshape::Line& dash(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Newshape::Line& dash(Callable&& c);

    // Sets the line width (in px).
    Layout::Newshape::Line& width(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Newshape::Line& width(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Polar {
 public:
    Polar() = default;
    Polar(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Gridshape {
        Circular,
        Linear,
    };
    static std::string to_string(Gridshape e);

    class Angularaxis;
    class Domain;
    class Radialaxis;

    Layout::Polar& angularaxis(Angularaxis f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Angularaxis&>>>
    Layout::Polar& angularaxis(Callable&& c);

    // Set the background color of the subplot
    Layout::Polar& bgcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar& bgcolor(Callable&& c);

    Layout::Polar& domain(Domain f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Domain&>>>
    Layout::Polar& domain(Callable&& c);

    // Determines if the radial axis grid lines and angular axis line are drawn as *circular* sectors or as *linear*
    // (polygon) sectors. Has an effect only when the angular axis has `type` *category*. Note that `radialaxis.angle`
    // is snapped to the angle of the closest vertex when `gridshape` is *circular* (so that radial axis scale is the
    // same as the data scale).
    // - Default: circular
    Layout::Polar& gridshape(enum Gridshape f);

    // Sets the fraction of the radius to cut out of the polar subplot.
    Layout::Polar& hole(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Polar& hole(Callable&& c);

    Layout::Polar& radialaxis(Radialaxis f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Radialaxis&>>>
    Layout::Polar& radialaxis(Callable&& c);

    // Sets angular span of this polar subplot with two angles (in degrees). Sector are assumed to be spanned in the
    // counterclockwise direction with *0* corresponding to rightmost limit of the polar subplot.
    Layout::Polar& sector(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Polar& sector(Callable&& c);

    // Controls persistence of user-driven changes in axis attributes, if not overridden in the individual axes.
    // Defaults to `layout.uirevision`.
    template <typename T>
    Layout::Polar& uirevision(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Polar& uirevision(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Polar::Angularaxis {
 public:
    Angularaxis() = default;
    Angularaxis(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Autotypenumbers {
        ConvertTypes,
        Strict,
    };
    static std::string to_string(Autotypenumbers e);

    enum class Categoryorder {
        Trace,
        CategoryAscending,
        CategoryDescending,
        Array,
        TotalAscending,
        TotalDescending,
        MinAscending,
        MinDescending,
        MaxAscending,
        MaxDescending,
        SumAscending,
        SumDescending,
        MeanAscending,
        MeanDescending,
        GeometricMeanAscending,
        GeometricMeanDescending,
        MedianAscending,
        MedianDescending,
    };
    static std::string to_string(Categoryorder e);

    enum class Direction {
        Counterclockwise,
        Clockwise,
    };
    static std::string to_string(Direction e);

    enum class Exponentformat {
        None,
        E,
        Power,
        Si,
        B,
    };
    static std::string to_string(Exponentformat e);

    enum class Layer {
        AboveTraces,
        BelowTraces,
    };
    static std::string to_string(Layer e);

    enum class Showexponent {
        All,
        First,
        Last,
        None,
    };
    static std::string to_string(Showexponent e);

    enum class Showtickprefix {
        All,
        First,
        Last,
        None,
    };
    static std::string to_string(Showtickprefix e);

    enum class Showticksuffix {
        All,
        First,
        Last,
        None,
    };
    static std::string to_string(Showticksuffix e);

    enum class Thetaunit {
        Radians,
        Degrees,
    };
    static std::string to_string(Thetaunit e);

    enum class Tickmode {
        Auto,
        Linear,
        Array,
    };
    static std::string to_string(Tickmode e);

    enum class Ticks {
        Outside,
        Inside,
        Empty,
    };
    static std::string to_string(Ticks e);

    enum class Type {
        Hyphen,
        Linear,
        Category,
    };
    static std::string to_string(Type e);

    // Sets the tick font.
    class Tickfont;
    class Tickformatstops;

    // Using *strict* a numeric string in trace data is not converted to a number. Using *convert types* a numeric
    // string in trace data may be treated as a number during automatic axis `type` detection. Defaults to
    // layout.autotypenumbers.
    // - Default: convert types
    Layout::Polar::Angularaxis& autotypenumbers(enum Autotypenumbers f);

    // Sets the order in which categories on this axis appear. Only has an effect if `categoryorder` is set to *array*.
    // Used with `categoryorder`.
    template <typename T, typename = std::enable_if_t<is_data_array_element_v<T>>>
    Layout::Polar::Angularaxis& categoryarray(const std::vector<T>& f);
    template <
        typename T, typename Callable,
        typename = std::enable_if_t<is_data_array_element_v<T> && (std::is_invocable_v<Callable, std::vector<T>&>)>>
    Layout::Polar::Angularaxis& categoryarray(Callable&& c);

    // Sets the source reference on Chart Studio Cloud for `categoryarray`.
    Layout::Polar::Angularaxis& categoryarraysrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Angularaxis& categoryarraysrc(Callable&& c);

    // Specifies the ordering logic for the case of categorical variables. By default, plotly uses *trace*, which
    // specifies the order that is present in the data supplied. Set `categoryorder` to *category ascending* or
    // *category descending* if order should be determined by the alphanumerical order of the category names. Set
    // `categoryorder` to *array* to derive the ordering from the attribute `categoryarray`. If a category is not found
    // in the `categoryarray` array, the sorting behavior for that attribute will be identical to the *trace* mode. The
    // unspecified categories will follow the categories in `categoryarray`. Set `categoryorder` to *total ascending* or
    // *total descending* if order should be determined by the numerical order of the values. Similarly, the order can
    // be determined by the min, max, sum, mean, geometric mean or median of all the values.
    // - Default: trace
    Layout::Polar::Angularaxis& categoryorder(enum Categoryorder f);

    // Sets default for all colors associated with this axis all at once: line, font, tick, and grid colors. Grid color
    // is lightened by blending this with the plot background Individual pieces can override this.
    Layout::Polar::Angularaxis& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Angularaxis& color(Callable&& c);

    // Sets the direction corresponding to positive angles.
    // - Default: counterclockwise
    Layout::Polar::Angularaxis& direction(enum Direction f);

    // Sets the step in-between ticks on this axis. Use with `tick0`. Must be a positive number, or special strings
    // available to *log* and *date* axes. If the axis `type` is *log*, then ticks are set every 10^(n*dtick) where n is
    // the tick number. For example, to set a tick mark at 1, 10, 100, 1000, ... set dtick to 1. To set tick marks at 1,
    // 100, 10000, ... set dtick to 2. To set tick marks at 1, 5, 25, 125, 625, 3125, ... set dtick to log_10(5), or
    // 0.69897000433. *log* has several special values; *L<f>*, where `f` is a positive number, gives ticks linearly
    // spaced in value (but not position). For example `tick0` = 0.1, `dtick` = *L0.5* will put ticks at 0.1,
    // 0.6, 1.1, 1.6 etc. To show powers of 10 plus small digits between, use *D1* (all digits) or *D2* (only 2 and 5).
    // `tick0` is ignored for *D1* and *D2*. If the axis `type` is *date*, then you must convert the time to
    // milliseconds. For example, to set the interval between ticks to one day, set `dtick` to 86400000.0. *date* also
    // has special values *M<n>* gives ticks spaced by a number of months. `n` must be a positive integer. To set ticks
    // on the 15th of every third month, set `tick0` to *2000-01-15* and `dtick` to *M3*. To set ticks every 4 years,
    // set `dtick` to *M48*
    template <typename T>
    Layout::Polar::Angularaxis& dtick(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Polar::Angularaxis& dtick(Callable&& c);

    // Determines a formatting rule for the tick exponents. For example, consider the number 1,000,000,000. If *none*,
    // it appears as 1,000,000,000. If *e*, 1e+9. If *E*, 1E+9. If *power*, 1x10^9 (with 9 in a super script). If *SI*,
    // 1G. If *B*, 1B.
    // - Default: B
    Layout::Polar::Angularaxis& exponentformat(enum Exponentformat f);

    // Sets the color of the grid lines.
    Layout::Polar::Angularaxis& gridcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Angularaxis& gridcolor(Callable&& c);

    // Sets the dash style of lines. Set to a dash type string (*solid*, *dot*, *dash*, *longdash*, *dashdot*, or
    // *longdashdot*) or a dash length list in px (eg *5px,10px,2px,2px*).
    Layout::Polar::Angularaxis& griddash(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Angularaxis& griddash(Callable&& c);

    // Sets the width (in px) of the grid lines.
    Layout::Polar::Angularaxis& gridwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Polar::Angularaxis& gridwidth(Callable&& c);

    // Sets the hover text formatting rule using d3 formatting mini-languages which are very similar to those in Python.
    // For numbers, see: https://github.com/d3/d3-format/tree/v1.4.5#d3-format. And for dates see:
    // https://github.com/d3/d3-time-format/tree/v2.2.3#locale_format. We add two items to d3's date formatter: *%h* for
    // half of the year as a decimal number as well as *%{n}f* for fractional seconds with n digits. For example,
    // *2016-10-13 09:15:23.456* with tickformat *%H~%M~%S.%2f* would display *09~15~23.46*
    Layout::Polar::Angularaxis& hoverformat(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Angularaxis& hoverformat(Callable&& c);

    // Replacement text for specific tick or hover labels. For example using {US: 'USA', CA: 'Canada'} changes US to USA
    // and CA to Canada. The labels we would have shown must match the keys exactly, after adding any tickprefix or
    // ticksuffix. For negative numbers the minus sign symbol used (U+2212) is wider than the regular ascii dash. That
    // means you need to use 1 instead of -1. labelalias can be used with any axis type, and both keys (if needed) and
    // values (if desired) can include html-like tags or MathJax.
    template <typename T>
    Layout::Polar::Angularaxis& labelalias(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Polar::Angularaxis& labelalias(Callable&& c);

    // Sets the layer on which this axis is displayed. If *above traces*, this axis is displayed above all the subplot's
    // traces If *below traces*, this axis is displayed below all the subplot's traces, but above the grid lines. Useful
    // when used together with scatter-like traces with `cliponaxis` set to *false* to show markers and/or text nodes
    // above this axis.
    // - Default: above traces
    Layout::Polar::Angularaxis& layer(enum Layer f);

    // Sets the axis line color.
    Layout::Polar::Angularaxis& linecolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Angularaxis& linecolor(Callable&& c);

    // Sets the width (in px) of the axis line.
    Layout::Polar::Angularaxis& linewidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Polar::Angularaxis& linewidth(Callable&& c);

    // Hide SI prefix for 10^n if |n| is below this number. This only has an effect when `tickformat` is *SI* or *B*.
    Layout::Polar::Angularaxis& minexponent(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Polar::Angularaxis& minexponent(Callable&& c);

    // Specifies the maximum number of ticks for the particular axis. The actual number of ticks will be chosen
    // automatically to be less than or equal to `nticks`. Has an effect only if `tickmode` is set to *auto*.
    Layout::Polar::Angularaxis& nticks(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Polar::Angularaxis& nticks(Callable&& c);

    // Set the angular period. Has an effect only when `angularaxis.type` is *category*.
    Layout::Polar::Angularaxis& period(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Polar::Angularaxis& period(Callable&& c);

    // Sets that start position (in degrees) of the angular axis By default, polar subplots with `direction` set to
    // *counterclockwise* get a `rotation` of *0* which corresponds to due East (like what mathematicians prefer). In
    // turn, polar with `direction` set to *clockwise* get a rotation of *90* which corresponds to due North (like on a
    // compass),
    Layout::Polar::Angularaxis& rotation(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Polar::Angularaxis& rotation(Callable&& c);

    // If "true", even 4-digit integers are separated
    Layout::Polar::Angularaxis& separatethousands(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Polar::Angularaxis& separatethousands(Callable&& c);

    // If *all*, all exponents are shown besides their significands. If *first*, only the exponent of the first tick is
    // shown. If *last*, only the exponent of the last tick is shown. If *none*, no exponents appear.
    // - Default: all
    Layout::Polar::Angularaxis& showexponent(enum Showexponent f);

    // Determines whether or not grid lines are drawn. If *true*, the grid lines are drawn at every tick mark.
    Layout::Polar::Angularaxis& showgrid(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Polar::Angularaxis& showgrid(Callable&& c);

    // Determines whether or not a line bounding this axis is drawn.
    Layout::Polar::Angularaxis& showline(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Polar::Angularaxis& showline(Callable&& c);

    // Determines whether or not the tick labels are drawn.
    Layout::Polar::Angularaxis& showticklabels(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Polar::Angularaxis& showticklabels(Callable&& c);

    // If *all*, all tick labels are displayed with a prefix. If *first*, only the first tick is displayed with a
    // prefix. If *last*, only the last tick is displayed with a suffix. If *none*, tick prefixes are hidden.
    // - Default: all
    Layout::Polar::Angularaxis& showtickprefix(enum Showtickprefix f);

    // Same as `showtickprefix` but for tick suffixes.
    // - Default: all
    Layout::Polar::Angularaxis& showticksuffix(enum Showticksuffix f);

    // Sets the format unit of the formatted *theta* values. Has an effect only when `angularaxis.type` is *linear*.
    // - Default: degrees
    Layout::Polar::Angularaxis& thetaunit(enum Thetaunit f);

    // Sets the placement of the first tick on this axis. Use with `dtick`. If the axis `type` is *log*, then you must
    // take the log of your starting tick (e.g. to set the starting tick to 100, set the `tick0` to 2) except when
    // `dtick`=*L<f>* (see `dtick` for more info). If the axis `type` is *date*, it should be a date string, like date
    // data. If the axis `type` is *category*, it should be a number, using the scale where each category is assigned a
    // serial number from zero in the order it appears.
    template <typename T>
    Layout::Polar::Angularaxis& tick0(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Polar::Angularaxis& tick0(Callable&& c);

    // Sets the angle of the tick labels with respect to the horizontal. For example, a `tickangle` of -90 draws the
    // tick labels vertically.
    Layout::Polar::Angularaxis& tickangle(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Polar::Angularaxis& tickangle(Callable&& c);

    // Sets the tick color.
    Layout::Polar::Angularaxis& tickcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Angularaxis& tickcolor(Callable&& c);

    // Sets the tick font.
    Layout::Polar::Angularaxis& tickfont(Tickfont f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Tickfont&>>>
    Layout::Polar::Angularaxis& tickfont(Callable&& c);

    // Sets the tick label formatting rule using d3 formatting mini-languages which are very similar to those in Python.
    // For numbers, see: https://github.com/d3/d3-format/tree/v1.4.5#d3-format. And for dates see:
    // https://github.com/d3/d3-time-format/tree/v2.2.3#locale_format. We add two items to d3's date formatter: *%h* for
    // half of the year as a decimal number as well as *%{n}f* for fractional seconds with n digits. For example,
    // *2016-10-13 09:15:23.456* with tickformat *%H~%M~%S.%2f* would display *09~15~23.46*
    Layout::Polar::Angularaxis& tickformat(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Angularaxis& tickformat(Callable&& c);

    Layout::Polar::Angularaxis& tickformatstops(Tickformatstops f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Tickformatstops&>>>
    Layout::Polar::Angularaxis& tickformatstops(Callable&& c);

    // Sets the spacing between tick labels as compared to the spacing between ticks. A value of 1 (default) means each
    // tick gets a label. A value of 2 means shows every 2nd label. A larger value n means only every nth tick is
    // labeled. `tick0` determines which labels are shown. Not implemented for axes with `type` *log* or
    // *multicategory*, or when `tickmode` is *array*.
    Layout::Polar::Angularaxis& ticklabelstep(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Polar::Angularaxis& ticklabelstep(Callable&& c);

    // Sets the tick length (in px).
    Layout::Polar::Angularaxis& ticklen(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Polar::Angularaxis& ticklen(Callable&& c);

    // Sets the tick mode for this axis. If *auto*, the number of ticks is set via `nticks`. If *linear*, the placement
    // of the ticks is determined by a starting position `tick0` and a tick step `dtick` (*linear* is the default value
    // if `tick0` and `dtick` are provided). If *array*, the placement of the ticks is set via `tickvals` and the tick
    // text is `ticktext`. (*array* is the default value if `tickvals` is provided).
    Layout::Polar::Angularaxis& tickmode(enum Tickmode f);

    // Sets a tick label prefix.
    Layout::Polar::Angularaxis& tickprefix(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Angularaxis& tickprefix(Callable&& c);

    // Determines whether ticks are drawn or not. If **, this axis' ticks are not drawn. If *outside* (*inside*), this
    // axis' are drawn outside (inside) the axis lines.
    Layout::Polar::Angularaxis& ticks(enum Ticks f);

    // Sets a tick label suffix.
    Layout::Polar::Angularaxis& ticksuffix(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Angularaxis& ticksuffix(Callable&& c);

    // Sets the text displayed at the ticks position via `tickvals`. Only has an effect if `tickmode` is set to *array*.
    // Used with `tickvals`.
    template <typename T, typename = std::enable_if_t<is_data_array_element_v<T>>>
    Layout::Polar::Angularaxis& ticktext(const std::vector<T>& f);
    template <
        typename T, typename Callable,
        typename = std::enable_if_t<is_data_array_element_v<T> && (std::is_invocable_v<Callable, std::vector<T>&>)>>
    Layout::Polar::Angularaxis& ticktext(Callable&& c);

    // Sets the source reference on Chart Studio Cloud for `ticktext`.
    Layout::Polar::Angularaxis& ticktextsrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Angularaxis& ticktextsrc(Callable&& c);

    // Sets the values at which ticks on this axis appear. Only has an effect if `tickmode` is set to *array*. Used with
    // `ticktext`.
    template <typename T, typename = std::enable_if_t<is_data_array_element_v<T>>>
    Layout::Polar::Angularaxis& tickvals(const std::vector<T>& f);
    template <
        typename T, typename Callable,
        typename = std::enable_if_t<is_data_array_element_v<T> && (std::is_invocable_v<Callable, std::vector<T>&>)>>
    Layout::Polar::Angularaxis& tickvals(Callable&& c);

    // Sets the source reference on Chart Studio Cloud for `tickvals`.
    Layout::Polar::Angularaxis& tickvalssrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Angularaxis& tickvalssrc(Callable&& c);

    // Sets the tick width (in px).
    Layout::Polar::Angularaxis& tickwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Polar::Angularaxis& tickwidth(Callable&& c);

    // Sets the angular axis type. If *linear*, set `thetaunit` to determine the unit in which axis value are shown. If
    // *category, use `period` to set the number of integer coordinates around polar axis.
    // - Default: -
    Layout::Polar::Angularaxis& type(enum Type f);

    // Controls persistence of user-driven changes in axis `rotation`. Defaults to `polar<N>.uirevision`.
    template <typename T>
    Layout::Polar::Angularaxis& uirevision(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Polar::Angularaxis& uirevision(Callable&& c);

    // A single toggle to hide the axis while preserving interaction like dragging. Default is true when a cheater plot
    // is present on the axis, otherwise false
    Layout::Polar::Angularaxis& visible(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Polar::Angularaxis& visible(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets the tick font.
class Layout::Polar::Angularaxis::Tickfont {
 public:
    Tickfont() = default;
    Tickfont(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    enum class Textcase {
        Normal,
        WordCaps,
        Upper,
        Lower,
    };
    static std::string to_string(Textcase e);

    enum class Variant {
        Normal,
        SmallCaps,
        AllSmallCaps,
        AllPetiteCaps,
        PetiteCaps,
        Unicase,
    };
    static std::string to_string(Variant e);

    Layout::Polar::Angularaxis::Tickfont& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Angularaxis::Tickfont& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Polar::Angularaxis::Tickfont& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Angularaxis::Tickfont& family(Callable&& c);

    // Sets the kind of decoration line(s) with text, such as an *under*, *over* or *through* as well as combinations
    // e.g. *under+over*, etc.
    // - Default: none
    // - Flags: ['under', 'over', 'through']
    // - Extras ['none']
    Layout::Polar::Angularaxis::Tickfont& lineposition(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Angularaxis::Tickfont& lineposition(Callable&& c);

    // Sets the shape and color of the shadow behind text. *auto* places minimal shadow and applies contrast text font
    // color. See https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow for additional options.
    Layout::Polar::Angularaxis::Tickfont& shadow(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Angularaxis::Tickfont& shadow(Callable&& c);

    Layout::Polar::Angularaxis::Tickfont& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Polar::Angularaxis::Tickfont& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Polar::Angularaxis::Tickfont& style(enum Style f);

    // Sets capitalization of text. It can be used to make text appear in all-uppercase or all-lowercase, or with each
    // word capitalized.
    // - Default: normal
    Layout::Polar::Angularaxis::Tickfont& textcase(enum Textcase f);

    // Sets the variant of the font.
    // - Default: normal
    Layout::Polar::Angularaxis::Tickfont& variant(enum Variant f);

    // Sets the weight (or boldness) of the font.
    Layout::Polar::Angularaxis::Tickfont& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Polar::Angularaxis::Tickfont& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Polar::Angularaxis::Tickformatstops {
 public:
    Tickformatstops() = default;
    Tickformatstops(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    class Tickformatstop;

    Layout::Polar::Angularaxis::Tickformatstops& tickformatstop(Tickformatstop f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Tickformatstop&>>>
    Layout::Polar::Angularaxis::Tickformatstops& tickformatstop(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Polar::Angularaxis::Tickformatstops::Tickformatstop {
 public:
    Tickformatstop() = default;
    Tickformatstop(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // range [*min*, *max*], where *min*, *max* - dtick values which describe some zoom level, it is possible to omit
    // *min* or *max* value by passing *null*
    Layout::Polar::Angularaxis::Tickformatstops::Tickformatstop& dtickrange(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Polar::Angularaxis::Tickformatstops::Tickformatstop& dtickrange(Callable&& c);

    // Determines whether or not this stop is used. If `false`, this stop is ignored even within its `dtickrange`.
    Layout::Polar::Angularaxis::Tickformatstops::Tickformatstop& enabled(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Polar::Angularaxis::Tickformatstops::Tickformatstop& enabled(Callable&& c);

    // When used in a template, named items are created in the output figure in addition to any items the figure already
    // has in this array. You can modify these items in the output figure by making your own item with
    // `templateitemname` matching this `name` alongside your modifications (including `visible: false` or `enabled:
    // false` to hide it). Has no effect outside of a template.
    Layout::Polar::Angularaxis::Tickformatstops::Tickformatstop& name(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Angularaxis::Tickformatstops::Tickformatstop& name(Callable&& c);

    // Used to refer to a named item in this array in the template. Named items from the template will be created even
    // without a matching item in the input figure, but you can modify one by making an item with `templateitemname`
    // matching its `name`, alongside your modifications (including `visible: false` or `enabled: false` to hide it). If
    // there is no template or no matching item, this item will be hidden unless you explicitly show it with `visible:
    // true`.
    Layout::Polar::Angularaxis::Tickformatstops::Tickformatstop& templateitemname(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Angularaxis::Tickformatstops::Tickformatstop& templateitemname(Callable&& c);

    // string - dtickformat for described zoom level, the same as *tickformat*
    Layout::Polar::Angularaxis::Tickformatstops::Tickformatstop& value(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Angularaxis::Tickformatstops::Tickformatstop& value(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Polar::Domain {
 public:
    Domain() = default;
    Domain(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // If there is a layout grid, use the domain for this column in the grid for this polar subplot .
    Layout::Polar::Domain& column(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Polar::Domain& column(Callable&& c);

    // If there is a layout grid, use the domain for this row in the grid for this polar subplot .
    Layout::Polar::Domain& row(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Polar::Domain& row(Callable&& c);

    // Sets the horizontal domain of this polar subplot (in plot fraction).
    Layout::Polar::Domain& x(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Polar::Domain& x(Callable&& c);

    // Sets the vertical domain of this polar subplot (in plot fraction).
    Layout::Polar::Domain& y(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Polar::Domain& y(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Polar::Radialaxis {
 public:
    Radialaxis() = default;
    Radialaxis(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Autorange {
        True,
        False,
        Reversed,
        MinReversed,
        MaxReversed,
        Min,
        Max,
    };
    static std::string to_string(Autorange e);

    enum class Autotypenumbers {
        ConvertTypes,
        Strict,
    };
    static std::string to_string(Autotypenumbers e);

    enum class Calendar {
        Chinese,
        Coptic,
        Discworld,
        Ethiopian,
        Gregorian,
        Hebrew,
        Islamic,
        Jalali,
        Julian,
        Mayan,
        Nanakshahi,
        Nepali,
        Persian,
        Taiwan,
        Thai,
        Ummalqura,
    };
    static std::string to_string(Calendar e);

    enum class Categoryorder {
        Trace,
        CategoryAscending,
        CategoryDescending,
        Array,
        TotalAscending,
        TotalDescending,
        MinAscending,
        MinDescending,
        MaxAscending,
        MaxDescending,
        SumAscending,
        SumDescending,
        MeanAscending,
        MeanDescending,
        GeometricMeanAscending,
        GeometricMeanDescending,
        MedianAscending,
        MedianDescending,
    };
    static std::string to_string(Categoryorder e);

    enum class Exponentformat {
        None,
        E,
        Power,
        Si,
        B,
    };
    static std::string to_string(Exponentformat e);

    enum class Layer {
        AboveTraces,
        BelowTraces,
    };
    static std::string to_string(Layer e);

    enum class Rangemode {
        Tozero,
        Nonnegative,
        Normal,
    };
    static std::string to_string(Rangemode e);

    enum class Showexponent {
        All,
        First,
        Last,
        None,
    };
    static std::string to_string(Showexponent e);

    enum class Showtickprefix {
        All,
        First,
        Last,
        None,
    };
    static std::string to_string(Showtickprefix e);

    enum class Showticksuffix {
        All,
        First,
        Last,
        None,
    };
    static std::string to_string(Showticksuffix e);

    enum class Side {
        Clockwise,
        Counterclockwise,
    };
    static std::string to_string(Side e);

    enum class Tickmode {
        Auto,
        Linear,
        Array,
    };
    static std::string to_string(Tickmode e);

    enum class Ticks {
        Outside,
        Inside,
        Empty,
    };
    static std::string to_string(Ticks e);

    enum class Type {
        Hyphen,
        Linear,
        Log,
        Date,
        Category,
    };
    static std::string to_string(Type e);

    class Autorangeoptions;
    // Sets the tick font.
    class Tickfont;
    class Tickformatstops;
    class Title;

    // Sets the angle (in degrees) from which the radial axis is drawn. Note that by default, radial axis line on the
    // theta=0 line corresponds to a line pointing right (like what mathematicians prefer). Defaults to the first
    // `polar.sector` angle.
    Layout::Polar::Radialaxis& angle(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Polar::Radialaxis& angle(Callable&& c);

    // Determines whether or not the range of this axis is computed in relation to the input data. See `rangemode` for
    // more info. If `range` is provided and it has a value for both the lower and upper bound, `autorange` is set to
    // *false*. Using *min* applies autorange only to set the minimum. Using *max* applies autorange only to set the
    // maximum. Using *min reversed* applies autorange only to set the minimum on a reversed axis. Using *max reversed*
    // applies autorange only to set the maximum on a reversed axis. Using *reversed* applies autorange on both ends and
    // reverses the axis direction.
    // - Default: True
    Layout::Polar::Radialaxis& autorange(enum Autorange f);

    Layout::Polar::Radialaxis& autorangeoptions(Autorangeoptions f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Autorangeoptions&>>>
    Layout::Polar::Radialaxis& autorangeoptions(Callable&& c);

    // When `tickangle` is set to *auto*, it will be set to the first angle in this array that is large enough to
    // prevent label overlap.
    Layout::Polar::Radialaxis& autotickangles(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Polar::Radialaxis& autotickangles(Callable&& c);

    // Using *strict* a numeric string in trace data is not converted to a number. Using *convert types* a numeric
    // string in trace data may be treated as a number during automatic axis `type` detection. Defaults to
    // layout.autotypenumbers.
    // - Default: convert types
    Layout::Polar::Radialaxis& autotypenumbers(enum Autotypenumbers f);

    // Sets the calendar system to use for `range` and `tick0` if this is a date axis. This does not set the calendar
    // for interpreting data on this axis, that's specified in the trace or via the global `layout.calendar`
    // - Default: gregorian
    Layout::Polar::Radialaxis& calendar(enum Calendar f);

    // Sets the order in which categories on this axis appear. Only has an effect if `categoryorder` is set to *array*.
    // Used with `categoryorder`.
    template <typename T, typename = std::enable_if_t<is_data_array_element_v<T>>>
    Layout::Polar::Radialaxis& categoryarray(const std::vector<T>& f);
    template <
        typename T, typename Callable,
        typename = std::enable_if_t<is_data_array_element_v<T> && (std::is_invocable_v<Callable, std::vector<T>&>)>>
    Layout::Polar::Radialaxis& categoryarray(Callable&& c);

    // Sets the source reference on Chart Studio Cloud for `categoryarray`.
    Layout::Polar::Radialaxis& categoryarraysrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Radialaxis& categoryarraysrc(Callable&& c);

    // Specifies the ordering logic for the case of categorical variables. By default, plotly uses *trace*, which
    // specifies the order that is present in the data supplied. Set `categoryorder` to *category ascending* or
    // *category descending* if order should be determined by the alphanumerical order of the category names. Set
    // `categoryorder` to *array* to derive the ordering from the attribute `categoryarray`. If a category is not found
    // in the `categoryarray` array, the sorting behavior for that attribute will be identical to the *trace* mode. The
    // unspecified categories will follow the categories in `categoryarray`. Set `categoryorder` to *total ascending* or
    // *total descending* if order should be determined by the numerical order of the values. Similarly, the order can
    // be determined by the min, max, sum, mean, geometric mean or median of all the values.
    // - Default: trace
    Layout::Polar::Radialaxis& categoryorder(enum Categoryorder f);

    // Sets default for all colors associated with this axis all at once: line, font, tick, and grid colors. Grid color
    // is lightened by blending this with the plot background Individual pieces can override this.
    Layout::Polar::Radialaxis& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Radialaxis& color(Callable&& c);

    // Sets the step in-between ticks on this axis. Use with `tick0`. Must be a positive number, or special strings
    // available to *log* and *date* axes. If the axis `type` is *log*, then ticks are set every 10^(n*dtick) where n is
    // the tick number. For example, to set a tick mark at 1, 10, 100, 1000, ... set dtick to 1. To set tick marks at 1,
    // 100, 10000, ... set dtick to 2. To set tick marks at 1, 5, 25, 125, 625, 3125, ... set dtick to log_10(5), or
    // 0.69897000433. *log* has several special values; *L<f>*, where `f` is a positive number, gives ticks linearly
    // spaced in value (but not position). For example `tick0` = 0.1, `dtick` = *L0.5* will put ticks at 0.1,
    // 0.6, 1.1, 1.6 etc. To show powers of 10 plus small digits between, use *D1* (all digits) or *D2* (only 2 and 5).
    // `tick0` is ignored for *D1* and *D2*. If the axis `type` is *date*, then you must convert the time to
    // milliseconds. For example, to set the interval between ticks to one day, set `dtick` to 86400000.0. *date* also
    // has special values *M<n>* gives ticks spaced by a number of months. `n` must be a positive integer. To set ticks
    // on the 15th of every third month, set `tick0` to *2000-01-15* and `dtick` to *M3*. To set ticks every 4 years,
    // set `dtick` to *M48*
    template <typename T>
    Layout::Polar::Radialaxis& dtick(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Polar::Radialaxis& dtick(Callable&& c);

    // Determines a formatting rule for the tick exponents. For example, consider the number 1,000,000,000. If *none*,
    // it appears as 1,000,000,000. If *e*, 1e+9. If *E*, 1E+9. If *power*, 1x10^9 (with 9 in a super script). If *SI*,
    // 1G. If *B*, 1B.
    // - Default: B
    Layout::Polar::Radialaxis& exponentformat(enum Exponentformat f);

    // Sets the color of the grid lines.
    Layout::Polar::Radialaxis& gridcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Radialaxis& gridcolor(Callable&& c);

    // Sets the dash style of lines. Set to a dash type string (*solid*, *dot*, *dash*, *longdash*, *dashdot*, or
    // *longdashdot*) or a dash length list in px (eg *5px,10px,2px,2px*).
    Layout::Polar::Radialaxis& griddash(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Radialaxis& griddash(Callable&& c);

    // Sets the width (in px) of the grid lines.
    Layout::Polar::Radialaxis& gridwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Polar::Radialaxis& gridwidth(Callable&& c);

    // Sets the hover text formatting rule using d3 formatting mini-languages which are very similar to those in Python.
    // For numbers, see: https://github.com/d3/d3-format/tree/v1.4.5#d3-format. And for dates see:
    // https://github.com/d3/d3-time-format/tree/v2.2.3#locale_format. We add two items to d3's date formatter: *%h* for
    // half of the year as a decimal number as well as *%{n}f* for fractional seconds with n digits. For example,
    // *2016-10-13 09:15:23.456* with tickformat *%H~%M~%S.%2f* would display *09~15~23.46*
    Layout::Polar::Radialaxis& hoverformat(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Radialaxis& hoverformat(Callable&& c);

    // Replacement text for specific tick or hover labels. For example using {US: 'USA', CA: 'Canada'} changes US to USA
    // and CA to Canada. The labels we would have shown must match the keys exactly, after adding any tickprefix or
    // ticksuffix. For negative numbers the minus sign symbol used (U+2212) is wider than the regular ascii dash. That
    // means you need to use 1 instead of -1. labelalias can be used with any axis type, and both keys (if needed) and
    // values (if desired) can include html-like tags or MathJax.
    template <typename T>
    Layout::Polar::Radialaxis& labelalias(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Polar::Radialaxis& labelalias(Callable&& c);

    // Sets the layer on which this axis is displayed. If *above traces*, this axis is displayed above all the subplot's
    // traces If *below traces*, this axis is displayed below all the subplot's traces, but above the grid lines. Useful
    // when used together with scatter-like traces with `cliponaxis` set to *false* to show markers and/or text nodes
    // above this axis.
    // - Default: above traces
    Layout::Polar::Radialaxis& layer(enum Layer f);

    // Sets the axis line color.
    Layout::Polar::Radialaxis& linecolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Radialaxis& linecolor(Callable&& c);

    // Sets the width (in px) of the axis line.
    Layout::Polar::Radialaxis& linewidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Polar::Radialaxis& linewidth(Callable&& c);

    // Determines the maximum range of this axis.
    template <typename T>
    Layout::Polar::Radialaxis& maxallowed(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Polar::Radialaxis& maxallowed(Callable&& c);

    // Determines the minimum range of this axis.
    template <typename T>
    Layout::Polar::Radialaxis& minallowed(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Polar::Radialaxis& minallowed(Callable&& c);

    // Hide SI prefix for 10^n if |n| is below this number. This only has an effect when `tickformat` is *SI* or *B*.
    Layout::Polar::Radialaxis& minexponent(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Polar::Radialaxis& minexponent(Callable&& c);

    // Specifies the maximum number of ticks for the particular axis. The actual number of ticks will be chosen
    // automatically to be less than or equal to `nticks`. Has an effect only if `tickmode` is set to *auto*.
    Layout::Polar::Radialaxis& nticks(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Polar::Radialaxis& nticks(Callable&& c);

    // Sets the range of this axis. If the axis `type` is *log*, then you must take the log of your desired range (e.g.
    // to set the range from 1 to 100, set the range from 0 to 2). If the axis `type` is *date*, it should be date
    // strings, like date data, though Date objects and unix milliseconds will be accepted and converted to strings. If
    // the axis `type` is *category*, it should be numbers, using the scale where each category is assigned a serial
    // number from zero in the order it appears. Leaving either or both elements `null` impacts the default `autorange`.
    Layout::Polar::Radialaxis& range(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Polar::Radialaxis& range(Callable&& c);

    // If *tozero*`, the range extends to 0, regardless of the input data If *nonnegative*, the range is non-negative,
    // regardless of the input data. If *normal*, the range is computed in relation to the extrema of the input data
    // (same behavior as for cartesian axes).
    // - Default: tozero
    Layout::Polar::Radialaxis& rangemode(enum Rangemode f);

    // If "true", even 4-digit integers are separated
    Layout::Polar::Radialaxis& separatethousands(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Polar::Radialaxis& separatethousands(Callable&& c);

    // If *all*, all exponents are shown besides their significands. If *first*, only the exponent of the first tick is
    // shown. If *last*, only the exponent of the last tick is shown. If *none*, no exponents appear.
    // - Default: all
    Layout::Polar::Radialaxis& showexponent(enum Showexponent f);

    // Determines whether or not grid lines are drawn. If *true*, the grid lines are drawn at every tick mark.
    Layout::Polar::Radialaxis& showgrid(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Polar::Radialaxis& showgrid(Callable&& c);

    // Determines whether or not a line bounding this axis is drawn.
    Layout::Polar::Radialaxis& showline(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Polar::Radialaxis& showline(Callable&& c);

    // Determines whether or not the tick labels are drawn.
    Layout::Polar::Radialaxis& showticklabels(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Polar::Radialaxis& showticklabels(Callable&& c);

    // If *all*, all tick labels are displayed with a prefix. If *first*, only the first tick is displayed with a
    // prefix. If *last*, only the last tick is displayed with a suffix. If *none*, tick prefixes are hidden.
    // - Default: all
    Layout::Polar::Radialaxis& showtickprefix(enum Showtickprefix f);

    // Same as `showtickprefix` but for tick suffixes.
    // - Default: all
    Layout::Polar::Radialaxis& showticksuffix(enum Showticksuffix f);

    // Determines on which side of radial axis line the tick and tick labels appear.
    // - Default: clockwise
    Layout::Polar::Radialaxis& side(enum Side f);

    // Sets the placement of the first tick on this axis. Use with `dtick`. If the axis `type` is *log*, then you must
    // take the log of your starting tick (e.g. to set the starting tick to 100, set the `tick0` to 2) except when
    // `dtick`=*L<f>* (see `dtick` for more info). If the axis `type` is *date*, it should be a date string, like date
    // data. If the axis `type` is *category*, it should be a number, using the scale where each category is assigned a
    // serial number from zero in the order it appears.
    template <typename T>
    Layout::Polar::Radialaxis& tick0(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Polar::Radialaxis& tick0(Callable&& c);

    // Sets the angle of the tick labels with respect to the horizontal. For example, a `tickangle` of -90 draws the
    // tick labels vertically.
    Layout::Polar::Radialaxis& tickangle(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Polar::Radialaxis& tickangle(Callable&& c);

    // Sets the tick color.
    Layout::Polar::Radialaxis& tickcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Radialaxis& tickcolor(Callable&& c);

    // Sets the tick font.
    Layout::Polar::Radialaxis& tickfont(Tickfont f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Tickfont&>>>
    Layout::Polar::Radialaxis& tickfont(Callable&& c);

    // Sets the tick label formatting rule using d3 formatting mini-languages which are very similar to those in Python.
    // For numbers, see: https://github.com/d3/d3-format/tree/v1.4.5#d3-format. And for dates see:
    // https://github.com/d3/d3-time-format/tree/v2.2.3#locale_format. We add two items to d3's date formatter: *%h* for
    // half of the year as a decimal number as well as *%{n}f* for fractional seconds with n digits. For example,
    // *2016-10-13 09:15:23.456* with tickformat *%H~%M~%S.%2f* would display *09~15~23.46*
    Layout::Polar::Radialaxis& tickformat(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Radialaxis& tickformat(Callable&& c);

    Layout::Polar::Radialaxis& tickformatstops(Tickformatstops f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Tickformatstops&>>>
    Layout::Polar::Radialaxis& tickformatstops(Callable&& c);

    // Sets the spacing between tick labels as compared to the spacing between ticks. A value of 1 (default) means each
    // tick gets a label. A value of 2 means shows every 2nd label. A larger value n means only every nth tick is
    // labeled. `tick0` determines which labels are shown. Not implemented for axes with `type` *log* or
    // *multicategory*, or when `tickmode` is *array*.
    Layout::Polar::Radialaxis& ticklabelstep(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Polar::Radialaxis& ticklabelstep(Callable&& c);

    // Sets the tick length (in px).
    Layout::Polar::Radialaxis& ticklen(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Polar::Radialaxis& ticklen(Callable&& c);

    // Sets the tick mode for this axis. If *auto*, the number of ticks is set via `nticks`. If *linear*, the placement
    // of the ticks is determined by a starting position `tick0` and a tick step `dtick` (*linear* is the default value
    // if `tick0` and `dtick` are provided). If *array*, the placement of the ticks is set via `tickvals` and the tick
    // text is `ticktext`. (*array* is the default value if `tickvals` is provided).
    Layout::Polar::Radialaxis& tickmode(enum Tickmode f);

    // Sets a tick label prefix.
    Layout::Polar::Radialaxis& tickprefix(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Radialaxis& tickprefix(Callable&& c);

    // Determines whether ticks are drawn or not. If **, this axis' ticks are not drawn. If *outside* (*inside*), this
    // axis' are drawn outside (inside) the axis lines.
    Layout::Polar::Radialaxis& ticks(enum Ticks f);

    // Sets a tick label suffix.
    Layout::Polar::Radialaxis& ticksuffix(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Radialaxis& ticksuffix(Callable&& c);

    // Sets the text displayed at the ticks position via `tickvals`. Only has an effect if `tickmode` is set to *array*.
    // Used with `tickvals`.
    template <typename T, typename = std::enable_if_t<is_data_array_element_v<T>>>
    Layout::Polar::Radialaxis& ticktext(const std::vector<T>& f);
    template <
        typename T, typename Callable,
        typename = std::enable_if_t<is_data_array_element_v<T> && (std::is_invocable_v<Callable, std::vector<T>&>)>>
    Layout::Polar::Radialaxis& ticktext(Callable&& c);

    // Sets the source reference on Chart Studio Cloud for `ticktext`.
    Layout::Polar::Radialaxis& ticktextsrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Radialaxis& ticktextsrc(Callable&& c);

    // Sets the values at which ticks on this axis appear. Only has an effect if `tickmode` is set to *array*. Used with
    // `ticktext`.
    template <typename T, typename = std::enable_if_t<is_data_array_element_v<T>>>
    Layout::Polar::Radialaxis& tickvals(const std::vector<T>& f);
    template <
        typename T, typename Callable,
        typename = std::enable_if_t<is_data_array_element_v<T> && (std::is_invocable_v<Callable, std::vector<T>&>)>>
    Layout::Polar::Radialaxis& tickvals(Callable&& c);

    // Sets the source reference on Chart Studio Cloud for `tickvals`.
    Layout::Polar::Radialaxis& tickvalssrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Radialaxis& tickvalssrc(Callable&& c);

    // Sets the tick width (in px).
    Layout::Polar::Radialaxis& tickwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Polar::Radialaxis& tickwidth(Callable&& c);

    Layout::Polar::Radialaxis& title(Title f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Title&>>>
    Layout::Polar::Radialaxis& title(Callable&& c);

    // Sets the axis type. By default, plotly attempts to determined the axis type by looking into the data of the
    // traces that referenced the axis in question.
    // - Default: -
    Layout::Polar::Radialaxis& type(enum Type f);

    // Controls persistence of user-driven changes in axis `range`, `autorange`, `angle`, and `title` if in `editable:
    // true` configuration. Defaults to `polar<N>.uirevision`.
    template <typename T>
    Layout::Polar::Radialaxis& uirevision(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Polar::Radialaxis& uirevision(Callable&& c);

    // A single toggle to hide the axis while preserving interaction like dragging. Default is true when a cheater plot
    // is present on the axis, otherwise false
    Layout::Polar::Radialaxis& visible(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Polar::Radialaxis& visible(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Polar::Radialaxis::Autorangeoptions {
 public:
    Autorangeoptions() = default;
    Autorangeoptions(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Clip autorange maximum if it goes beyond this value. Has no effect when `autorangeoptions.maxallowed` is
    // provided.
    template <typename T>
    Layout::Polar::Radialaxis::Autorangeoptions& clipmax(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Polar::Radialaxis::Autorangeoptions& clipmax(Callable&& c);

    // Clip autorange minimum if it goes beyond this value. Has no effect when `autorangeoptions.minallowed` is
    // provided.
    template <typename T>
    Layout::Polar::Radialaxis::Autorangeoptions& clipmin(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Polar::Radialaxis::Autorangeoptions& clipmin(Callable&& c);

    // Ensure this value is included in autorange.
    template <typename T>
    Layout::Polar::Radialaxis::Autorangeoptions& include(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Polar::Radialaxis::Autorangeoptions& include(Callable&& c);
    template <typename T>
    Layout::Polar::Radialaxis::Autorangeoptions& include(const std::vector<T>& f);

    // Sets the source reference on Chart Studio Cloud for `include`.
    Layout::Polar::Radialaxis::Autorangeoptions& includesrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Radialaxis::Autorangeoptions& includesrc(Callable&& c);

    // Use this value exactly as autorange maximum.
    template <typename T>
    Layout::Polar::Radialaxis::Autorangeoptions& maxallowed(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Polar::Radialaxis::Autorangeoptions& maxallowed(Callable&& c);

    // Use this value exactly as autorange minimum.
    template <typename T>
    Layout::Polar::Radialaxis::Autorangeoptions& minallowed(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Polar::Radialaxis::Autorangeoptions& minallowed(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets the tick font.
class Layout::Polar::Radialaxis::Tickfont {
 public:
    Tickfont() = default;
    Tickfont(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    enum class Textcase {
        Normal,
        WordCaps,
        Upper,
        Lower,
    };
    static std::string to_string(Textcase e);

    enum class Variant {
        Normal,
        SmallCaps,
        AllSmallCaps,
        AllPetiteCaps,
        PetiteCaps,
        Unicase,
    };
    static std::string to_string(Variant e);

    Layout::Polar::Radialaxis::Tickfont& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Radialaxis::Tickfont& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Polar::Radialaxis::Tickfont& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Radialaxis::Tickfont& family(Callable&& c);

    // Sets the kind of decoration line(s) with text, such as an *under*, *over* or *through* as well as combinations
    // e.g. *under+over*, etc.
    // - Default: none
    // - Flags: ['under', 'over', 'through']
    // - Extras ['none']
    Layout::Polar::Radialaxis::Tickfont& lineposition(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Radialaxis::Tickfont& lineposition(Callable&& c);

    // Sets the shape and color of the shadow behind text. *auto* places minimal shadow and applies contrast text font
    // color. See https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow for additional options.
    Layout::Polar::Radialaxis::Tickfont& shadow(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Radialaxis::Tickfont& shadow(Callable&& c);

    Layout::Polar::Radialaxis::Tickfont& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Polar::Radialaxis::Tickfont& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Polar::Radialaxis::Tickfont& style(enum Style f);

    // Sets capitalization of text. It can be used to make text appear in all-uppercase or all-lowercase, or with each
    // word capitalized.
    // - Default: normal
    Layout::Polar::Radialaxis::Tickfont& textcase(enum Textcase f);

    // Sets the variant of the font.
    // - Default: normal
    Layout::Polar::Radialaxis::Tickfont& variant(enum Variant f);

    // Sets the weight (or boldness) of the font.
    Layout::Polar::Radialaxis::Tickfont& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Polar::Radialaxis::Tickfont& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Polar::Radialaxis::Tickformatstops {
 public:
    Tickformatstops() = default;
    Tickformatstops(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    class Tickformatstop;

    Layout::Polar::Radialaxis::Tickformatstops& tickformatstop(Tickformatstop f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Tickformatstop&>>>
    Layout::Polar::Radialaxis::Tickformatstops& tickformatstop(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Polar::Radialaxis::Tickformatstops::Tickformatstop {
 public:
    Tickformatstop() = default;
    Tickformatstop(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // range [*min*, *max*], where *min*, *max* - dtick values which describe some zoom level, it is possible to omit
    // *min* or *max* value by passing *null*
    Layout::Polar::Radialaxis::Tickformatstops::Tickformatstop& dtickrange(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Polar::Radialaxis::Tickformatstops::Tickformatstop& dtickrange(Callable&& c);

    // Determines whether or not this stop is used. If `false`, this stop is ignored even within its `dtickrange`.
    Layout::Polar::Radialaxis::Tickformatstops::Tickformatstop& enabled(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Polar::Radialaxis::Tickformatstops::Tickformatstop& enabled(Callable&& c);

    // When used in a template, named items are created in the output figure in addition to any items the figure already
    // has in this array. You can modify these items in the output figure by making your own item with
    // `templateitemname` matching this `name` alongside your modifications (including `visible: false` or `enabled:
    // false` to hide it). Has no effect outside of a template.
    Layout::Polar::Radialaxis::Tickformatstops::Tickformatstop& name(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Radialaxis::Tickformatstops::Tickformatstop& name(Callable&& c);

    // Used to refer to a named item in this array in the template. Named items from the template will be created even
    // without a matching item in the input figure, but you can modify one by making an item with `templateitemname`
    // matching its `name`, alongside your modifications (including `visible: false` or `enabled: false` to hide it). If
    // there is no template or no matching item, this item will be hidden unless you explicitly show it with `visible:
    // true`.
    Layout::Polar::Radialaxis::Tickformatstops::Tickformatstop& templateitemname(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Radialaxis::Tickformatstops::Tickformatstop& templateitemname(Callable&& c);

    // string - dtickformat for described zoom level, the same as *tickformat*
    Layout::Polar::Radialaxis::Tickformatstops::Tickformatstop& value(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Radialaxis::Tickformatstops::Tickformatstop& value(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Polar::Radialaxis::Title {
 public:
    Title() = default;
    Title(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Sets this axis' title font.
    class Font;

    // Sets this axis' title font.
    Layout::Polar::Radialaxis::Title& font(Font f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Font&>>>
    Layout::Polar::Radialaxis::Title& font(Callable&& c);

    // Sets the title of this axis.
    Layout::Polar::Radialaxis::Title& text(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Radialaxis::Title& text(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets this axis' title font.
class Layout::Polar::Radialaxis::Title::Font {
 public:
    Font() = default;
    Font(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    enum class Textcase {
        Normal,
        WordCaps,
        Upper,
        Lower,
    };
    static std::string to_string(Textcase e);

    enum class Variant {
        Normal,
        SmallCaps,
        AllSmallCaps,
        AllPetiteCaps,
        PetiteCaps,
        Unicase,
    };
    static std::string to_string(Variant e);

    Layout::Polar::Radialaxis::Title::Font& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Radialaxis::Title::Font& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Polar::Radialaxis::Title::Font& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Radialaxis::Title::Font& family(Callable&& c);

    // Sets the kind of decoration line(s) with text, such as an *under*, *over* or *through* as well as combinations
    // e.g. *under+over*, etc.
    // - Default: none
    // - Flags: ['under', 'over', 'through']
    // - Extras ['none']
    Layout::Polar::Radialaxis::Title::Font& lineposition(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Radialaxis::Title::Font& lineposition(Callable&& c);

    // Sets the shape and color of the shadow behind text. *auto* places minimal shadow and applies contrast text font
    // color. See https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow for additional options.
    Layout::Polar::Radialaxis::Title::Font& shadow(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Polar::Radialaxis::Title::Font& shadow(Callable&& c);

    Layout::Polar::Radialaxis::Title::Font& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Polar::Radialaxis::Title::Font& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Polar::Radialaxis::Title::Font& style(enum Style f);

    // Sets capitalization of text. It can be used to make text appear in all-uppercase or all-lowercase, or with each
    // word capitalized.
    // - Default: normal
    Layout::Polar::Radialaxis::Title::Font& textcase(enum Textcase f);

    // Sets the variant of the font.
    // - Default: normal
    Layout::Polar::Radialaxis::Title::Font& variant(enum Variant f);

    // Sets the weight (or boldness) of the font.
    Layout::Polar::Radialaxis::Title::Font& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Polar::Radialaxis::Title::Font& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Scene {
 public:
    Scene() = default;
    Scene(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Aspectmode {
        Auto,
        Cube,
        Data,
        Manual,
    };
    static std::string to_string(Aspectmode e);

    enum class Dragmode {
        Orbit,
        Turntable,
        Zoom,
        Pan,
        False,
    };
    static std::string to_string(Dragmode e);

    enum class Hovermode {
        Closest,
        False,
    };
    static std::string to_string(Hovermode e);

    class Annotations;
    // Sets this scene's axis aspectratio.
    class Aspectratio;
    class Camera;
    class Domain;
    class Xaxis;
    class Yaxis;
    class Zaxis;

    Layout::Scene& annotations(Annotations f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Annotations&>>>
    Layout::Scene& annotations(Callable&& c);

    // If *cube*, this scene's axes are drawn as a cube, regardless of the axes' ranges. If *data*, this scene's axes
    // are drawn in proportion with the axes' ranges. If *manual*, this scene's axes are drawn in proportion with the
    // input of *aspectratio* (the default behavior if *aspectratio* is provided). If *auto*, this scene's axes are
    // drawn using the results of *data* except when one axis is more than four times the size of the two others, where
    // in that case the results of *cube* are used.
    // - Default: auto
    Layout::Scene& aspectmode(enum Aspectmode f);

    // Sets this scene's axis aspectratio.
    Layout::Scene& aspectratio(Aspectratio f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Aspectratio&>>>
    Layout::Scene& aspectratio(Callable&& c);

    Layout::Scene& bgcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene& bgcolor(Callable&& c);

    Layout::Scene& camera(Camera f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Camera&>>>
    Layout::Scene& camera(Callable&& c);

    Layout::Scene& domain(Domain f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Domain&>>>
    Layout::Scene& domain(Callable&& c);

    // Determines the mode of drag interactions for this scene.
    Layout::Scene& dragmode(enum Dragmode f);

    // Determines the mode of hover interactions for this scene.
    // - Default: closest
    Layout::Scene& hovermode(enum Hovermode f);

    // Controls persistence of user-driven changes in camera attributes. Defaults to `layout.uirevision`.
    template <typename T>
    Layout::Scene& uirevision(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Scene& uirevision(Callable&& c);

    Layout::Scene& xaxis(Xaxis f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Xaxis&>>>
    Layout::Scene& xaxis(Callable&& c);

    Layout::Scene& yaxis(Yaxis f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Yaxis&>>>
    Layout::Scene& yaxis(Callable&& c);

    Layout::Scene& zaxis(Zaxis f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Zaxis&>>>
    Layout::Scene& zaxis(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Scene::Annotations {
 public:
    Annotations() = default;
    Annotations(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    class Annotation;

    Layout::Scene::Annotations& annotation(Annotation f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Annotation&>>>
    Layout::Scene::Annotations& annotation(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Scene::Annotations::Annotation {
 public:
    Annotation() = default;
    Annotation(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Align {
        Left,
        Center,
        Right,
    };
    static std::string to_string(Align e);

    enum class Valign {
        Top,
        Middle,
        Bottom,
    };
    static std::string to_string(Valign e);

    enum class Xanchor {
        Auto,
        Left,
        Center,
        Right,
    };
    static std::string to_string(Xanchor e);

    enum class Yanchor {
        Auto,
        Top,
        Middle,
        Bottom,
    };
    static std::string to_string(Yanchor e);

    // Sets the annotation text font.
    class Font;
    class Hoverlabel;

    // Sets the horizontal alignment of the `text` within the box. Has an effect only if `text` spans two or more lines
    // (i.e. `text` contains one or more <br> HTML tags) or if an explicit width is set to override the text width.
    // - Default: center
    Layout::Scene::Annotations::Annotation& align(enum Align f);

    // Sets the color of the annotation arrow.
    Layout::Scene::Annotations::Annotation& arrowcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Annotations::Annotation& arrowcolor(Callable&& c);

    // Sets the end annotation arrow head style.
    Layout::Scene::Annotations::Annotation& arrowhead(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Scene::Annotations::Annotation& arrowhead(Callable&& c);

    // Sets the annotation arrow head position.
    // - Default: end
    // - Flags: ['end', 'start']
    // - Extras ['none']
    Layout::Scene::Annotations::Annotation& arrowside(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Annotations::Annotation& arrowside(Callable&& c);

    // Sets the size of the end annotation arrow head, relative to `arrowwidth`. A value of 1 (default) gives a head
    // about 3x as wide as the line.
    Layout::Scene::Annotations::Annotation& arrowsize(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Annotations::Annotation& arrowsize(Callable&& c);

    // Sets the width (in px) of annotation arrow line.
    Layout::Scene::Annotations::Annotation& arrowwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Annotations::Annotation& arrowwidth(Callable&& c);

    // Sets the x component of the arrow tail about the arrow head (in pixels).
    Layout::Scene::Annotations::Annotation& ax(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Annotations::Annotation& ax(Callable&& c);

    // Sets the y component of the arrow tail about the arrow head (in pixels).
    Layout::Scene::Annotations::Annotation& ay(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Annotations::Annotation& ay(Callable&& c);

    // Sets the background color of the annotation.
    Layout::Scene::Annotations::Annotation& bgcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Annotations::Annotation& bgcolor(Callable&& c);

    // Sets the color of the border enclosing the annotation `text`.
    Layout::Scene::Annotations::Annotation& bordercolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Annotations::Annotation& bordercolor(Callable&& c);

    // Sets the padding (in px) between the `text` and the enclosing border.
    Layout::Scene::Annotations::Annotation& borderpad(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Annotations::Annotation& borderpad(Callable&& c);

    // Sets the width (in px) of the border enclosing the annotation `text`.
    Layout::Scene::Annotations::Annotation& borderwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Annotations::Annotation& borderwidth(Callable&& c);

    // Determines whether the annotation text box captures mouse move and click events, or allows those events to pass
    // through to data points in the plot that may be behind the annotation. By default `captureevents` is *false*
    // unless `hovertext` is provided. If you use the event `plotly_clickannotation` without `hovertext` you must
    // explicitly enable `captureevents`.
    Layout::Scene::Annotations::Annotation& captureevents(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Scene::Annotations::Annotation& captureevents(Callable&& c);

    // Sets the annotation text font.
    Layout::Scene::Annotations::Annotation& font(Font f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Font&>>>
    Layout::Scene::Annotations::Annotation& font(Callable&& c);

    // Sets an explicit height for the text box. null (default) lets the text set the box height. Taller text will be
    // clipped.
    Layout::Scene::Annotations::Annotation& height(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Annotations::Annotation& height(Callable&& c);

    Layout::Scene::Annotations::Annotation& hoverlabel(Hoverlabel f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Hoverlabel&>>>
    Layout::Scene::Annotations::Annotation& hoverlabel(Callable&& c);

    // Sets text to appear when hovering over this annotation. If omitted or blank, no hover label will appear.
    Layout::Scene::Annotations::Annotation& hovertext(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Annotations::Annotation& hovertext(Callable&& c);

    // When used in a template, named items are created in the output figure in addition to any items the figure already
    // has in this array. You can modify these items in the output figure by making your own item with
    // `templateitemname` matching this `name` alongside your modifications (including `visible: false` or `enabled:
    // false` to hide it). Has no effect outside of a template.
    Layout::Scene::Annotations::Annotation& name(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Annotations::Annotation& name(Callable&& c);

    // Sets the opacity of the annotation (text + arrow).
    Layout::Scene::Annotations::Annotation& opacity(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Annotations::Annotation& opacity(Callable&& c);

    // Determines whether or not the annotation is drawn with an arrow. If *true*, `text` is placed near the arrow's
    // tail. If *false*, `text` lines up with the `x` and `y` provided.
    Layout::Scene::Annotations::Annotation& showarrow(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Scene::Annotations::Annotation& showarrow(Callable&& c);

    // Sets a distance, in pixels, to move the end arrowhead away from the position it is pointing at, for example to
    // point at the edge of a marker independent of zoom. Note that this shortens the arrow from the `ax` / `ay` vector,
    // in contrast to `xshift` / `yshift` which moves everything by this amount.
    Layout::Scene::Annotations::Annotation& standoff(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Annotations::Annotation& standoff(Callable&& c);

    // Sets the start annotation arrow head style.
    Layout::Scene::Annotations::Annotation& startarrowhead(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Scene::Annotations::Annotation& startarrowhead(Callable&& c);

    // Sets the size of the start annotation arrow head, relative to `arrowwidth`. A value of 1 (default) gives a head
    // about 3x as wide as the line.
    Layout::Scene::Annotations::Annotation& startarrowsize(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Annotations::Annotation& startarrowsize(Callable&& c);

    // Sets a distance, in pixels, to move the start arrowhead away from the position it is pointing at, for example to
    // point at the edge of a marker independent of zoom. Note that this shortens the arrow from the `ax` / `ay` vector,
    // in contrast to `xshift` / `yshift` which moves everything by this amount.
    Layout::Scene::Annotations::Annotation& startstandoff(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Annotations::Annotation& startstandoff(Callable&& c);

    // Used to refer to a named item in this array in the template. Named items from the template will be created even
    // without a matching item in the input figure, but you can modify one by making an item with `templateitemname`
    // matching its `name`, alongside your modifications (including `visible: false` or `enabled: false` to hide it). If
    // there is no template or no matching item, this item will be hidden unless you explicitly show it with `visible:
    // true`.
    Layout::Scene::Annotations::Annotation& templateitemname(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Annotations::Annotation& templateitemname(Callable&& c);

    // Sets the text associated with this annotation. Plotly uses a subset of HTML tags to do things like newline
    // (<br>), bold (<b></b>), italics (<i></i>), hyperlinks (<a href='...'></a>). Tags <em>, <sup>, <sub>, <s>, <u>
    // <span> are also supported.
    Layout::Scene::Annotations::Annotation& text(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Annotations::Annotation& text(Callable&& c);

    // Sets the angle at which the `text` is drawn with respect to the horizontal.
    Layout::Scene::Annotations::Annotation& textangle(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Annotations::Annotation& textangle(Callable&& c);

    // Sets the vertical alignment of the `text` within the box. Has an effect only if an explicit height is set to
    // override the text height.
    // - Default: middle
    Layout::Scene::Annotations::Annotation& valign(enum Valign f);

    // Determines whether or not this annotation is visible.
    Layout::Scene::Annotations::Annotation& visible(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Scene::Annotations::Annotation& visible(Callable&& c);

    // Sets an explicit width for the text box. null (default) lets the text set the box width. Wider text will be
    // clipped. There is no automatic wrapping; use <br> to start a new line.
    Layout::Scene::Annotations::Annotation& width(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Annotations::Annotation& width(Callable&& c);

    // Sets the annotation's x position.
    template <typename T>
    Layout::Scene::Annotations::Annotation& x(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Scene::Annotations::Annotation& x(Callable&& c);

    // Sets the text box's horizontal position anchor This anchor binds the `x` position to the *left*, *center* or
    // *right* of the annotation. For example, if `x` is set to 1, `xref` to *paper* and `xanchor` to *right* then the
    // right-most portion of the annotation lines up with the right-most edge of the plotting area. If *auto*, the
    // anchor is equivalent to *center* for data-referenced annotations or if there is an arrow, whereas for
    // paper-referenced with no arrow, the anchor picked corresponds to the closest side.
    // - Default: auto
    Layout::Scene::Annotations::Annotation& xanchor(enum Xanchor f);

    // Shifts the position of the whole annotation and arrow to the right (positive) or left (negative) by this many
    // pixels.
    Layout::Scene::Annotations::Annotation& xshift(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Annotations::Annotation& xshift(Callable&& c);

    // Sets the annotation's y position.
    template <typename T>
    Layout::Scene::Annotations::Annotation& y(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Scene::Annotations::Annotation& y(Callable&& c);

    // Sets the text box's vertical position anchor This anchor binds the `y` position to the *top*, *middle* or
    // *bottom* of the annotation. For example, if `y` is set to 1, `yref` to *paper* and `yanchor` to *top* then the
    // top-most portion of the annotation lines up with the top-most edge of the plotting area. If *auto*, the anchor is
    // equivalent to *middle* for data-referenced annotations or if there is an arrow, whereas for paper-referenced with
    // no arrow, the anchor picked corresponds to the closest side.
    // - Default: auto
    Layout::Scene::Annotations::Annotation& yanchor(enum Yanchor f);

    // Shifts the position of the whole annotation and arrow up (positive) or down (negative) by this many pixels.
    Layout::Scene::Annotations::Annotation& yshift(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Annotations::Annotation& yshift(Callable&& c);

    // Sets the annotation's z position.
    template <typename T>
    Layout::Scene::Annotations::Annotation& z(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Scene::Annotations::Annotation& z(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets the annotation text font.
class Layout::Scene::Annotations::Annotation::Font {
 public:
    Font() = default;
    Font(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    enum class Textcase {
        Normal,
        WordCaps,
        Upper,
        Lower,
    };
    static std::string to_string(Textcase e);

    enum class Variant {
        Normal,
        SmallCaps,
        AllSmallCaps,
        AllPetiteCaps,
        PetiteCaps,
        Unicase,
    };
    static std::string to_string(Variant e);

    Layout::Scene::Annotations::Annotation::Font& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Annotations::Annotation::Font& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Scene::Annotations::Annotation::Font& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Annotations::Annotation::Font& family(Callable&& c);

    // Sets the kind of decoration line(s) with text, such as an *under*, *over* or *through* as well as combinations
    // e.g. *under+over*, etc.
    // - Default: none
    // - Flags: ['under', 'over', 'through']
    // - Extras ['none']
    Layout::Scene::Annotations::Annotation::Font& lineposition(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Annotations::Annotation::Font& lineposition(Callable&& c);

    // Sets the shape and color of the shadow behind text. *auto* places minimal shadow and applies contrast text font
    // color. See https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow for additional options.
    Layout::Scene::Annotations::Annotation::Font& shadow(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Annotations::Annotation::Font& shadow(Callable&& c);

    Layout::Scene::Annotations::Annotation::Font& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Annotations::Annotation::Font& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Scene::Annotations::Annotation::Font& style(enum Style f);

    // Sets capitalization of text. It can be used to make text appear in all-uppercase or all-lowercase, or with each
    // word capitalized.
    // - Default: normal
    Layout::Scene::Annotations::Annotation::Font& textcase(enum Textcase f);

    // Sets the variant of the font.
    // - Default: normal
    Layout::Scene::Annotations::Annotation::Font& variant(enum Variant f);

    // Sets the weight (or boldness) of the font.
    Layout::Scene::Annotations::Annotation::Font& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Scene::Annotations::Annotation::Font& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Scene::Annotations::Annotation::Hoverlabel {
 public:
    Hoverlabel() = default;
    Hoverlabel(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Sets the hover label text font. By default uses the global hover font and size, with color from
    // `hoverlabel.bordercolor`.
    class Font;

    // Sets the background color of the hover label. By default uses the annotation's `bgcolor` made opaque, or white if
    // it was transparent.
    Layout::Scene::Annotations::Annotation::Hoverlabel& bgcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Annotations::Annotation::Hoverlabel& bgcolor(Callable&& c);

    // Sets the border color of the hover label. By default uses either dark grey or white, for maximum contrast with
    // `hoverlabel.bgcolor`.
    Layout::Scene::Annotations::Annotation::Hoverlabel& bordercolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Annotations::Annotation::Hoverlabel& bordercolor(Callable&& c);

    // Sets the hover label text font. By default uses the global hover font and size, with color from
    // `hoverlabel.bordercolor`.
    Layout::Scene::Annotations::Annotation::Hoverlabel& font(Font f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Font&>>>
    Layout::Scene::Annotations::Annotation::Hoverlabel& font(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets the hover label text font. By default uses the global hover font and size, with color from
// `hoverlabel.bordercolor`.
class Layout::Scene::Annotations::Annotation::Hoverlabel::Font {
 public:
    Font() = default;
    Font(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    enum class Textcase {
        Normal,
        WordCaps,
        Upper,
        Lower,
    };
    static std::string to_string(Textcase e);

    enum class Variant {
        Normal,
        SmallCaps,
        AllSmallCaps,
        AllPetiteCaps,
        PetiteCaps,
        Unicase,
    };
    static std::string to_string(Variant e);

    Layout::Scene::Annotations::Annotation::Hoverlabel::Font& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Annotations::Annotation::Hoverlabel::Font& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Scene::Annotations::Annotation::Hoverlabel::Font& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Annotations::Annotation::Hoverlabel::Font& family(Callable&& c);

    // Sets the kind of decoration line(s) with text, such as an *under*, *over* or *through* as well as combinations
    // e.g. *under+over*, etc.
    // - Default: none
    // - Flags: ['under', 'over', 'through']
    // - Extras ['none']
    Layout::Scene::Annotations::Annotation::Hoverlabel::Font& lineposition(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Annotations::Annotation::Hoverlabel::Font& lineposition(Callable&& c);

    // Sets the shape and color of the shadow behind text. *auto* places minimal shadow and applies contrast text font
    // color. See https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow for additional options.
    Layout::Scene::Annotations::Annotation::Hoverlabel::Font& shadow(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Annotations::Annotation::Hoverlabel::Font& shadow(Callable&& c);

    Layout::Scene::Annotations::Annotation::Hoverlabel::Font& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Annotations::Annotation::Hoverlabel::Font& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Scene::Annotations::Annotation::Hoverlabel::Font& style(enum Style f);

    // Sets capitalization of text. It can be used to make text appear in all-uppercase or all-lowercase, or with each
    // word capitalized.
    // - Default: normal
    Layout::Scene::Annotations::Annotation::Hoverlabel::Font& textcase(enum Textcase f);

    // Sets the variant of the font.
    // - Default: normal
    Layout::Scene::Annotations::Annotation::Hoverlabel::Font& variant(enum Variant f);

    // Sets the weight (or boldness) of the font.
    Layout::Scene::Annotations::Annotation::Hoverlabel::Font& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Scene::Annotations::Annotation::Hoverlabel::Font& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets this scene's axis aspectratio.
class Layout::Scene::Aspectratio {
 public:
    Aspectratio() = default;
    Aspectratio(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    class Impliededits;

    Layout::Scene::Aspectratio& impliedEdits(Impliededits f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Impliededits&>>>
    Layout::Scene::Aspectratio& impliedEdits(Callable&& c);

    Layout::Scene::Aspectratio& x(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Aspectratio& x(Callable&& c);

    Layout::Scene::Aspectratio& y(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Aspectratio& y(Callable&& c);

    Layout::Scene::Aspectratio& z(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Aspectratio& z(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Scene::Aspectratio::Impliededits {
 public:
    Impliededits() = default;
    Impliededits(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Scene::Camera {
 public:
    Camera() = default;
    Camera(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Sets the (x,y,z) components of the 'center' camera vector This vector determines the translation (x,y,z) space
    // about the center of this scene. By default, there is no such translation.
    class Center;
    // Sets the (x,y,z) components of the 'eye' camera vector. This vector determines the view point about the origin of
    // this scene.
    class Eye;
    class Projection;
    // Sets the (x,y,z) components of the 'up' camera vector. This vector determines the up direction of this scene with
    // respect to the page. The default is *{x: 0, y: 0, z: 1}* which means that the z axis points up.
    class Up;

    // Sets the (x,y,z) components of the 'center' camera vector This vector determines the translation (x,y,z) space
    // about the center of this scene. By default, there is no such translation.
    Layout::Scene::Camera& center(Center f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Center&>>>
    Layout::Scene::Camera& center(Callable&& c);

    // Sets the (x,y,z) components of the 'eye' camera vector. This vector determines the view point about the origin of
    // this scene.
    Layout::Scene::Camera& eye(Eye f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Eye&>>>
    Layout::Scene::Camera& eye(Callable&& c);

    Layout::Scene::Camera& projection(Projection f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Projection&>>>
    Layout::Scene::Camera& projection(Callable&& c);

    // Sets the (x,y,z) components of the 'up' camera vector. This vector determines the up direction of this scene with
    // respect to the page. The default is *{x: 0, y: 0, z: 1}* which means that the z axis points up.
    Layout::Scene::Camera& up(Up f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Up&>>>
    Layout::Scene::Camera& up(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets the (x,y,z) components of the 'center' camera vector This vector determines the translation (x,y,z) space about
// the center of this scene. By default, there is no such translation.
class Layout::Scene::Camera::Center {
 public:
    Center() = default;
    Center(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    Layout::Scene::Camera::Center& x(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Camera::Center& x(Callable&& c);

    Layout::Scene::Camera::Center& y(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Camera::Center& y(Callable&& c);

    Layout::Scene::Camera::Center& z(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Camera::Center& z(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets the (x,y,z) components of the 'eye' camera vector. This vector determines the view point about the origin of
// this scene.
class Layout::Scene::Camera::Eye {
 public:
    Eye() = default;
    Eye(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    Layout::Scene::Camera::Eye& x(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Camera::Eye& x(Callable&& c);

    Layout::Scene::Camera::Eye& y(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Camera::Eye& y(Callable&& c);

    Layout::Scene::Camera::Eye& z(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Camera::Eye& z(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Scene::Camera::Projection {
 public:
    Projection() = default;
    Projection(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Type {
        Perspective,
        Orthographic,
    };
    static std::string to_string(Type e);

    // Sets the projection type. The projection type could be either *perspective* or *orthographic*. The default is
    // *perspective*.
    // - Default: perspective
    Layout::Scene::Camera::Projection& type(enum Type f);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets the (x,y,z) components of the 'up' camera vector. This vector determines the up direction of this scene with
// respect to the page. The default is *{x: 0, y: 0, z: 1}* which means that the z axis points up.
class Layout::Scene::Camera::Up {
 public:
    Up() = default;
    Up(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    Layout::Scene::Camera::Up& x(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Camera::Up& x(Callable&& c);

    Layout::Scene::Camera::Up& y(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Camera::Up& y(Callable&& c);

    Layout::Scene::Camera::Up& z(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Camera::Up& z(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Scene::Domain {
 public:
    Domain() = default;
    Domain(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // If there is a layout grid, use the domain for this column in the grid for this scene subplot .
    Layout::Scene::Domain& column(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Scene::Domain& column(Callable&& c);

    // If there is a layout grid, use the domain for this row in the grid for this scene subplot .
    Layout::Scene::Domain& row(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Scene::Domain& row(Callable&& c);

    // Sets the horizontal domain of this scene subplot (in plot fraction).
    Layout::Scene::Domain& x(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Scene::Domain& x(Callable&& c);

    // Sets the vertical domain of this scene subplot (in plot fraction).
    Layout::Scene::Domain& y(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Scene::Domain& y(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Scene::Xaxis {
 public:
    Xaxis() = default;
    Xaxis(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Autorange {
        True,
        False,
        Reversed,
        MinReversed,
        MaxReversed,
        Min,
        Max,
    };
    static std::string to_string(Autorange e);

    enum class Autotypenumbers {
        ConvertTypes,
        Strict,
    };
    static std::string to_string(Autotypenumbers e);

    enum class Calendar {
        Chinese,
        Coptic,
        Discworld,
        Ethiopian,
        Gregorian,
        Hebrew,
        Islamic,
        Jalali,
        Julian,
        Mayan,
        Nanakshahi,
        Nepali,
        Persian,
        Taiwan,
        Thai,
        Ummalqura,
    };
    static std::string to_string(Calendar e);

    enum class Categoryorder {
        Trace,
        CategoryAscending,
        CategoryDescending,
        Array,
        TotalAscending,
        TotalDescending,
        MinAscending,
        MinDescending,
        MaxAscending,
        MaxDescending,
        SumAscending,
        SumDescending,
        MeanAscending,
        MeanDescending,
        GeometricMeanAscending,
        GeometricMeanDescending,
        MedianAscending,
        MedianDescending,
    };
    static std::string to_string(Categoryorder e);

    enum class Exponentformat {
        None,
        E,
        Power,
        Si,
        B,
    };
    static std::string to_string(Exponentformat e);

    enum class Mirror {
        True,
        Ticks,
        False,
        All,
        Allticks,
    };
    static std::string to_string(Mirror e);

    enum class Rangemode {
        Normal,
        Tozero,
        Nonnegative,
    };
    static std::string to_string(Rangemode e);

    enum class Showexponent {
        All,
        First,
        Last,
        None,
    };
    static std::string to_string(Showexponent e);

    enum class Showtickprefix {
        All,
        First,
        Last,
        None,
    };
    static std::string to_string(Showtickprefix e);

    enum class Showticksuffix {
        All,
        First,
        Last,
        None,
    };
    static std::string to_string(Showticksuffix e);

    enum class Tickmode {
        Auto,
        Linear,
        Array,
    };
    static std::string to_string(Tickmode e);

    enum class Ticks {
        Outside,
        Inside,
        Empty,
    };
    static std::string to_string(Ticks e);

    enum class Type {
        Hyphen,
        Linear,
        Log,
        Date,
        Category,
    };
    static std::string to_string(Type e);

    class Autorangeoptions;
    // Sets the tick font.
    class Tickfont;
    class Tickformatstops;
    class Title;

    // Determines whether or not the range of this axis is computed in relation to the input data. See `rangemode` for
    // more info. If `range` is provided and it has a value for both the lower and upper bound, `autorange` is set to
    // *false*. Using *min* applies autorange only to set the minimum. Using *max* applies autorange only to set the
    // maximum. Using *min reversed* applies autorange only to set the minimum on a reversed axis. Using *max reversed*
    // applies autorange only to set the maximum on a reversed axis. Using *reversed* applies autorange on both ends and
    // reverses the axis direction.
    // - Default: True
    Layout::Scene::Xaxis& autorange(enum Autorange f);

    Layout::Scene::Xaxis& autorangeoptions(Autorangeoptions f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Autorangeoptions&>>>
    Layout::Scene::Xaxis& autorangeoptions(Callable&& c);

    // Using *strict* a numeric string in trace data is not converted to a number. Using *convert types* a numeric
    // string in trace data may be treated as a number during automatic axis `type` detection. Defaults to
    // layout.autotypenumbers.
    // - Default: convert types
    Layout::Scene::Xaxis& autotypenumbers(enum Autotypenumbers f);

    // Sets the background color of this axis' wall.
    Layout::Scene::Xaxis& backgroundcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Xaxis& backgroundcolor(Callable&& c);

    // Sets the calendar system to use for `range` and `tick0` if this is a date axis. This does not set the calendar
    // for interpreting data on this axis, that's specified in the trace or via the global `layout.calendar`
    // - Default: gregorian
    Layout::Scene::Xaxis& calendar(enum Calendar f);

    // Sets the order in which categories on this axis appear. Only has an effect if `categoryorder` is set to *array*.
    // Used with `categoryorder`.
    template <typename T, typename = std::enable_if_t<is_data_array_element_v<T>>>
    Layout::Scene::Xaxis& categoryarray(const std::vector<T>& f);
    template <
        typename T, typename Callable,
        typename = std::enable_if_t<is_data_array_element_v<T> && (std::is_invocable_v<Callable, std::vector<T>&>)>>
    Layout::Scene::Xaxis& categoryarray(Callable&& c);

    // Sets the source reference on Chart Studio Cloud for `categoryarray`.
    Layout::Scene::Xaxis& categoryarraysrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Xaxis& categoryarraysrc(Callable&& c);

    // Specifies the ordering logic for the case of categorical variables. By default, plotly uses *trace*, which
    // specifies the order that is present in the data supplied. Set `categoryorder` to *category ascending* or
    // *category descending* if order should be determined by the alphanumerical order of the category names. Set
    // `categoryorder` to *array* to derive the ordering from the attribute `categoryarray`. If a category is not found
    // in the `categoryarray` array, the sorting behavior for that attribute will be identical to the *trace* mode. The
    // unspecified categories will follow the categories in `categoryarray`. Set `categoryorder` to *total ascending* or
    // *total descending* if order should be determined by the numerical order of the values. Similarly, the order can
    // be determined by the min, max, sum, mean, geometric mean or median of all the values.
    // - Default: trace
    Layout::Scene::Xaxis& categoryorder(enum Categoryorder f);

    // Sets default for all colors associated with this axis all at once: line, font, tick, and grid colors. Grid color
    // is lightened by blending this with the plot background Individual pieces can override this.
    Layout::Scene::Xaxis& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Xaxis& color(Callable&& c);

    // Sets the step in-between ticks on this axis. Use with `tick0`. Must be a positive number, or special strings
    // available to *log* and *date* axes. If the axis `type` is *log*, then ticks are set every 10^(n*dtick) where n is
    // the tick number. For example, to set a tick mark at 1, 10, 100, 1000, ... set dtick to 1. To set tick marks at 1,
    // 100, 10000, ... set dtick to 2. To set tick marks at 1, 5, 25, 125, 625, 3125, ... set dtick to log_10(5), or
    // 0.69897000433. *log* has several special values; *L<f>*, where `f` is a positive number, gives ticks linearly
    // spaced in value (but not position). For example `tick0` = 0.1, `dtick` = *L0.5* will put ticks at 0.1,
    // 0.6, 1.1, 1.6 etc. To show powers of 10 plus small digits between, use *D1* (all digits) or *D2* (only 2 and 5).
    // `tick0` is ignored for *D1* and *D2*. If the axis `type` is *date*, then you must convert the time to
    // milliseconds. For example, to set the interval between ticks to one day, set `dtick` to 86400000.0. *date* also
    // has special values *M<n>* gives ticks spaced by a number of months. `n` must be a positive integer. To set ticks
    // on the 15th of every third month, set `tick0` to *2000-01-15* and `dtick` to *M3*. To set ticks every 4 years,
    // set `dtick` to *M48*
    template <typename T>
    Layout::Scene::Xaxis& dtick(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Scene::Xaxis& dtick(Callable&& c);

    // Determines a formatting rule for the tick exponents. For example, consider the number 1,000,000,000. If *none*,
    // it appears as 1,000,000,000. If *e*, 1e+9. If *E*, 1E+9. If *power*, 1x10^9 (with 9 in a super script). If *SI*,
    // 1G. If *B*, 1B.
    // - Default: B
    Layout::Scene::Xaxis& exponentformat(enum Exponentformat f);

    // Sets the color of the grid lines.
    Layout::Scene::Xaxis& gridcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Xaxis& gridcolor(Callable&& c);

    // Sets the width (in px) of the grid lines.
    Layout::Scene::Xaxis& gridwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Xaxis& gridwidth(Callable&& c);

    // Sets the hover text formatting rule using d3 formatting mini-languages which are very similar to those in Python.
    // For numbers, see: https://github.com/d3/d3-format/tree/v1.4.5#d3-format. And for dates see:
    // https://github.com/d3/d3-time-format/tree/v2.2.3#locale_format. We add two items to d3's date formatter: *%h* for
    // half of the year as a decimal number as well as *%{n}f* for fractional seconds with n digits. For example,
    // *2016-10-13 09:15:23.456* with tickformat *%H~%M~%S.%2f* would display *09~15~23.46*
    Layout::Scene::Xaxis& hoverformat(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Xaxis& hoverformat(Callable&& c);

    // Replacement text for specific tick or hover labels. For example using {US: 'USA', CA: 'Canada'} changes US to USA
    // and CA to Canada. The labels we would have shown must match the keys exactly, after adding any tickprefix or
    // ticksuffix. For negative numbers the minus sign symbol used (U+2212) is wider than the regular ascii dash. That
    // means you need to use 1 instead of -1. labelalias can be used with any axis type, and both keys (if needed) and
    // values (if desired) can include html-like tags or MathJax.
    template <typename T>
    Layout::Scene::Xaxis& labelalias(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Scene::Xaxis& labelalias(Callable&& c);

    // Sets the axis line color.
    Layout::Scene::Xaxis& linecolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Xaxis& linecolor(Callable&& c);

    // Sets the width (in px) of the axis line.
    Layout::Scene::Xaxis& linewidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Xaxis& linewidth(Callable&& c);

    // Determines the maximum range of this axis.
    template <typename T>
    Layout::Scene::Xaxis& maxallowed(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Scene::Xaxis& maxallowed(Callable&& c);

    // Determines the minimum range of this axis.
    template <typename T>
    Layout::Scene::Xaxis& minallowed(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Scene::Xaxis& minallowed(Callable&& c);

    // Hide SI prefix for 10^n if |n| is below this number. This only has an effect when `tickformat` is *SI* or *B*.
    Layout::Scene::Xaxis& minexponent(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Xaxis& minexponent(Callable&& c);

    // Determines if the axis lines or/and ticks are mirrored to the opposite side of the plotting area. If *true*, the
    // axis lines are mirrored. If *ticks*, the axis lines and ticks are mirrored. If *false*, mirroring is disable. If
    // *all*, axis lines are mirrored on all shared-axes subplots. If *allticks*, axis lines and ticks are mirrored on
    // all shared-axes subplots.
    // - Default: False
    Layout::Scene::Xaxis& mirror(enum Mirror f);

    // Specifies the maximum number of ticks for the particular axis. The actual number of ticks will be chosen
    // automatically to be less than or equal to `nticks`. Has an effect only if `tickmode` is set to *auto*.
    Layout::Scene::Xaxis& nticks(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Scene::Xaxis& nticks(Callable&& c);

    // Sets the range of this axis. If the axis `type` is *log*, then you must take the log of your desired range (e.g.
    // to set the range from 1 to 100, set the range from 0 to 2). If the axis `type` is *date*, it should be date
    // strings, like date data, though Date objects and unix milliseconds will be accepted and converted to strings. If
    // the axis `type` is *category*, it should be numbers, using the scale where each category is assigned a serial
    // number from zero in the order it appears. Leaving either or both elements `null` impacts the default `autorange`.
    Layout::Scene::Xaxis& range(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Scene::Xaxis& range(Callable&& c);

    // If *normal*, the range is computed in relation to the extrema of the input data. If *tozero*`, the range extends
    // to 0, regardless of the input data If *nonnegative*, the range is non-negative, regardless of the input data.
    // Applies only to linear axes.
    // - Default: normal
    Layout::Scene::Xaxis& rangemode(enum Rangemode f);

    // If "true", even 4-digit integers are separated
    Layout::Scene::Xaxis& separatethousands(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Scene::Xaxis& separatethousands(Callable&& c);

    // Sets whether or not this axis is labeled
    Layout::Scene::Xaxis& showaxeslabels(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Scene::Xaxis& showaxeslabels(Callable&& c);

    // Sets whether or not this axis' wall has a background color.
    Layout::Scene::Xaxis& showbackground(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Scene::Xaxis& showbackground(Callable&& c);

    // If *all*, all exponents are shown besides their significands. If *first*, only the exponent of the first tick is
    // shown. If *last*, only the exponent of the last tick is shown. If *none*, no exponents appear.
    // - Default: all
    Layout::Scene::Xaxis& showexponent(enum Showexponent f);

    // Determines whether or not grid lines are drawn. If *true*, the grid lines are drawn at every tick mark.
    Layout::Scene::Xaxis& showgrid(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Scene::Xaxis& showgrid(Callable&& c);

    // Determines whether or not a line bounding this axis is drawn.
    Layout::Scene::Xaxis& showline(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Scene::Xaxis& showline(Callable&& c);

    // Sets whether or not spikes starting from data points to this axis' wall are shown on hover.
    Layout::Scene::Xaxis& showspikes(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Scene::Xaxis& showspikes(Callable&& c);

    // Determines whether or not the tick labels are drawn.
    Layout::Scene::Xaxis& showticklabels(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Scene::Xaxis& showticklabels(Callable&& c);

    // If *all*, all tick labels are displayed with a prefix. If *first*, only the first tick is displayed with a
    // prefix. If *last*, only the last tick is displayed with a suffix. If *none*, tick prefixes are hidden.
    // - Default: all
    Layout::Scene::Xaxis& showtickprefix(enum Showtickprefix f);

    // Same as `showtickprefix` but for tick suffixes.
    // - Default: all
    Layout::Scene::Xaxis& showticksuffix(enum Showticksuffix f);

    // Sets the color of the spikes.
    Layout::Scene::Xaxis& spikecolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Xaxis& spikecolor(Callable&& c);

    // Sets whether or not spikes extending from the projection data points to this axis' wall boundaries are shown on
    // hover.
    Layout::Scene::Xaxis& spikesides(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Scene::Xaxis& spikesides(Callable&& c);

    // Sets the thickness (in px) of the spikes.
    Layout::Scene::Xaxis& spikethickness(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Xaxis& spikethickness(Callable&& c);

    // Sets the placement of the first tick on this axis. Use with `dtick`. If the axis `type` is *log*, then you must
    // take the log of your starting tick (e.g. to set the starting tick to 100, set the `tick0` to 2) except when
    // `dtick`=*L<f>* (see `dtick` for more info). If the axis `type` is *date*, it should be a date string, like date
    // data. If the axis `type` is *category*, it should be a number, using the scale where each category is assigned a
    // serial number from zero in the order it appears.
    template <typename T>
    Layout::Scene::Xaxis& tick0(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Scene::Xaxis& tick0(Callable&& c);

    // Sets the angle of the tick labels with respect to the horizontal. For example, a `tickangle` of -90 draws the
    // tick labels vertically.
    Layout::Scene::Xaxis& tickangle(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Xaxis& tickangle(Callable&& c);

    // Sets the tick color.
    Layout::Scene::Xaxis& tickcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Xaxis& tickcolor(Callable&& c);

    // Sets the tick font.
    Layout::Scene::Xaxis& tickfont(Tickfont f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Tickfont&>>>
    Layout::Scene::Xaxis& tickfont(Callable&& c);

    // Sets the tick label formatting rule using d3 formatting mini-languages which are very similar to those in Python.
    // For numbers, see: https://github.com/d3/d3-format/tree/v1.4.5#d3-format. And for dates see:
    // https://github.com/d3/d3-time-format/tree/v2.2.3#locale_format. We add two items to d3's date formatter: *%h* for
    // half of the year as a decimal number as well as *%{n}f* for fractional seconds with n digits. For example,
    // *2016-10-13 09:15:23.456* with tickformat *%H~%M~%S.%2f* would display *09~15~23.46*
    Layout::Scene::Xaxis& tickformat(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Xaxis& tickformat(Callable&& c);

    Layout::Scene::Xaxis& tickformatstops(Tickformatstops f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Tickformatstops&>>>
    Layout::Scene::Xaxis& tickformatstops(Callable&& c);

    // Sets the tick length (in px).
    Layout::Scene::Xaxis& ticklen(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Xaxis& ticklen(Callable&& c);

    // Sets the tick mode for this axis. If *auto*, the number of ticks is set via `nticks`. If *linear*, the placement
    // of the ticks is determined by a starting position `tick0` and a tick step `dtick` (*linear* is the default value
    // if `tick0` and `dtick` are provided). If *array*, the placement of the ticks is set via `tickvals` and the tick
    // text is `ticktext`. (*array* is the default value if `tickvals` is provided).
    Layout::Scene::Xaxis& tickmode(enum Tickmode f);

    // Sets a tick label prefix.
    Layout::Scene::Xaxis& tickprefix(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Xaxis& tickprefix(Callable&& c);

    // Determines whether ticks are drawn or not. If **, this axis' ticks are not drawn. If *outside* (*inside*), this
    // axis' are drawn outside (inside) the axis lines.
    Layout::Scene::Xaxis& ticks(enum Ticks f);

    // Sets a tick label suffix.
    Layout::Scene::Xaxis& ticksuffix(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Xaxis& ticksuffix(Callable&& c);

    // Sets the text displayed at the ticks position via `tickvals`. Only has an effect if `tickmode` is set to *array*.
    // Used with `tickvals`.
    template <typename T, typename = std::enable_if_t<is_data_array_element_v<T>>>
    Layout::Scene::Xaxis& ticktext(const std::vector<T>& f);
    template <
        typename T, typename Callable,
        typename = std::enable_if_t<is_data_array_element_v<T> && (std::is_invocable_v<Callable, std::vector<T>&>)>>
    Layout::Scene::Xaxis& ticktext(Callable&& c);

    // Sets the source reference on Chart Studio Cloud for `ticktext`.
    Layout::Scene::Xaxis& ticktextsrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Xaxis& ticktextsrc(Callable&& c);

    // Sets the values at which ticks on this axis appear. Only has an effect if `tickmode` is set to *array*. Used with
    // `ticktext`.
    template <typename T, typename = std::enable_if_t<is_data_array_element_v<T>>>
    Layout::Scene::Xaxis& tickvals(const std::vector<T>& f);
    template <
        typename T, typename Callable,
        typename = std::enable_if_t<is_data_array_element_v<T> && (std::is_invocable_v<Callable, std::vector<T>&>)>>
    Layout::Scene::Xaxis& tickvals(Callable&& c);

    // Sets the source reference on Chart Studio Cloud for `tickvals`.
    Layout::Scene::Xaxis& tickvalssrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Xaxis& tickvalssrc(Callable&& c);

    // Sets the tick width (in px).
    Layout::Scene::Xaxis& tickwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Xaxis& tickwidth(Callable&& c);

    Layout::Scene::Xaxis& title(Title f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Title&>>>
    Layout::Scene::Xaxis& title(Callable&& c);

    // Sets the axis type. By default, plotly attempts to determined the axis type by looking into the data of the
    // traces that referenced the axis in question.
    // - Default: -
    Layout::Scene::Xaxis& type(enum Type f);

    // A single toggle to hide the axis while preserving interaction like dragging. Default is true when a cheater plot
    // is present on the axis, otherwise false
    Layout::Scene::Xaxis& visible(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Scene::Xaxis& visible(Callable&& c);

    // Determines whether or not a line is drawn at along the 0 value of this axis. If *true*, the zero line is drawn on
    // top of the grid lines.
    Layout::Scene::Xaxis& zeroline(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Scene::Xaxis& zeroline(Callable&& c);

    // Sets the line color of the zero line.
    Layout::Scene::Xaxis& zerolinecolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Xaxis& zerolinecolor(Callable&& c);

    // Sets the width (in px) of the zero line.
    Layout::Scene::Xaxis& zerolinewidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Xaxis& zerolinewidth(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Scene::Xaxis::Autorangeoptions {
 public:
    Autorangeoptions() = default;
    Autorangeoptions(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Clip autorange maximum if it goes beyond this value. Has no effect when `autorangeoptions.maxallowed` is
    // provided.
    template <typename T>
    Layout::Scene::Xaxis::Autorangeoptions& clipmax(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Scene::Xaxis::Autorangeoptions& clipmax(Callable&& c);

    // Clip autorange minimum if it goes beyond this value. Has no effect when `autorangeoptions.minallowed` is
    // provided.
    template <typename T>
    Layout::Scene::Xaxis::Autorangeoptions& clipmin(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Scene::Xaxis::Autorangeoptions& clipmin(Callable&& c);

    // Ensure this value is included in autorange.
    template <typename T>
    Layout::Scene::Xaxis::Autorangeoptions& include(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Scene::Xaxis::Autorangeoptions& include(Callable&& c);
    template <typename T>
    Layout::Scene::Xaxis::Autorangeoptions& include(const std::vector<T>& f);

    // Sets the source reference on Chart Studio Cloud for `include`.
    Layout::Scene::Xaxis::Autorangeoptions& includesrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Xaxis::Autorangeoptions& includesrc(Callable&& c);

    // Use this value exactly as autorange maximum.
    template <typename T>
    Layout::Scene::Xaxis::Autorangeoptions& maxallowed(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Scene::Xaxis::Autorangeoptions& maxallowed(Callable&& c);

    // Use this value exactly as autorange minimum.
    template <typename T>
    Layout::Scene::Xaxis::Autorangeoptions& minallowed(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Scene::Xaxis::Autorangeoptions& minallowed(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets the tick font.
class Layout::Scene::Xaxis::Tickfont {
 public:
    Tickfont() = default;
    Tickfont(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    enum class Textcase {
        Normal,
        WordCaps,
        Upper,
        Lower,
    };
    static std::string to_string(Textcase e);

    enum class Variant {
        Normal,
        SmallCaps,
        AllSmallCaps,
        AllPetiteCaps,
        PetiteCaps,
        Unicase,
    };
    static std::string to_string(Variant e);

    Layout::Scene::Xaxis::Tickfont& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Xaxis::Tickfont& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Scene::Xaxis::Tickfont& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Xaxis::Tickfont& family(Callable&& c);

    // Sets the kind of decoration line(s) with text, such as an *under*, *over* or *through* as well as combinations
    // e.g. *under+over*, etc.
    // - Default: none
    // - Flags: ['under', 'over', 'through']
    // - Extras ['none']
    Layout::Scene::Xaxis::Tickfont& lineposition(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Xaxis::Tickfont& lineposition(Callable&& c);

    // Sets the shape and color of the shadow behind text. *auto* places minimal shadow and applies contrast text font
    // color. See https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow for additional options.
    Layout::Scene::Xaxis::Tickfont& shadow(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Xaxis::Tickfont& shadow(Callable&& c);

    Layout::Scene::Xaxis::Tickfont& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Xaxis::Tickfont& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Scene::Xaxis::Tickfont& style(enum Style f);

    // Sets capitalization of text. It can be used to make text appear in all-uppercase or all-lowercase, or with each
    // word capitalized.
    // - Default: normal
    Layout::Scene::Xaxis::Tickfont& textcase(enum Textcase f);

    // Sets the variant of the font.
    // - Default: normal
    Layout::Scene::Xaxis::Tickfont& variant(enum Variant f);

    // Sets the weight (or boldness) of the font.
    Layout::Scene::Xaxis::Tickfont& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Scene::Xaxis::Tickfont& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Scene::Xaxis::Tickformatstops {
 public:
    Tickformatstops() = default;
    Tickformatstops(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    class Tickformatstop;

    Layout::Scene::Xaxis::Tickformatstops& tickformatstop(Tickformatstop f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Tickformatstop&>>>
    Layout::Scene::Xaxis::Tickformatstops& tickformatstop(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Scene::Xaxis::Tickformatstops::Tickformatstop {
 public:
    Tickformatstop() = default;
    Tickformatstop(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // range [*min*, *max*], where *min*, *max* - dtick values which describe some zoom level, it is possible to omit
    // *min* or *max* value by passing *null*
    Layout::Scene::Xaxis::Tickformatstops::Tickformatstop& dtickrange(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Scene::Xaxis::Tickformatstops::Tickformatstop& dtickrange(Callable&& c);

    // Determines whether or not this stop is used. If `false`, this stop is ignored even within its `dtickrange`.
    Layout::Scene::Xaxis::Tickformatstops::Tickformatstop& enabled(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Scene::Xaxis::Tickformatstops::Tickformatstop& enabled(Callable&& c);

    // When used in a template, named items are created in the output figure in addition to any items the figure already
    // has in this array. You can modify these items in the output figure by making your own item with
    // `templateitemname` matching this `name` alongside your modifications (including `visible: false` or `enabled:
    // false` to hide it). Has no effect outside of a template.
    Layout::Scene::Xaxis::Tickformatstops::Tickformatstop& name(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Xaxis::Tickformatstops::Tickformatstop& name(Callable&& c);

    // Used to refer to a named item in this array in the template. Named items from the template will be created even
    // without a matching item in the input figure, but you can modify one by making an item with `templateitemname`
    // matching its `name`, alongside your modifications (including `visible: false` or `enabled: false` to hide it). If
    // there is no template or no matching item, this item will be hidden unless you explicitly show it with `visible:
    // true`.
    Layout::Scene::Xaxis::Tickformatstops::Tickformatstop& templateitemname(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Xaxis::Tickformatstops::Tickformatstop& templateitemname(Callable&& c);

    // string - dtickformat for described zoom level, the same as *tickformat*
    Layout::Scene::Xaxis::Tickformatstops::Tickformatstop& value(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Xaxis::Tickformatstops::Tickformatstop& value(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Scene::Xaxis::Title {
 public:
    Title() = default;
    Title(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Sets this axis' title font.
    class Font;

    // Sets this axis' title font.
    Layout::Scene::Xaxis::Title& font(Font f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Font&>>>
    Layout::Scene::Xaxis::Title& font(Callable&& c);

    // Sets the title of this axis.
    Layout::Scene::Xaxis::Title& text(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Xaxis::Title& text(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets this axis' title font.
class Layout::Scene::Xaxis::Title::Font {
 public:
    Font() = default;
    Font(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    enum class Textcase {
        Normal,
        WordCaps,
        Upper,
        Lower,
    };
    static std::string to_string(Textcase e);

    enum class Variant {
        Normal,
        SmallCaps,
        AllSmallCaps,
        AllPetiteCaps,
        PetiteCaps,
        Unicase,
    };
    static std::string to_string(Variant e);

    Layout::Scene::Xaxis::Title::Font& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Xaxis::Title::Font& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Scene::Xaxis::Title::Font& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Xaxis::Title::Font& family(Callable&& c);

    // Sets the kind of decoration line(s) with text, such as an *under*, *over* or *through* as well as combinations
    // e.g. *under+over*, etc.
    // - Default: none
    // - Flags: ['under', 'over', 'through']
    // - Extras ['none']
    Layout::Scene::Xaxis::Title::Font& lineposition(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Xaxis::Title::Font& lineposition(Callable&& c);

    // Sets the shape and color of the shadow behind text. *auto* places minimal shadow and applies contrast text font
    // color. See https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow for additional options.
    Layout::Scene::Xaxis::Title::Font& shadow(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Xaxis::Title::Font& shadow(Callable&& c);

    Layout::Scene::Xaxis::Title::Font& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Xaxis::Title::Font& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Scene::Xaxis::Title::Font& style(enum Style f);

    // Sets capitalization of text. It can be used to make text appear in all-uppercase or all-lowercase, or with each
    // word capitalized.
    // - Default: normal
    Layout::Scene::Xaxis::Title::Font& textcase(enum Textcase f);

    // Sets the variant of the font.
    // - Default: normal
    Layout::Scene::Xaxis::Title::Font& variant(enum Variant f);

    // Sets the weight (or boldness) of the font.
    Layout::Scene::Xaxis::Title::Font& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Scene::Xaxis::Title::Font& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Scene::Yaxis {
 public:
    Yaxis() = default;
    Yaxis(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Autorange {
        True,
        False,
        Reversed,
        MinReversed,
        MaxReversed,
        Min,
        Max,
    };
    static std::string to_string(Autorange e);

    enum class Autotypenumbers {
        ConvertTypes,
        Strict,
    };
    static std::string to_string(Autotypenumbers e);

    enum class Calendar {
        Chinese,
        Coptic,
        Discworld,
        Ethiopian,
        Gregorian,
        Hebrew,
        Islamic,
        Jalali,
        Julian,
        Mayan,
        Nanakshahi,
        Nepali,
        Persian,
        Taiwan,
        Thai,
        Ummalqura,
    };
    static std::string to_string(Calendar e);

    enum class Categoryorder {
        Trace,
        CategoryAscending,
        CategoryDescending,
        Array,
        TotalAscending,
        TotalDescending,
        MinAscending,
        MinDescending,
        MaxAscending,
        MaxDescending,
        SumAscending,
        SumDescending,
        MeanAscending,
        MeanDescending,
        GeometricMeanAscending,
        GeometricMeanDescending,
        MedianAscending,
        MedianDescending,
    };
    static std::string to_string(Categoryorder e);

    enum class Exponentformat {
        None,
        E,
        Power,
        Si,
        B,
    };
    static std::string to_string(Exponentformat e);

    enum class Mirror {
        True,
        Ticks,
        False,
        All,
        Allticks,
    };
    static std::string to_string(Mirror e);

    enum class Rangemode {
        Normal,
        Tozero,
        Nonnegative,
    };
    static std::string to_string(Rangemode e);

    enum class Showexponent {
        All,
        First,
        Last,
        None,
    };
    static std::string to_string(Showexponent e);

    enum class Showtickprefix {
        All,
        First,
        Last,
        None,
    };
    static std::string to_string(Showtickprefix e);

    enum class Showticksuffix {
        All,
        First,
        Last,
        None,
    };
    static std::string to_string(Showticksuffix e);

    enum class Tickmode {
        Auto,
        Linear,
        Array,
    };
    static std::string to_string(Tickmode e);

    enum class Ticks {
        Outside,
        Inside,
        Empty,
    };
    static std::string to_string(Ticks e);

    enum class Type {
        Hyphen,
        Linear,
        Log,
        Date,
        Category,
    };
    static std::string to_string(Type e);

    class Autorangeoptions;
    // Sets the tick font.
    class Tickfont;
    class Tickformatstops;
    class Title;

    // Determines whether or not the range of this axis is computed in relation to the input data. See `rangemode` for
    // more info. If `range` is provided and it has a value for both the lower and upper bound, `autorange` is set to
    // *false*. Using *min* applies autorange only to set the minimum. Using *max* applies autorange only to set the
    // maximum. Using *min reversed* applies autorange only to set the minimum on a reversed axis. Using *max reversed*
    // applies autorange only to set the maximum on a reversed axis. Using *reversed* applies autorange on both ends and
    // reverses the axis direction.
    // - Default: True
    Layout::Scene::Yaxis& autorange(enum Autorange f);

    Layout::Scene::Yaxis& autorangeoptions(Autorangeoptions f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Autorangeoptions&>>>
    Layout::Scene::Yaxis& autorangeoptions(Callable&& c);

    // Using *strict* a numeric string in trace data is not converted to a number. Using *convert types* a numeric
    // string in trace data may be treated as a number during automatic axis `type` detection. Defaults to
    // layout.autotypenumbers.
    // - Default: convert types
    Layout::Scene::Yaxis& autotypenumbers(enum Autotypenumbers f);

    // Sets the background color of this axis' wall.
    Layout::Scene::Yaxis& backgroundcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Yaxis& backgroundcolor(Callable&& c);

    // Sets the calendar system to use for `range` and `tick0` if this is a date axis. This does not set the calendar
    // for interpreting data on this axis, that's specified in the trace or via the global `layout.calendar`
    // - Default: gregorian
    Layout::Scene::Yaxis& calendar(enum Calendar f);

    // Sets the order in which categories on this axis appear. Only has an effect if `categoryorder` is set to *array*.
    // Used with `categoryorder`.
    template <typename T, typename = std::enable_if_t<is_data_array_element_v<T>>>
    Layout::Scene::Yaxis& categoryarray(const std::vector<T>& f);
    template <
        typename T, typename Callable,
        typename = std::enable_if_t<is_data_array_element_v<T> && (std::is_invocable_v<Callable, std::vector<T>&>)>>
    Layout::Scene::Yaxis& categoryarray(Callable&& c);

    // Sets the source reference on Chart Studio Cloud for `categoryarray`.
    Layout::Scene::Yaxis& categoryarraysrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Yaxis& categoryarraysrc(Callable&& c);

    // Specifies the ordering logic for the case of categorical variables. By default, plotly uses *trace*, which
    // specifies the order that is present in the data supplied. Set `categoryorder` to *category ascending* or
    // *category descending* if order should be determined by the alphanumerical order of the category names. Set
    // `categoryorder` to *array* to derive the ordering from the attribute `categoryarray`. If a category is not found
    // in the `categoryarray` array, the sorting behavior for that attribute will be identical to the *trace* mode. The
    // unspecified categories will follow the categories in `categoryarray`. Set `categoryorder` to *total ascending* or
    // *total descending* if order should be determined by the numerical order of the values. Similarly, the order can
    // be determined by the min, max, sum, mean, geometric mean or median of all the values.
    // - Default: trace
    Layout::Scene::Yaxis& categoryorder(enum Categoryorder f);

    // Sets default for all colors associated with this axis all at once: line, font, tick, and grid colors. Grid color
    // is lightened by blending this with the plot background Individual pieces can override this.
    Layout::Scene::Yaxis& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Yaxis& color(Callable&& c);

    // Sets the step in-between ticks on this axis. Use with `tick0`. Must be a positive number, or special strings
    // available to *log* and *date* axes. If the axis `type` is *log*, then ticks are set every 10^(n*dtick) where n is
    // the tick number. For example, to set a tick mark at 1, 10, 100, 1000, ... set dtick to 1. To set tick marks at 1,
    // 100, 10000, ... set dtick to 2. To set tick marks at 1, 5, 25, 125, 625, 3125, ... set dtick to log_10(5), or
    // 0.69897000433. *log* has several special values; *L<f>*, where `f` is a positive number, gives ticks linearly
    // spaced in value (but not position). For example `tick0` = 0.1, `dtick` = *L0.5* will put ticks at 0.1,
    // 0.6, 1.1, 1.6 etc. To show powers of 10 plus small digits between, use *D1* (all digits) or *D2* (only 2 and 5).
    // `tick0` is ignored for *D1* and *D2*. If the axis `type` is *date*, then you must convert the time to
    // milliseconds. For example, to set the interval between ticks to one day, set `dtick` to 86400000.0. *date* also
    // has special values *M<n>* gives ticks spaced by a number of months. `n` must be a positive integer. To set ticks
    // on the 15th of every third month, set `tick0` to *2000-01-15* and `dtick` to *M3*. To set ticks every 4 years,
    // set `dtick` to *M48*
    template <typename T>
    Layout::Scene::Yaxis& dtick(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Scene::Yaxis& dtick(Callable&& c);

    // Determines a formatting rule for the tick exponents. For example, consider the number 1,000,000,000. If *none*,
    // it appears as 1,000,000,000. If *e*, 1e+9. If *E*, 1E+9. If *power*, 1x10^9 (with 9 in a super script). If *SI*,
    // 1G. If *B*, 1B.
    // - Default: B
    Layout::Scene::Yaxis& exponentformat(enum Exponentformat f);

    // Sets the color of the grid lines.
    Layout::Scene::Yaxis& gridcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Yaxis& gridcolor(Callable&& c);

    // Sets the width (in px) of the grid lines.
    Layout::Scene::Yaxis& gridwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Yaxis& gridwidth(Callable&& c);

    // Sets the hover text formatting rule using d3 formatting mini-languages which are very similar to those in Python.
    // For numbers, see: https://github.com/d3/d3-format/tree/v1.4.5#d3-format. And for dates see:
    // https://github.com/d3/d3-time-format/tree/v2.2.3#locale_format. We add two items to d3's date formatter: *%h* for
    // half of the year as a decimal number as well as *%{n}f* for fractional seconds with n digits. For example,
    // *2016-10-13 09:15:23.456* with tickformat *%H~%M~%S.%2f* would display *09~15~23.46*
    Layout::Scene::Yaxis& hoverformat(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Yaxis& hoverformat(Callable&& c);

    // Replacement text for specific tick or hover labels. For example using {US: 'USA', CA: 'Canada'} changes US to USA
    // and CA to Canada. The labels we would have shown must match the keys exactly, after adding any tickprefix or
    // ticksuffix. For negative numbers the minus sign symbol used (U+2212) is wider than the regular ascii dash. That
    // means you need to use 1 instead of -1. labelalias can be used with any axis type, and both keys (if needed) and
    // values (if desired) can include html-like tags or MathJax.
    template <typename T>
    Layout::Scene::Yaxis& labelalias(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Scene::Yaxis& labelalias(Callable&& c);

    // Sets the axis line color.
    Layout::Scene::Yaxis& linecolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Yaxis& linecolor(Callable&& c);

    // Sets the width (in px) of the axis line.
    Layout::Scene::Yaxis& linewidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Yaxis& linewidth(Callable&& c);

    // Determines the maximum range of this axis.
    template <typename T>
    Layout::Scene::Yaxis& maxallowed(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Scene::Yaxis& maxallowed(Callable&& c);

    // Determines the minimum range of this axis.
    template <typename T>
    Layout::Scene::Yaxis& minallowed(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Scene::Yaxis& minallowed(Callable&& c);

    // Hide SI prefix for 10^n if |n| is below this number. This only has an effect when `tickformat` is *SI* or *B*.
    Layout::Scene::Yaxis& minexponent(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Yaxis& minexponent(Callable&& c);

    // Determines if the axis lines or/and ticks are mirrored to the opposite side of the plotting area. If *true*, the
    // axis lines are mirrored. If *ticks*, the axis lines and ticks are mirrored. If *false*, mirroring is disable. If
    // *all*, axis lines are mirrored on all shared-axes subplots. If *allticks*, axis lines and ticks are mirrored on
    // all shared-axes subplots.
    // - Default: False
    Layout::Scene::Yaxis& mirror(enum Mirror f);

    // Specifies the maximum number of ticks for the particular axis. The actual number of ticks will be chosen
    // automatically to be less than or equal to `nticks`. Has an effect only if `tickmode` is set to *auto*.
    Layout::Scene::Yaxis& nticks(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Scene::Yaxis& nticks(Callable&& c);

    // Sets the range of this axis. If the axis `type` is *log*, then you must take the log of your desired range (e.g.
    // to set the range from 1 to 100, set the range from 0 to 2). If the axis `type` is *date*, it should be date
    // strings, like date data, though Date objects and unix milliseconds will be accepted and converted to strings. If
    // the axis `type` is *category*, it should be numbers, using the scale where each category is assigned a serial
    // number from zero in the order it appears. Leaving either or both elements `null` impacts the default `autorange`.
    Layout::Scene::Yaxis& range(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Scene::Yaxis& range(Callable&& c);

    // If *normal*, the range is computed in relation to the extrema of the input data. If *tozero*`, the range extends
    // to 0, regardless of the input data If *nonnegative*, the range is non-negative, regardless of the input data.
    // Applies only to linear axes.
    // - Default: normal
    Layout::Scene::Yaxis& rangemode(enum Rangemode f);

    // If "true", even 4-digit integers are separated
    Layout::Scene::Yaxis& separatethousands(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Scene::Yaxis& separatethousands(Callable&& c);

    // Sets whether or not this axis is labeled
    Layout::Scene::Yaxis& showaxeslabels(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Scene::Yaxis& showaxeslabels(Callable&& c);

    // Sets whether or not this axis' wall has a background color.
    Layout::Scene::Yaxis& showbackground(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Scene::Yaxis& showbackground(Callable&& c);

    // If *all*, all exponents are shown besides their significands. If *first*, only the exponent of the first tick is
    // shown. If *last*, only the exponent of the last tick is shown. If *none*, no exponents appear.
    // - Default: all
    Layout::Scene::Yaxis& showexponent(enum Showexponent f);

    // Determines whether or not grid lines are drawn. If *true*, the grid lines are drawn at every tick mark.
    Layout::Scene::Yaxis& showgrid(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Scene::Yaxis& showgrid(Callable&& c);

    // Determines whether or not a line bounding this axis is drawn.
    Layout::Scene::Yaxis& showline(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Scene::Yaxis& showline(Callable&& c);

    // Sets whether or not spikes starting from data points to this axis' wall are shown on hover.
    Layout::Scene::Yaxis& showspikes(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Scene::Yaxis& showspikes(Callable&& c);

    // Determines whether or not the tick labels are drawn.
    Layout::Scene::Yaxis& showticklabels(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Scene::Yaxis& showticklabels(Callable&& c);

    // If *all*, all tick labels are displayed with a prefix. If *first*, only the first tick is displayed with a
    // prefix. If *last*, only the last tick is displayed with a suffix. If *none*, tick prefixes are hidden.
    // - Default: all
    Layout::Scene::Yaxis& showtickprefix(enum Showtickprefix f);

    // Same as `showtickprefix` but for tick suffixes.
    // - Default: all
    Layout::Scene::Yaxis& showticksuffix(enum Showticksuffix f);

    // Sets the color of the spikes.
    Layout::Scene::Yaxis& spikecolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Yaxis& spikecolor(Callable&& c);

    // Sets whether or not spikes extending from the projection data points to this axis' wall boundaries are shown on
    // hover.
    Layout::Scene::Yaxis& spikesides(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Scene::Yaxis& spikesides(Callable&& c);

    // Sets the thickness (in px) of the spikes.
    Layout::Scene::Yaxis& spikethickness(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Yaxis& spikethickness(Callable&& c);

    // Sets the placement of the first tick on this axis. Use with `dtick`. If the axis `type` is *log*, then you must
    // take the log of your starting tick (e.g. to set the starting tick to 100, set the `tick0` to 2) except when
    // `dtick`=*L<f>* (see `dtick` for more info). If the axis `type` is *date*, it should be a date string, like date
    // data. If the axis `type` is *category*, it should be a number, using the scale where each category is assigned a
    // serial number from zero in the order it appears.
    template <typename T>
    Layout::Scene::Yaxis& tick0(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Scene::Yaxis& tick0(Callable&& c);

    // Sets the angle of the tick labels with respect to the horizontal. For example, a `tickangle` of -90 draws the
    // tick labels vertically.
    Layout::Scene::Yaxis& tickangle(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Yaxis& tickangle(Callable&& c);

    // Sets the tick color.
    Layout::Scene::Yaxis& tickcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Yaxis& tickcolor(Callable&& c);

    // Sets the tick font.
    Layout::Scene::Yaxis& tickfont(Tickfont f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Tickfont&>>>
    Layout::Scene::Yaxis& tickfont(Callable&& c);

    // Sets the tick label formatting rule using d3 formatting mini-languages which are very similar to those in Python.
    // For numbers, see: https://github.com/d3/d3-format/tree/v1.4.5#d3-format. And for dates see:
    // https://github.com/d3/d3-time-format/tree/v2.2.3#locale_format. We add two items to d3's date formatter: *%h* for
    // half of the year as a decimal number as well as *%{n}f* for fractional seconds with n digits. For example,
    // *2016-10-13 09:15:23.456* with tickformat *%H~%M~%S.%2f* would display *09~15~23.46*
    Layout::Scene::Yaxis& tickformat(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Yaxis& tickformat(Callable&& c);

    Layout::Scene::Yaxis& tickformatstops(Tickformatstops f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Tickformatstops&>>>
    Layout::Scene::Yaxis& tickformatstops(Callable&& c);

    // Sets the tick length (in px).
    Layout::Scene::Yaxis& ticklen(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Yaxis& ticklen(Callable&& c);

    // Sets the tick mode for this axis. If *auto*, the number of ticks is set via `nticks`. If *linear*, the placement
    // of the ticks is determined by a starting position `tick0` and a tick step `dtick` (*linear* is the default value
    // if `tick0` and `dtick` are provided). If *array*, the placement of the ticks is set via `tickvals` and the tick
    // text is `ticktext`. (*array* is the default value if `tickvals` is provided).
    Layout::Scene::Yaxis& tickmode(enum Tickmode f);

    // Sets a tick label prefix.
    Layout::Scene::Yaxis& tickprefix(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Yaxis& tickprefix(Callable&& c);

    // Determines whether ticks are drawn or not. If **, this axis' ticks are not drawn. If *outside* (*inside*), this
    // axis' are drawn outside (inside) the axis lines.
    Layout::Scene::Yaxis& ticks(enum Ticks f);

    // Sets a tick label suffix.
    Layout::Scene::Yaxis& ticksuffix(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Yaxis& ticksuffix(Callable&& c);

    // Sets the text displayed at the ticks position via `tickvals`. Only has an effect if `tickmode` is set to *array*.
    // Used with `tickvals`.
    template <typename T, typename = std::enable_if_t<is_data_array_element_v<T>>>
    Layout::Scene::Yaxis& ticktext(const std::vector<T>& f);
    template <
        typename T, typename Callable,
        typename = std::enable_if_t<is_data_array_element_v<T> && (std::is_invocable_v<Callable, std::vector<T>&>)>>
    Layout::Scene::Yaxis& ticktext(Callable&& c);

    // Sets the source reference on Chart Studio Cloud for `ticktext`.
    Layout::Scene::Yaxis& ticktextsrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Yaxis& ticktextsrc(Callable&& c);

    // Sets the values at which ticks on this axis appear. Only has an effect if `tickmode` is set to *array*. Used with
    // `ticktext`.
    template <typename T, typename = std::enable_if_t<is_data_array_element_v<T>>>
    Layout::Scene::Yaxis& tickvals(const std::vector<T>& f);
    template <
        typename T, typename Callable,
        typename = std::enable_if_t<is_data_array_element_v<T> && (std::is_invocable_v<Callable, std::vector<T>&>)>>
    Layout::Scene::Yaxis& tickvals(Callable&& c);

    // Sets the source reference on Chart Studio Cloud for `tickvals`.
    Layout::Scene::Yaxis& tickvalssrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Yaxis& tickvalssrc(Callable&& c);

    // Sets the tick width (in px).
    Layout::Scene::Yaxis& tickwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Yaxis& tickwidth(Callable&& c);

    Layout::Scene::Yaxis& title(Title f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Title&>>>
    Layout::Scene::Yaxis& title(Callable&& c);

    // Sets the axis type. By default, plotly attempts to determined the axis type by looking into the data of the
    // traces that referenced the axis in question.
    // - Default: -
    Layout::Scene::Yaxis& type(enum Type f);

    // A single toggle to hide the axis while preserving interaction like dragging. Default is true when a cheater plot
    // is present on the axis, otherwise false
    Layout::Scene::Yaxis& visible(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Scene::Yaxis& visible(Callable&& c);

    // Determines whether or not a line is drawn at along the 0 value of this axis. If *true*, the zero line is drawn on
    // top of the grid lines.
    Layout::Scene::Yaxis& zeroline(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Scene::Yaxis& zeroline(Callable&& c);

    // Sets the line color of the zero line.
    Layout::Scene::Yaxis& zerolinecolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Yaxis& zerolinecolor(Callable&& c);

    // Sets the width (in px) of the zero line.
    Layout::Scene::Yaxis& zerolinewidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Yaxis& zerolinewidth(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Scene::Yaxis::Autorangeoptions {
 public:
    Autorangeoptions() = default;
    Autorangeoptions(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Clip autorange maximum if it goes beyond this value. Has no effect when `autorangeoptions.maxallowed` is
    // provided.
    template <typename T>
    Layout::Scene::Yaxis::Autorangeoptions& clipmax(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Scene::Yaxis::Autorangeoptions& clipmax(Callable&& c);

    // Clip autorange minimum if it goes beyond this value. Has no effect when `autorangeoptions.minallowed` is
    // provided.
    template <typename T>
    Layout::Scene::Yaxis::Autorangeoptions& clipmin(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Scene::Yaxis::Autorangeoptions& clipmin(Callable&& c);

    // Ensure this value is included in autorange.
    template <typename T>
    Layout::Scene::Yaxis::Autorangeoptions& include(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Scene::Yaxis::Autorangeoptions& include(Callable&& c);
    template <typename T>
    Layout::Scene::Yaxis::Autorangeoptions& include(const std::vector<T>& f);

    // Sets the source reference on Chart Studio Cloud for `include`.
    Layout::Scene::Yaxis::Autorangeoptions& includesrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Yaxis::Autorangeoptions& includesrc(Callable&& c);

    // Use this value exactly as autorange maximum.
    template <typename T>
    Layout::Scene::Yaxis::Autorangeoptions& maxallowed(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Scene::Yaxis::Autorangeoptions& maxallowed(Callable&& c);

    // Use this value exactly as autorange minimum.
    template <typename T>
    Layout::Scene::Yaxis::Autorangeoptions& minallowed(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Scene::Yaxis::Autorangeoptions& minallowed(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets the tick font.
class Layout::Scene::Yaxis::Tickfont {
 public:
    Tickfont() = default;
    Tickfont(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    enum class Textcase {
        Normal,
        WordCaps,
        Upper,
        Lower,
    };
    static std::string to_string(Textcase e);

    enum class Variant {
        Normal,
        SmallCaps,
        AllSmallCaps,
        AllPetiteCaps,
        PetiteCaps,
        Unicase,
    };
    static std::string to_string(Variant e);

    Layout::Scene::Yaxis::Tickfont& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Yaxis::Tickfont& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Scene::Yaxis::Tickfont& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Yaxis::Tickfont& family(Callable&& c);

    // Sets the kind of decoration line(s) with text, such as an *under*, *over* or *through* as well as combinations
    // e.g. *under+over*, etc.
    // - Default: none
    // - Flags: ['under', 'over', 'through']
    // - Extras ['none']
    Layout::Scene::Yaxis::Tickfont& lineposition(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Yaxis::Tickfont& lineposition(Callable&& c);

    // Sets the shape and color of the shadow behind text. *auto* places minimal shadow and applies contrast text font
    // color. See https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow for additional options.
    Layout::Scene::Yaxis::Tickfont& shadow(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Yaxis::Tickfont& shadow(Callable&& c);

    Layout::Scene::Yaxis::Tickfont& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Yaxis::Tickfont& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Scene::Yaxis::Tickfont& style(enum Style f);

    // Sets capitalization of text. It can be used to make text appear in all-uppercase or all-lowercase, or with each
    // word capitalized.
    // - Default: normal
    Layout::Scene::Yaxis::Tickfont& textcase(enum Textcase f);

    // Sets the variant of the font.
    // - Default: normal
    Layout::Scene::Yaxis::Tickfont& variant(enum Variant f);

    // Sets the weight (or boldness) of the font.
    Layout::Scene::Yaxis::Tickfont& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Scene::Yaxis::Tickfont& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Scene::Yaxis::Tickformatstops {
 public:
    Tickformatstops() = default;
    Tickformatstops(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    class Tickformatstop;

    Layout::Scene::Yaxis::Tickformatstops& tickformatstop(Tickformatstop f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Tickformatstop&>>>
    Layout::Scene::Yaxis::Tickformatstops& tickformatstop(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Scene::Yaxis::Tickformatstops::Tickformatstop {
 public:
    Tickformatstop() = default;
    Tickformatstop(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // range [*min*, *max*], where *min*, *max* - dtick values which describe some zoom level, it is possible to omit
    // *min* or *max* value by passing *null*
    Layout::Scene::Yaxis::Tickformatstops::Tickformatstop& dtickrange(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Scene::Yaxis::Tickformatstops::Tickformatstop& dtickrange(Callable&& c);

    // Determines whether or not this stop is used. If `false`, this stop is ignored even within its `dtickrange`.
    Layout::Scene::Yaxis::Tickformatstops::Tickformatstop& enabled(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Scene::Yaxis::Tickformatstops::Tickformatstop& enabled(Callable&& c);

    // When used in a template, named items are created in the output figure in addition to any items the figure already
    // has in this array. You can modify these items in the output figure by making your own item with
    // `templateitemname` matching this `name` alongside your modifications (including `visible: false` or `enabled:
    // false` to hide it). Has no effect outside of a template.
    Layout::Scene::Yaxis::Tickformatstops::Tickformatstop& name(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Yaxis::Tickformatstops::Tickformatstop& name(Callable&& c);

    // Used to refer to a named item in this array in the template. Named items from the template will be created even
    // without a matching item in the input figure, but you can modify one by making an item with `templateitemname`
    // matching its `name`, alongside your modifications (including `visible: false` or `enabled: false` to hide it). If
    // there is no template or no matching item, this item will be hidden unless you explicitly show it with `visible:
    // true`.
    Layout::Scene::Yaxis::Tickformatstops::Tickformatstop& templateitemname(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Yaxis::Tickformatstops::Tickformatstop& templateitemname(Callable&& c);

    // string - dtickformat for described zoom level, the same as *tickformat*
    Layout::Scene::Yaxis::Tickformatstops::Tickformatstop& value(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Yaxis::Tickformatstops::Tickformatstop& value(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Scene::Yaxis::Title {
 public:
    Title() = default;
    Title(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Sets this axis' title font.
    class Font;

    // Sets this axis' title font.
    Layout::Scene::Yaxis::Title& font(Font f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Font&>>>
    Layout::Scene::Yaxis::Title& font(Callable&& c);

    // Sets the title of this axis.
    Layout::Scene::Yaxis::Title& text(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Yaxis::Title& text(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets this axis' title font.
class Layout::Scene::Yaxis::Title::Font {
 public:
    Font() = default;
    Font(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    enum class Textcase {
        Normal,
        WordCaps,
        Upper,
        Lower,
    };
    static std::string to_string(Textcase e);

    enum class Variant {
        Normal,
        SmallCaps,
        AllSmallCaps,
        AllPetiteCaps,
        PetiteCaps,
        Unicase,
    };
    static std::string to_string(Variant e);

    Layout::Scene::Yaxis::Title::Font& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Yaxis::Title::Font& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Scene::Yaxis::Title::Font& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Yaxis::Title::Font& family(Callable&& c);

    // Sets the kind of decoration line(s) with text, such as an *under*, *over* or *through* as well as combinations
    // e.g. *under+over*, etc.
    // - Default: none
    // - Flags: ['under', 'over', 'through']
    // - Extras ['none']
    Layout::Scene::Yaxis::Title::Font& lineposition(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Yaxis::Title::Font& lineposition(Callable&& c);

    // Sets the shape and color of the shadow behind text. *auto* places minimal shadow and applies contrast text font
    // color. See https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow for additional options.
    Layout::Scene::Yaxis::Title::Font& shadow(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Yaxis::Title::Font& shadow(Callable&& c);

    Layout::Scene::Yaxis::Title::Font& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Yaxis::Title::Font& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Scene::Yaxis::Title::Font& style(enum Style f);

    // Sets capitalization of text. It can be used to make text appear in all-uppercase or all-lowercase, or with each
    // word capitalized.
    // - Default: normal
    Layout::Scene::Yaxis::Title::Font& textcase(enum Textcase f);

    // Sets the variant of the font.
    // - Default: normal
    Layout::Scene::Yaxis::Title::Font& variant(enum Variant f);

    // Sets the weight (or boldness) of the font.
    Layout::Scene::Yaxis::Title::Font& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Scene::Yaxis::Title::Font& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Scene::Zaxis {
 public:
    Zaxis() = default;
    Zaxis(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Autorange {
        True,
        False,
        Reversed,
        MinReversed,
        MaxReversed,
        Min,
        Max,
    };
    static std::string to_string(Autorange e);

    enum class Autotypenumbers {
        ConvertTypes,
        Strict,
    };
    static std::string to_string(Autotypenumbers e);

    enum class Calendar {
        Chinese,
        Coptic,
        Discworld,
        Ethiopian,
        Gregorian,
        Hebrew,
        Islamic,
        Jalali,
        Julian,
        Mayan,
        Nanakshahi,
        Nepali,
        Persian,
        Taiwan,
        Thai,
        Ummalqura,
    };
    static std::string to_string(Calendar e);

    enum class Categoryorder {
        Trace,
        CategoryAscending,
        CategoryDescending,
        Array,
        TotalAscending,
        TotalDescending,
        MinAscending,
        MinDescending,
        MaxAscending,
        MaxDescending,
        SumAscending,
        SumDescending,
        MeanAscending,
        MeanDescending,
        GeometricMeanAscending,
        GeometricMeanDescending,
        MedianAscending,
        MedianDescending,
    };
    static std::string to_string(Categoryorder e);

    enum class Exponentformat {
        None,
        E,
        Power,
        Si,
        B,
    };
    static std::string to_string(Exponentformat e);

    enum class Mirror {
        True,
        Ticks,
        False,
        All,
        Allticks,
    };
    static std::string to_string(Mirror e);

    enum class Rangemode {
        Normal,
        Tozero,
        Nonnegative,
    };
    static std::string to_string(Rangemode e);

    enum class Showexponent {
        All,
        First,
        Last,
        None,
    };
    static std::string to_string(Showexponent e);

    enum class Showtickprefix {
        All,
        First,
        Last,
        None,
    };
    static std::string to_string(Showtickprefix e);

    enum class Showticksuffix {
        All,
        First,
        Last,
        None,
    };
    static std::string to_string(Showticksuffix e);

    enum class Tickmode {
        Auto,
        Linear,
        Array,
    };
    static std::string to_string(Tickmode e);

    enum class Ticks {
        Outside,
        Inside,
        Empty,
    };
    static std::string to_string(Ticks e);

    enum class Type {
        Hyphen,
        Linear,
        Log,
        Date,
        Category,
    };
    static std::string to_string(Type e);

    class Autorangeoptions;
    // Sets the tick font.
    class Tickfont;
    class Tickformatstops;
    class Title;

    // Determines whether or not the range of this axis is computed in relation to the input data. See `rangemode` for
    // more info. If `range` is provided and it has a value for both the lower and upper bound, `autorange` is set to
    // *false*. Using *min* applies autorange only to set the minimum. Using *max* applies autorange only to set the
    // maximum. Using *min reversed* applies autorange only to set the minimum on a reversed axis. Using *max reversed*
    // applies autorange only to set the maximum on a reversed axis. Using *reversed* applies autorange on both ends and
    // reverses the axis direction.
    // - Default: True
    Layout::Scene::Zaxis& autorange(enum Autorange f);

    Layout::Scene::Zaxis& autorangeoptions(Autorangeoptions f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Autorangeoptions&>>>
    Layout::Scene::Zaxis& autorangeoptions(Callable&& c);

    // Using *strict* a numeric string in trace data is not converted to a number. Using *convert types* a numeric
    // string in trace data may be treated as a number during automatic axis `type` detection. Defaults to
    // layout.autotypenumbers.
    // - Default: convert types
    Layout::Scene::Zaxis& autotypenumbers(enum Autotypenumbers f);

    // Sets the background color of this axis' wall.
    Layout::Scene::Zaxis& backgroundcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Zaxis& backgroundcolor(Callable&& c);

    // Sets the calendar system to use for `range` and `tick0` if this is a date axis. This does not set the calendar
    // for interpreting data on this axis, that's specified in the trace or via the global `layout.calendar`
    // - Default: gregorian
    Layout::Scene::Zaxis& calendar(enum Calendar f);

    // Sets the order in which categories on this axis appear. Only has an effect if `categoryorder` is set to *array*.
    // Used with `categoryorder`.
    template <typename T, typename = std::enable_if_t<is_data_array_element_v<T>>>
    Layout::Scene::Zaxis& categoryarray(const std::vector<T>& f);
    template <
        typename T, typename Callable,
        typename = std::enable_if_t<is_data_array_element_v<T> && (std::is_invocable_v<Callable, std::vector<T>&>)>>
    Layout::Scene::Zaxis& categoryarray(Callable&& c);

    // Sets the source reference on Chart Studio Cloud for `categoryarray`.
    Layout::Scene::Zaxis& categoryarraysrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Zaxis& categoryarraysrc(Callable&& c);

    // Specifies the ordering logic for the case of categorical variables. By default, plotly uses *trace*, which
    // specifies the order that is present in the data supplied. Set `categoryorder` to *category ascending* or
    // *category descending* if order should be determined by the alphanumerical order of the category names. Set
    // `categoryorder` to *array* to derive the ordering from the attribute `categoryarray`. If a category is not found
    // in the `categoryarray` array, the sorting behavior for that attribute will be identical to the *trace* mode. The
    // unspecified categories will follow the categories in `categoryarray`. Set `categoryorder` to *total ascending* or
    // *total descending* if order should be determined by the numerical order of the values. Similarly, the order can
    // be determined by the min, max, sum, mean, geometric mean or median of all the values.
    // - Default: trace
    Layout::Scene::Zaxis& categoryorder(enum Categoryorder f);

    // Sets default for all colors associated with this axis all at once: line, font, tick, and grid colors. Grid color
    // is lightened by blending this with the plot background Individual pieces can override this.
    Layout::Scene::Zaxis& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Zaxis& color(Callable&& c);

    // Sets the step in-between ticks on this axis. Use with `tick0`. Must be a positive number, or special strings
    // available to *log* and *date* axes. If the axis `type` is *log*, then ticks are set every 10^(n*dtick) where n is
    // the tick number. For example, to set a tick mark at 1, 10, 100, 1000, ... set dtick to 1. To set tick marks at 1,
    // 100, 10000, ... set dtick to 2. To set tick marks at 1, 5, 25, 125, 625, 3125, ... set dtick to log_10(5), or
    // 0.69897000433. *log* has several special values; *L<f>*, where `f` is a positive number, gives ticks linearly
    // spaced in value (but not position). For example `tick0` = 0.1, `dtick` = *L0.5* will put ticks at 0.1,
    // 0.6, 1.1, 1.6 etc. To show powers of 10 plus small digits between, use *D1* (all digits) or *D2* (only 2 and 5).
    // `tick0` is ignored for *D1* and *D2*. If the axis `type` is *date*, then you must convert the time to
    // milliseconds. For example, to set the interval between ticks to one day, set `dtick` to 86400000.0. *date* also
    // has special values *M<n>* gives ticks spaced by a number of months. `n` must be a positive integer. To set ticks
    // on the 15th of every third month, set `tick0` to *2000-01-15* and `dtick` to *M3*. To set ticks every 4 years,
    // set `dtick` to *M48*
    template <typename T>
    Layout::Scene::Zaxis& dtick(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Scene::Zaxis& dtick(Callable&& c);

    // Determines a formatting rule for the tick exponents. For example, consider the number 1,000,000,000. If *none*,
    // it appears as 1,000,000,000. If *e*, 1e+9. If *E*, 1E+9. If *power*, 1x10^9 (with 9 in a super script). If *SI*,
    // 1G. If *B*, 1B.
    // - Default: B
    Layout::Scene::Zaxis& exponentformat(enum Exponentformat f);

    // Sets the color of the grid lines.
    Layout::Scene::Zaxis& gridcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Zaxis& gridcolor(Callable&& c);

    // Sets the width (in px) of the grid lines.
    Layout::Scene::Zaxis& gridwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Zaxis& gridwidth(Callable&& c);

    // Sets the hover text formatting rule using d3 formatting mini-languages which are very similar to those in Python.
    // For numbers, see: https://github.com/d3/d3-format/tree/v1.4.5#d3-format. And for dates see:
    // https://github.com/d3/d3-time-format/tree/v2.2.3#locale_format. We add two items to d3's date formatter: *%h* for
    // half of the year as a decimal number as well as *%{n}f* for fractional seconds with n digits. For example,
    // *2016-10-13 09:15:23.456* with tickformat *%H~%M~%S.%2f* would display *09~15~23.46*
    Layout::Scene::Zaxis& hoverformat(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Zaxis& hoverformat(Callable&& c);

    // Replacement text for specific tick or hover labels. For example using {US: 'USA', CA: 'Canada'} changes US to USA
    // and CA to Canada. The labels we would have shown must match the keys exactly, after adding any tickprefix or
    // ticksuffix. For negative numbers the minus sign symbol used (U+2212) is wider than the regular ascii dash. That
    // means you need to use 1 instead of -1. labelalias can be used with any axis type, and both keys (if needed) and
    // values (if desired) can include html-like tags or MathJax.
    template <typename T>
    Layout::Scene::Zaxis& labelalias(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Scene::Zaxis& labelalias(Callable&& c);

    // Sets the axis line color.
    Layout::Scene::Zaxis& linecolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Zaxis& linecolor(Callable&& c);

    // Sets the width (in px) of the axis line.
    Layout::Scene::Zaxis& linewidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Zaxis& linewidth(Callable&& c);

    // Determines the maximum range of this axis.
    template <typename T>
    Layout::Scene::Zaxis& maxallowed(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Scene::Zaxis& maxallowed(Callable&& c);

    // Determines the minimum range of this axis.
    template <typename T>
    Layout::Scene::Zaxis& minallowed(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Scene::Zaxis& minallowed(Callable&& c);

    // Hide SI prefix for 10^n if |n| is below this number. This only has an effect when `tickformat` is *SI* or *B*.
    Layout::Scene::Zaxis& minexponent(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Zaxis& minexponent(Callable&& c);

    // Determines if the axis lines or/and ticks are mirrored to the opposite side of the plotting area. If *true*, the
    // axis lines are mirrored. If *ticks*, the axis lines and ticks are mirrored. If *false*, mirroring is disable. If
    // *all*, axis lines are mirrored on all shared-axes subplots. If *allticks*, axis lines and ticks are mirrored on
    // all shared-axes subplots.
    // - Default: False
    Layout::Scene::Zaxis& mirror(enum Mirror f);

    // Specifies the maximum number of ticks for the particular axis. The actual number of ticks will be chosen
    // automatically to be less than or equal to `nticks`. Has an effect only if `tickmode` is set to *auto*.
    Layout::Scene::Zaxis& nticks(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Scene::Zaxis& nticks(Callable&& c);

    // Sets the range of this axis. If the axis `type` is *log*, then you must take the log of your desired range (e.g.
    // to set the range from 1 to 100, set the range from 0 to 2). If the axis `type` is *date*, it should be date
    // strings, like date data, though Date objects and unix milliseconds will be accepted and converted to strings. If
    // the axis `type` is *category*, it should be numbers, using the scale where each category is assigned a serial
    // number from zero in the order it appears. Leaving either or both elements `null` impacts the default `autorange`.
    Layout::Scene::Zaxis& range(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Scene::Zaxis& range(Callable&& c);

    // If *normal*, the range is computed in relation to the extrema of the input data. If *tozero*`, the range extends
    // to 0, regardless of the input data If *nonnegative*, the range is non-negative, regardless of the input data.
    // Applies only to linear axes.
    // - Default: normal
    Layout::Scene::Zaxis& rangemode(enum Rangemode f);

    // If "true", even 4-digit integers are separated
    Layout::Scene::Zaxis& separatethousands(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Scene::Zaxis& separatethousands(Callable&& c);

    // Sets whether or not this axis is labeled
    Layout::Scene::Zaxis& showaxeslabels(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Scene::Zaxis& showaxeslabels(Callable&& c);

    // Sets whether or not this axis' wall has a background color.
    Layout::Scene::Zaxis& showbackground(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Scene::Zaxis& showbackground(Callable&& c);

    // If *all*, all exponents are shown besides their significands. If *first*, only the exponent of the first tick is
    // shown. If *last*, only the exponent of the last tick is shown. If *none*, no exponents appear.
    // - Default: all
    Layout::Scene::Zaxis& showexponent(enum Showexponent f);

    // Determines whether or not grid lines are drawn. If *true*, the grid lines are drawn at every tick mark.
    Layout::Scene::Zaxis& showgrid(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Scene::Zaxis& showgrid(Callable&& c);

    // Determines whether or not a line bounding this axis is drawn.
    Layout::Scene::Zaxis& showline(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Scene::Zaxis& showline(Callable&& c);

    // Sets whether or not spikes starting from data points to this axis' wall are shown on hover.
    Layout::Scene::Zaxis& showspikes(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Scene::Zaxis& showspikes(Callable&& c);

    // Determines whether or not the tick labels are drawn.
    Layout::Scene::Zaxis& showticklabels(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Scene::Zaxis& showticklabels(Callable&& c);

    // If *all*, all tick labels are displayed with a prefix. If *first*, only the first tick is displayed with a
    // prefix. If *last*, only the last tick is displayed with a suffix. If *none*, tick prefixes are hidden.
    // - Default: all
    Layout::Scene::Zaxis& showtickprefix(enum Showtickprefix f);

    // Same as `showtickprefix` but for tick suffixes.
    // - Default: all
    Layout::Scene::Zaxis& showticksuffix(enum Showticksuffix f);

    // Sets the color of the spikes.
    Layout::Scene::Zaxis& spikecolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Zaxis& spikecolor(Callable&& c);

    // Sets whether or not spikes extending from the projection data points to this axis' wall boundaries are shown on
    // hover.
    Layout::Scene::Zaxis& spikesides(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Scene::Zaxis& spikesides(Callable&& c);

    // Sets the thickness (in px) of the spikes.
    Layout::Scene::Zaxis& spikethickness(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Zaxis& spikethickness(Callable&& c);

    // Sets the placement of the first tick on this axis. Use with `dtick`. If the axis `type` is *log*, then you must
    // take the log of your starting tick (e.g. to set the starting tick to 100, set the `tick0` to 2) except when
    // `dtick`=*L<f>* (see `dtick` for more info). If the axis `type` is *date*, it should be a date string, like date
    // data. If the axis `type` is *category*, it should be a number, using the scale where each category is assigned a
    // serial number from zero in the order it appears.
    template <typename T>
    Layout::Scene::Zaxis& tick0(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Scene::Zaxis& tick0(Callable&& c);

    // Sets the angle of the tick labels with respect to the horizontal. For example, a `tickangle` of -90 draws the
    // tick labels vertically.
    Layout::Scene::Zaxis& tickangle(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Zaxis& tickangle(Callable&& c);

    // Sets the tick color.
    Layout::Scene::Zaxis& tickcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Zaxis& tickcolor(Callable&& c);

    // Sets the tick font.
    Layout::Scene::Zaxis& tickfont(Tickfont f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Tickfont&>>>
    Layout::Scene::Zaxis& tickfont(Callable&& c);

    // Sets the tick label formatting rule using d3 formatting mini-languages which are very similar to those in Python.
    // For numbers, see: https://github.com/d3/d3-format/tree/v1.4.5#d3-format. And for dates see:
    // https://github.com/d3/d3-time-format/tree/v2.2.3#locale_format. We add two items to d3's date formatter: *%h* for
    // half of the year as a decimal number as well as *%{n}f* for fractional seconds with n digits. For example,
    // *2016-10-13 09:15:23.456* with tickformat *%H~%M~%S.%2f* would display *09~15~23.46*
    Layout::Scene::Zaxis& tickformat(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Zaxis& tickformat(Callable&& c);

    Layout::Scene::Zaxis& tickformatstops(Tickformatstops f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Tickformatstops&>>>
    Layout::Scene::Zaxis& tickformatstops(Callable&& c);

    // Sets the tick length (in px).
    Layout::Scene::Zaxis& ticklen(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Zaxis& ticklen(Callable&& c);

    // Sets the tick mode for this axis. If *auto*, the number of ticks is set via `nticks`. If *linear*, the placement
    // of the ticks is determined by a starting position `tick0` and a tick step `dtick` (*linear* is the default value
    // if `tick0` and `dtick` are provided). If *array*, the placement of the ticks is set via `tickvals` and the tick
    // text is `ticktext`. (*array* is the default value if `tickvals` is provided).
    Layout::Scene::Zaxis& tickmode(enum Tickmode f);

    // Sets a tick label prefix.
    Layout::Scene::Zaxis& tickprefix(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Zaxis& tickprefix(Callable&& c);

    // Determines whether ticks are drawn or not. If **, this axis' ticks are not drawn. If *outside* (*inside*), this
    // axis' are drawn outside (inside) the axis lines.
    Layout::Scene::Zaxis& ticks(enum Ticks f);

    // Sets a tick label suffix.
    Layout::Scene::Zaxis& ticksuffix(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Zaxis& ticksuffix(Callable&& c);

    // Sets the text displayed at the ticks position via `tickvals`. Only has an effect if `tickmode` is set to *array*.
    // Used with `tickvals`.
    template <typename T, typename = std::enable_if_t<is_data_array_element_v<T>>>
    Layout::Scene::Zaxis& ticktext(const std::vector<T>& f);
    template <
        typename T, typename Callable,
        typename = std::enable_if_t<is_data_array_element_v<T> && (std::is_invocable_v<Callable, std::vector<T>&>)>>
    Layout::Scene::Zaxis& ticktext(Callable&& c);

    // Sets the source reference on Chart Studio Cloud for `ticktext`.
    Layout::Scene::Zaxis& ticktextsrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Zaxis& ticktextsrc(Callable&& c);

    // Sets the values at which ticks on this axis appear. Only has an effect if `tickmode` is set to *array*. Used with
    // `ticktext`.
    template <typename T, typename = std::enable_if_t<is_data_array_element_v<T>>>
    Layout::Scene::Zaxis& tickvals(const std::vector<T>& f);
    template <
        typename T, typename Callable,
        typename = std::enable_if_t<is_data_array_element_v<T> && (std::is_invocable_v<Callable, std::vector<T>&>)>>
    Layout::Scene::Zaxis& tickvals(Callable&& c);

    // Sets the source reference on Chart Studio Cloud for `tickvals`.
    Layout::Scene::Zaxis& tickvalssrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Zaxis& tickvalssrc(Callable&& c);

    // Sets the tick width (in px).
    Layout::Scene::Zaxis& tickwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Zaxis& tickwidth(Callable&& c);

    Layout::Scene::Zaxis& title(Title f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Title&>>>
    Layout::Scene::Zaxis& title(Callable&& c);

    // Sets the axis type. By default, plotly attempts to determined the axis type by looking into the data of the
    // traces that referenced the axis in question.
    // - Default: -
    Layout::Scene::Zaxis& type(enum Type f);

    // A single toggle to hide the axis while preserving interaction like dragging. Default is true when a cheater plot
    // is present on the axis, otherwise false
    Layout::Scene::Zaxis& visible(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Scene::Zaxis& visible(Callable&& c);

    // Determines whether or not a line is drawn at along the 0 value of this axis. If *true*, the zero line is drawn on
    // top of the grid lines.
    Layout::Scene::Zaxis& zeroline(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Scene::Zaxis& zeroline(Callable&& c);

    // Sets the line color of the zero line.
    Layout::Scene::Zaxis& zerolinecolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Zaxis& zerolinecolor(Callable&& c);

    // Sets the width (in px) of the zero line.
    Layout::Scene::Zaxis& zerolinewidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Zaxis& zerolinewidth(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Scene::Zaxis::Autorangeoptions {
 public:
    Autorangeoptions() = default;
    Autorangeoptions(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Clip autorange maximum if it goes beyond this value. Has no effect when `autorangeoptions.maxallowed` is
    // provided.
    template <typename T>
    Layout::Scene::Zaxis::Autorangeoptions& clipmax(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Scene::Zaxis::Autorangeoptions& clipmax(Callable&& c);

    // Clip autorange minimum if it goes beyond this value. Has no effect when `autorangeoptions.minallowed` is
    // provided.
    template <typename T>
    Layout::Scene::Zaxis::Autorangeoptions& clipmin(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Scene::Zaxis::Autorangeoptions& clipmin(Callable&& c);

    // Ensure this value is included in autorange.
    template <typename T>
    Layout::Scene::Zaxis::Autorangeoptions& include(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Scene::Zaxis::Autorangeoptions& include(Callable&& c);
    template <typename T>
    Layout::Scene::Zaxis::Autorangeoptions& include(const std::vector<T>& f);

    // Sets the source reference on Chart Studio Cloud for `include`.
    Layout::Scene::Zaxis::Autorangeoptions& includesrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Zaxis::Autorangeoptions& includesrc(Callable&& c);

    // Use this value exactly as autorange maximum.
    template <typename T>
    Layout::Scene::Zaxis::Autorangeoptions& maxallowed(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Scene::Zaxis::Autorangeoptions& maxallowed(Callable&& c);

    // Use this value exactly as autorange minimum.
    template <typename T>
    Layout::Scene::Zaxis::Autorangeoptions& minallowed(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Scene::Zaxis::Autorangeoptions& minallowed(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets the tick font.
class Layout::Scene::Zaxis::Tickfont {
 public:
    Tickfont() = default;
    Tickfont(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    enum class Textcase {
        Normal,
        WordCaps,
        Upper,
        Lower,
    };
    static std::string to_string(Textcase e);

    enum class Variant {
        Normal,
        SmallCaps,
        AllSmallCaps,
        AllPetiteCaps,
        PetiteCaps,
        Unicase,
    };
    static std::string to_string(Variant e);

    Layout::Scene::Zaxis::Tickfont& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Zaxis::Tickfont& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Scene::Zaxis::Tickfont& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Zaxis::Tickfont& family(Callable&& c);

    // Sets the kind of decoration line(s) with text, such as an *under*, *over* or *through* as well as combinations
    // e.g. *under+over*, etc.
    // - Default: none
    // - Flags: ['under', 'over', 'through']
    // - Extras ['none']
    Layout::Scene::Zaxis::Tickfont& lineposition(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Zaxis::Tickfont& lineposition(Callable&& c);

    // Sets the shape and color of the shadow behind text. *auto* places minimal shadow and applies contrast text font
    // color. See https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow for additional options.
    Layout::Scene::Zaxis::Tickfont& shadow(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Zaxis::Tickfont& shadow(Callable&& c);

    Layout::Scene::Zaxis::Tickfont& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Zaxis::Tickfont& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Scene::Zaxis::Tickfont& style(enum Style f);

    // Sets capitalization of text. It can be used to make text appear in all-uppercase or all-lowercase, or with each
    // word capitalized.
    // - Default: normal
    Layout::Scene::Zaxis::Tickfont& textcase(enum Textcase f);

    // Sets the variant of the font.
    // - Default: normal
    Layout::Scene::Zaxis::Tickfont& variant(enum Variant f);

    // Sets the weight (or boldness) of the font.
    Layout::Scene::Zaxis::Tickfont& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Scene::Zaxis::Tickfont& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Scene::Zaxis::Tickformatstops {
 public:
    Tickformatstops() = default;
    Tickformatstops(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    class Tickformatstop;

    Layout::Scene::Zaxis::Tickformatstops& tickformatstop(Tickformatstop f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Tickformatstop&>>>
    Layout::Scene::Zaxis::Tickformatstops& tickformatstop(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Scene::Zaxis::Tickformatstops::Tickformatstop {
 public:
    Tickformatstop() = default;
    Tickformatstop(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // range [*min*, *max*], where *min*, *max* - dtick values which describe some zoom level, it is possible to omit
    // *min* or *max* value by passing *null*
    Layout::Scene::Zaxis::Tickformatstops::Tickformatstop& dtickrange(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Scene::Zaxis::Tickformatstops::Tickformatstop& dtickrange(Callable&& c);

    // Determines whether or not this stop is used. If `false`, this stop is ignored even within its `dtickrange`.
    Layout::Scene::Zaxis::Tickformatstops::Tickformatstop& enabled(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Scene::Zaxis::Tickformatstops::Tickformatstop& enabled(Callable&& c);

    // When used in a template, named items are created in the output figure in addition to any items the figure already
    // has in this array. You can modify these items in the output figure by making your own item with
    // `templateitemname` matching this `name` alongside your modifications (including `visible: false` or `enabled:
    // false` to hide it). Has no effect outside of a template.
    Layout::Scene::Zaxis::Tickformatstops::Tickformatstop& name(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Zaxis::Tickformatstops::Tickformatstop& name(Callable&& c);

    // Used to refer to a named item in this array in the template. Named items from the template will be created even
    // without a matching item in the input figure, but you can modify one by making an item with `templateitemname`
    // matching its `name`, alongside your modifications (including `visible: false` or `enabled: false` to hide it). If
    // there is no template or no matching item, this item will be hidden unless you explicitly show it with `visible:
    // true`.
    Layout::Scene::Zaxis::Tickformatstops::Tickformatstop& templateitemname(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Zaxis::Tickformatstops::Tickformatstop& templateitemname(Callable&& c);

    // string - dtickformat for described zoom level, the same as *tickformat*
    Layout::Scene::Zaxis::Tickformatstops::Tickformatstop& value(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Zaxis::Tickformatstops::Tickformatstop& value(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Scene::Zaxis::Title {
 public:
    Title() = default;
    Title(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Sets this axis' title font.
    class Font;

    // Sets this axis' title font.
    Layout::Scene::Zaxis::Title& font(Font f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Font&>>>
    Layout::Scene::Zaxis::Title& font(Callable&& c);

    // Sets the title of this axis.
    Layout::Scene::Zaxis::Title& text(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Zaxis::Title& text(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets this axis' title font.
class Layout::Scene::Zaxis::Title::Font {
 public:
    Font() = default;
    Font(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    enum class Textcase {
        Normal,
        WordCaps,
        Upper,
        Lower,
    };
    static std::string to_string(Textcase e);

    enum class Variant {
        Normal,
        SmallCaps,
        AllSmallCaps,
        AllPetiteCaps,
        PetiteCaps,
        Unicase,
    };
    static std::string to_string(Variant e);

    Layout::Scene::Zaxis::Title::Font& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Zaxis::Title::Font& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Scene::Zaxis::Title::Font& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Zaxis::Title::Font& family(Callable&& c);

    // Sets the kind of decoration line(s) with text, such as an *under*, *over* or *through* as well as combinations
    // e.g. *under+over*, etc.
    // - Default: none
    // - Flags: ['under', 'over', 'through']
    // - Extras ['none']
    Layout::Scene::Zaxis::Title::Font& lineposition(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Zaxis::Title::Font& lineposition(Callable&& c);

    // Sets the shape and color of the shadow behind text. *auto* places minimal shadow and applies contrast text font
    // color. See https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow for additional options.
    Layout::Scene::Zaxis::Title::Font& shadow(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Scene::Zaxis::Title::Font& shadow(Callable&& c);

    Layout::Scene::Zaxis::Title::Font& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Scene::Zaxis::Title::Font& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Scene::Zaxis::Title::Font& style(enum Style f);

    // Sets capitalization of text. It can be used to make text appear in all-uppercase or all-lowercase, or with each
    // word capitalized.
    // - Default: normal
    Layout::Scene::Zaxis::Title::Font& textcase(enum Textcase f);

    // Sets the variant of the font.
    // - Default: normal
    Layout::Scene::Zaxis::Title::Font& variant(enum Variant f);

    // Sets the weight (or boldness) of the font.
    Layout::Scene::Zaxis::Title::Font& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Scene::Zaxis::Title::Font& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Selections {
 public:
    Selections() = default;
    Selections(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    class Selection;

    Layout::Selections& selection(Selection f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Selection&>>>
    Layout::Selections& selection(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Selections::Selection {
 public:
    Selection() = default;
    Selection(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Type {
        Rect,
        Path,
    };
    static std::string to_string(Type e);

    class Line;

    Layout::Selections::Selection& line(Line f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Line&>>>
    Layout::Selections::Selection& line(Callable&& c);

    // When used in a template, named items are created in the output figure in addition to any items the figure already
    // has in this array. You can modify these items in the output figure by making your own item with
    // `templateitemname` matching this `name` alongside your modifications (including `visible: false` or `enabled:
    // false` to hide it). Has no effect outside of a template.
    Layout::Selections::Selection& name(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Selections::Selection& name(Callable&& c);

    // Sets the opacity of the selection.
    Layout::Selections::Selection& opacity(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Selections::Selection& opacity(Callable&& c);

    // For `type` *path* - a valid SVG path similar to `shapes.path` in data coordinates. Allowed segments are: M, L and
    // Z.
    Layout::Selections::Selection& path(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Selections::Selection& path(Callable&& c);

    // Used to refer to a named item in this array in the template. Named items from the template will be created even
    // without a matching item in the input figure, but you can modify one by making an item with `templateitemname`
    // matching its `name`, alongside your modifications (including `visible: false` or `enabled: false` to hide it). If
    // there is no template or no matching item, this item will be hidden unless you explicitly show it with `visible:
    // true`.
    Layout::Selections::Selection& templateitemname(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Selections::Selection& templateitemname(Callable&& c);

    // Specifies the selection type to be drawn. If *rect*, a rectangle is drawn linking (`x0`,`y0`), (`x1`,`y0`),
    // (`x1`,`y1`) and (`x0`,`y1`). If *path*, draw a custom SVG path using `path`.
    Layout::Selections::Selection& type(enum Type f);

    // Sets the selection's starting x position.
    template <typename T>
    Layout::Selections::Selection& x0(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Selections::Selection& x0(Callable&& c);

    // Sets the selection's end x position.
    template <typename T>
    Layout::Selections::Selection& x1(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Selections::Selection& x1(Callable&& c);

    // Sets the selection's x coordinate axis. If set to a x axis id (e.g. *x* or *x2*), the `x` position refers to a x
    // coordinate. If set to *paper*, the `x` position refers to the distance from the left of the plotting area in
    // normalized coordinates where *0* (*1*) corresponds to the left (right). If set to a x axis ID followed by
    // *domain* (separated by a space), the position behaves like for *paper*, but refers to the distance in fractions
    // of the domain length from the left of the domain of that axis: e.g., *x2 domain* refers to the domain of the
    // second x  axis and a x position of 0.5 refers to the point between the left and the right of the domain of the
    // second x axis.
    Layout::Selections::Selection& xref(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Selections::Selection& xref(Callable&& c);

    // Sets the selection's starting y position.
    template <typename T>
    Layout::Selections::Selection& y0(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Selections::Selection& y0(Callable&& c);

    // Sets the selection's end y position.
    template <typename T>
    Layout::Selections::Selection& y1(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Selections::Selection& y1(Callable&& c);

    // Sets the selection's x coordinate axis. If set to a y axis id (e.g. *y* or *y2*), the `y` position refers to a y
    // coordinate. If set to *paper*, the `y` position refers to the distance from the bottom of the plotting area in
    // normalized coordinates where *0* (*1*) corresponds to the bottom (top). If set to a y axis ID followed by
    // *domain* (separated by a space), the position behaves like for *paper*, but refers to the distance in fractions
    // of the domain length from the bottom of the domain of that axis: e.g., *y2 domain* refers to the domain of the
    // second y  axis and a y position of 0.5 refers to the point between the bottom and the top of the domain of the
    // second y axis.
    Layout::Selections::Selection& yref(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Selections::Selection& yref(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Selections::Selection::Line {
 public:
    Line() = default;
    Line(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Sets the line color.
    Layout::Selections::Selection::Line& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Selections::Selection::Line& color(Callable&& c);

    // Sets the dash style of lines. Set to a dash type string (*solid*, *dot*, *dash*, *longdash*, *dashdot*, or
    // *longdashdot*) or a dash length list in px (eg *5px,10px,2px,2px*).
    Layout::Selections::Selection::Line& dash(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Selections::Selection::Line& dash(Callable&& c);

    // Sets the line width (in px).
    Layout::Selections::Selection::Line& width(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Selections::Selection::Line& width(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Shapes {
 public:
    Shapes() = default;
    Shapes(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    class Shape;

    Layout::Shapes& shape(Shape f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Shape&>>>
    Layout::Shapes& shape(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Shapes::Shape {
 public:
    Shape() = default;
    Shape(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Fillrule {
        Evenodd,
        Nonzero,
    };
    static std::string to_string(Fillrule e);

    enum class Layer {
        Below,
        Above,
        Between,
    };
    static std::string to_string(Layer e);

    enum class Type {
        Circle,
        Rect,
        Path,
        Line,
    };
    static std::string to_string(Type e);

    enum class Visible {
        True,
        False,
        Legendonly,
    };
    static std::string to_string(Visible e);

    enum class Xsizemode {
        Scaled,
        Pixel,
    };
    static std::string to_string(Xsizemode e);

    enum class Ysizemode {
        Scaled,
        Pixel,
    };
    static std::string to_string(Ysizemode e);

    class Label;
    class Legendgrouptitle;
    class Line;

    // Determines whether the shape could be activated for edit or not. Has no effect when the older editable shapes
    // mode is enabled via `config.editable` or `config.edits.shapePosition`.
    Layout::Shapes::Shape& editable(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Shapes::Shape& editable(Callable&& c);

    // Sets the color filling the shape's interior. Only applies to closed shapes.
    Layout::Shapes::Shape& fillcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Shapes::Shape& fillcolor(Callable&& c);

    // Determines which regions of complex paths constitute the interior. For more info please visit
    // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-rule
    // - Default: evenodd
    Layout::Shapes::Shape& fillrule(enum Fillrule f);

    Layout::Shapes::Shape& label(Label f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Label&>>>
    Layout::Shapes::Shape& label(Callable&& c);

    // Specifies whether shapes are drawn below gridlines (*below*), between gridlines and traces (*between*) or above
    // traces (*above*).
    // - Default: above
    Layout::Shapes::Shape& layer(enum Layer f);

    // Sets the reference to a legend to show this shape in. References to these legends are *legend*, *legend2*,
    // *legend3*, etc. Settings for these legends are set in the layout, under `layout.legend`, `layout.legend2`, etc.
    Layout::Shapes::Shape& legend(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Shapes::Shape& legend(Callable&& c);

    // Sets the legend group for this shape. Traces and shapes part of the same legend group hide/show at the same time
    // when toggling legend items.
    Layout::Shapes::Shape& legendgroup(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Shapes::Shape& legendgroup(Callable&& c);

    Layout::Shapes::Shape& legendgrouptitle(Legendgrouptitle f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Legendgrouptitle&>>>
    Layout::Shapes::Shape& legendgrouptitle(Callable&& c);

    // Sets the legend rank for this shape. Items and groups with smaller ranks are presented on top/left side while
    // with *reversed* `legend.traceorder` they are on bottom/right side. The default legendrank is 1000, so that you
    // can use ranks less than 1000 to place certain items before all unranked items, and ranks greater than 1000 to go
    // after all unranked items. When having unranked or equal rank items shapes would be displayed after traces i.e.
    // according to their order in data and layout.
    Layout::Shapes::Shape& legendrank(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Shapes::Shape& legendrank(Callable&& c);

    // Sets the width (in px or fraction) of the legend for this shape.
    Layout::Shapes::Shape& legendwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Shapes::Shape& legendwidth(Callable&& c);

    Layout::Shapes::Shape& line(Line f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Line&>>>
    Layout::Shapes::Shape& line(Callable&& c);

    // When used in a template, named items are created in the output figure in addition to any items the figure already
    // has in this array. You can modify these items in the output figure by making your own item with
    // `templateitemname` matching this `name` alongside your modifications (including `visible: false` or `enabled:
    // false` to hide it). Has no effect outside of a template.
    Layout::Shapes::Shape& name(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Shapes::Shape& name(Callable&& c);

    // Sets the opacity of the shape.
    Layout::Shapes::Shape& opacity(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Shapes::Shape& opacity(Callable&& c);

    // For `type` *path* - a valid SVG path with the pixel values replaced by data values in `xsizemode`/`ysizemode`
    // being *scaled* and taken unmodified as pixels relative to `xanchor` and `yanchor` in case of *pixel* size mode.
    // There are a few restrictions / quirks only absolute instructions, not relative. So the allowed segments are: M,
    // L, H, V, Q, C, T, S, and Z arcs (A) are not allowed because radius rx and ry are relative. In the future we could
    // consider supporting relative commands, but we would have to decide on how to handle date and log axes. Note that
    // even as is, Q and C Bezier paths that are smooth on linear axes may not be smooth on log, and vice versa. no
    // chained "polybezier" commands - specify the segment type for each one. On category axes, values are numbers
    // scaled to the serial numbers of categories because using the categories themselves there would be no way to
    // describe fractional positions On data axes: because space and T are both normal components of path strings, we
    // can't use either to separate date from time parts. Therefore we'll use underscore for this purpose:
    // 2015-02-21_13:45:56.789
    Layout::Shapes::Shape& path(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Shapes::Shape& path(Callable&& c);

    // Determines whether or not this shape is shown in the legend.
    Layout::Shapes::Shape& showlegend(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Shapes::Shape& showlegend(Callable&& c);

    // Used to refer to a named item in this array in the template. Named items from the template will be created even
    // without a matching item in the input figure, but you can modify one by making an item with `templateitemname`
    // matching its `name`, alongside your modifications (including `visible: false` or `enabled: false` to hide it). If
    // there is no template or no matching item, this item will be hidden unless you explicitly show it with `visible:
    // true`.
    Layout::Shapes::Shape& templateitemname(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Shapes::Shape& templateitemname(Callable&& c);

    // Specifies the shape type to be drawn. If *line*, a line is drawn from (`x0`,`y0`) to (`x1`,`y1`) with respect to
    // the axes' sizing mode. If *circle*, a circle is drawn from ((`x0`+`x1`)/2, (`y0`+`y1`)/2)) with radius
    // (|(`x0`+`x1`)/2 - `x0`|, |(`y0`+`y1`)/2 -`y0`)|) with respect to the axes' sizing mode. If *rect*, a rectangle is
    // drawn linking (`x0`,`y0`), (`x1`,`y0`), (`x1`,`y1`), (`x0`,`y1`), (`x0`,`y0`) with respect to the axes' sizing
    // mode. If *path*, draw a custom SVG path using `path`. with respect to the axes' sizing mode.
    Layout::Shapes::Shape& type(enum Type f);

    // Determines whether or not this shape is visible. If *legendonly*, the shape is not drawn, but can appear as a
    // legend item (provided that the legend itself is visible).
    // - Default: True
    Layout::Shapes::Shape& visible(enum Visible f);

    // Sets the shape's starting x position. See `type` and `xsizemode` for more info.
    template <typename T>
    Layout::Shapes::Shape& x0(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Shapes::Shape& x0(Callable&& c);

    // Shifts `x0` away from the center of the category when `xref` is a *category* or *multicategory* axis. -0.5
    // corresponds to the start of the category and 0.5 corresponds to the end of the category.
    Layout::Shapes::Shape& x0shift(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Shapes::Shape& x0shift(Callable&& c);

    // Sets the shape's end x position. See `type` and `xsizemode` for more info.
    template <typename T>
    Layout::Shapes::Shape& x1(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Shapes::Shape& x1(Callable&& c);

    // Shifts `x1` away from the center of the category when `xref` is a *category* or *multicategory* axis. -0.5
    // corresponds to the start of the category and 0.5 corresponds to the end of the category.
    Layout::Shapes::Shape& x1shift(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Shapes::Shape& x1shift(Callable&& c);

    // Only relevant in conjunction with `xsizemode` set to *pixel*. Specifies the anchor point on the x axis to which
    // `x0`, `x1` and x coordinates within `path` are relative to. E.g. useful to attach a pixel sized shape to a
    // certain data value. No effect when `xsizemode` not set to *pixel*.
    template <typename T>
    Layout::Shapes::Shape& xanchor(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Shapes::Shape& xanchor(Callable&& c);

    // Sets the shape's x coordinate axis. If set to a x axis id (e.g. *x* or *x2*), the `x` position refers to a x
    // coordinate. If set to *paper*, the `x` position refers to the distance from the left of the plotting area in
    // normalized coordinates where *0* (*1*) corresponds to the left (right). If set to a x axis ID followed by
    // *domain* (separated by a space), the position behaves like for *paper*, but refers to the distance in fractions
    // of the domain length from the left of the domain of that axis: e.g., *x2 domain* refers to the domain of the
    // second x  axis and a x position of 0.5 refers to the point between the left and the right of the domain of the
    // second x axis.
    Layout::Shapes::Shape& xref(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Shapes::Shape& xref(Callable&& c);

    // Sets the shapes's sizing mode along the x axis. If set to *scaled*, `x0`, `x1` and x coordinates within `path`
    // refer to data values on the x axis or a fraction of the plot area's width (`xref` set to *paper*). If set to
    // *pixel*, `xanchor` specifies the x position in terms of data or plot fraction but `x0`, `x1` and x coordinates
    // within `path` are pixels relative to `xanchor`. This way, the shape can have a fixed width while maintaining a
    // position relative to data or plot fraction.
    // - Default: scaled
    Layout::Shapes::Shape& xsizemode(enum Xsizemode f);

    // Sets the shape's starting y position. See `type` and `ysizemode` for more info.
    template <typename T>
    Layout::Shapes::Shape& y0(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Shapes::Shape& y0(Callable&& c);

    // Shifts `y0` away from the center of the category when `yref` is a *category* or *multicategory* axis. -0.5
    // corresponds to the start of the category and 0.5 corresponds to the end of the category.
    Layout::Shapes::Shape& y0shift(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Shapes::Shape& y0shift(Callable&& c);

    // Sets the shape's end y position. See `type` and `ysizemode` for more info.
    template <typename T>
    Layout::Shapes::Shape& y1(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Shapes::Shape& y1(Callable&& c);

    // Shifts `y1` away from the center of the category when `yref` is a *category* or *multicategory* axis. -0.5
    // corresponds to the start of the category and 0.5 corresponds to the end of the category.
    Layout::Shapes::Shape& y1shift(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Shapes::Shape& y1shift(Callable&& c);

    // Only relevant in conjunction with `ysizemode` set to *pixel*. Specifies the anchor point on the y axis to which
    // `y0`, `y1` and y coordinates within `path` are relative to. E.g. useful to attach a pixel sized shape to a
    // certain data value. No effect when `ysizemode` not set to *pixel*.
    template <typename T>
    Layout::Shapes::Shape& yanchor(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Shapes::Shape& yanchor(Callable&& c);

    // Sets the shape's y coordinate axis. If set to a y axis id (e.g. *y* or *y2*), the `y` position refers to a y
    // coordinate. If set to *paper*, the `y` position refers to the distance from the bottom of the plotting area in
    // normalized coordinates where *0* (*1*) corresponds to the bottom (top). If set to a y axis ID followed by
    // *domain* (separated by a space), the position behaves like for *paper*, but refers to the distance in fractions
    // of the domain length from the bottom of the domain of that axis: e.g., *y2 domain* refers to the domain of the
    // second y  axis and a y position of 0.5 refers to the point between the bottom and the top of the domain of the
    // second y axis.
    Layout::Shapes::Shape& yref(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Shapes::Shape& yref(Callable&& c);

    // Sets the shapes's sizing mode along the y axis. If set to *scaled*, `y0`, `y1` and y coordinates within `path`
    // refer to data values on the y axis or a fraction of the plot area's height (`yref` set to *paper*). If set to
    // *pixel*, `yanchor` specifies the y position in terms of data or plot fraction but `y0`, `y1` and y coordinates
    // within `path` are pixels relative to `yanchor`. This way, the shape can have a fixed height while maintaining a
    // position relative to data or plot fraction.
    // - Default: scaled
    Layout::Shapes::Shape& ysizemode(enum Ysizemode f);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Shapes::Shape::Label {
 public:
    Label() = default;
    Label(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Textposition {
        TopLeft,
        TopCenter,
        TopRight,
        MiddleLeft,
        MiddleCenter,
        MiddleRight,
        BottomLeft,
        BottomCenter,
        BottomRight,
        Start,
        Middle,
        End,
    };
    static std::string to_string(Textposition e);

    enum class Xanchor {
        Auto,
        Left,
        Center,
        Right,
    };
    static std::string to_string(Xanchor e);

    enum class Yanchor {
        Top,
        Middle,
        Bottom,
    };
    static std::string to_string(Yanchor e);

    // Sets the shape label text font.
    class Font;

    // Sets the shape label text font.
    Layout::Shapes::Shape::Label& font(Font f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Font&>>>
    Layout::Shapes::Shape::Label& font(Callable&& c);

    // Sets padding (in px) between edge of label and edge of shape.
    Layout::Shapes::Shape::Label& padding(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Shapes::Shape::Label& padding(Callable&& c);

    // Sets the text to display with shape. It is also used for legend item if `name` is not provided.
    Layout::Shapes::Shape::Label& text(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Shapes::Shape::Label& text(Callable&& c);

    // Sets the angle at which the label text is drawn with respect to the horizontal. For lines, angle *auto* is the
    // same angle as the line. For all other shapes, angle *auto* is horizontal.
    Layout::Shapes::Shape::Label& textangle(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Shapes::Shape::Label& textangle(Callable&& c);

    // Sets the position of the label text relative to the shape. Supported values for rectangles, circles and paths are
    // *top left*, *top center*, *top right*, *middle left*, *middle center*, *middle right*, *bottom left*, *bottom
    // center*, and *bottom right*. Supported values for lines are *start*, *middle*, and *end*. Default: *middle
    // center* for rectangles, circles, and paths; *middle* for lines.
    Layout::Shapes::Shape::Label& textposition(enum Textposition f);

    // Template string used for rendering the shape's label. Note that this will override `text`. Variables are inserted
    // using %{variable}, for example "x0: %{x0}". Numbers are formatted using d3-format's syntax %{variable:d3-format},
    // for example "Price: %{x0:$.2f}". See https://github.com/d3/d3-format/tree/v1.4.5#d3-format for details on the
    // formatting syntax. Dates are formatted using d3-time-format's syntax %{variable|d3-time-format}, for example
    // "Day: %{x0|%m %b %Y}". See https://github.com/d3/d3-time-format/tree/v2.2.3#locale_format for details on the date
    // formatting syntax. A single multiplication or division operation may be applied to numeric variables, and
    // combined with d3 number formatting, for example "Length in cm: %{x0*2.54}", "%{slope*60:.1f} meters per second."
    // For log axes, variable values are given in log units. For date axes, x/y coordinate variables and center
    // variables use datetimes, while all other variable values use values in ms. Finally, the template string has
    // access to variables `x0`, `x1`, `y0`, `y1`, `slope`, `dx`, `dy`, `width`, `height`, `length`, `xcenter` and
    // `ycenter`.
    Layout::Shapes::Shape::Label& texttemplate(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Shapes::Shape::Label& texttemplate(Callable&& c);

    // Sets the label's horizontal position anchor This anchor binds the specified `textposition` to the *left*,
    // *center* or *right* of the label text. For example, if `textposition` is set to *top right* and `xanchor` to
    // *right* then the right-most portion of the label text lines up with the right-most edge of the shape.
    // - Default: auto
    Layout::Shapes::Shape::Label& xanchor(enum Xanchor f);

    // Sets the label's vertical position anchor This anchor binds the specified `textposition` to the *top*, *middle*
    // or *bottom* of the label text. For example, if `textposition` is set to *top right* and `yanchor` to *top* then
    // the top-most portion of the label text lines up with the top-most edge of the shape.
    Layout::Shapes::Shape::Label& yanchor(enum Yanchor f);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets the shape label text font.
class Layout::Shapes::Shape::Label::Font {
 public:
    Font() = default;
    Font(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    enum class Textcase {
        Normal,
        WordCaps,
        Upper,
        Lower,
    };
    static std::string to_string(Textcase e);

    enum class Variant {
        Normal,
        SmallCaps,
        AllSmallCaps,
        AllPetiteCaps,
        PetiteCaps,
        Unicase,
    };
    static std::string to_string(Variant e);

    Layout::Shapes::Shape::Label::Font& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Shapes::Shape::Label::Font& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Shapes::Shape::Label::Font& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Shapes::Shape::Label::Font& family(Callable&& c);

    // Sets the kind of decoration line(s) with text, such as an *under*, *over* or *through* as well as combinations
    // e.g. *under+over*, etc.
    // - Default: none
    // - Flags: ['under', 'over', 'through']
    // - Extras ['none']
    Layout::Shapes::Shape::Label::Font& lineposition(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Shapes::Shape::Label::Font& lineposition(Callable&& c);

    // Sets the shape and color of the shadow behind text. *auto* places minimal shadow and applies contrast text font
    // color. See https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow for additional options.
    Layout::Shapes::Shape::Label::Font& shadow(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Shapes::Shape::Label::Font& shadow(Callable&& c);

    Layout::Shapes::Shape::Label::Font& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Shapes::Shape::Label::Font& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Shapes::Shape::Label::Font& style(enum Style f);

    // Sets capitalization of text. It can be used to make text appear in all-uppercase or all-lowercase, or with each
    // word capitalized.
    // - Default: normal
    Layout::Shapes::Shape::Label::Font& textcase(enum Textcase f);

    // Sets the variant of the font.
    // - Default: normal
    Layout::Shapes::Shape::Label::Font& variant(enum Variant f);

    // Sets the weight (or boldness) of the font.
    Layout::Shapes::Shape::Label::Font& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Shapes::Shape::Label::Font& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Shapes::Shape::Legendgrouptitle {
 public:
    Legendgrouptitle() = default;
    Legendgrouptitle(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Sets this legend group's title font.
    class Font;

    // Sets this legend group's title font.
    Layout::Shapes::Shape::Legendgrouptitle& font(Font f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Font&>>>
    Layout::Shapes::Shape::Legendgrouptitle& font(Callable&& c);

    // Sets the title of the legend group.
    Layout::Shapes::Shape::Legendgrouptitle& text(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Shapes::Shape::Legendgrouptitle& text(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets this legend group's title font.
class Layout::Shapes::Shape::Legendgrouptitle::Font {
 public:
    Font() = default;
    Font(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    enum class Textcase {
        Normal,
        WordCaps,
        Upper,
        Lower,
    };
    static std::string to_string(Textcase e);

    enum class Variant {
        Normal,
        SmallCaps,
        AllSmallCaps,
        AllPetiteCaps,
        PetiteCaps,
        Unicase,
    };
    static std::string to_string(Variant e);

    Layout::Shapes::Shape::Legendgrouptitle::Font& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Shapes::Shape::Legendgrouptitle::Font& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Shapes::Shape::Legendgrouptitle::Font& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Shapes::Shape::Legendgrouptitle::Font& family(Callable&& c);

    // Sets the kind of decoration line(s) with text, such as an *under*, *over* or *through* as well as combinations
    // e.g. *under+over*, etc.
    // - Default: none
    // - Flags: ['under', 'over', 'through']
    // - Extras ['none']
    Layout::Shapes::Shape::Legendgrouptitle::Font& lineposition(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Shapes::Shape::Legendgrouptitle::Font& lineposition(Callable&& c);

    // Sets the shape and color of the shadow behind text. *auto* places minimal shadow and applies contrast text font
    // color. See https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow for additional options.
    Layout::Shapes::Shape::Legendgrouptitle::Font& shadow(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Shapes::Shape::Legendgrouptitle::Font& shadow(Callable&& c);

    Layout::Shapes::Shape::Legendgrouptitle::Font& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Shapes::Shape::Legendgrouptitle::Font& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Shapes::Shape::Legendgrouptitle::Font& style(enum Style f);

    // Sets capitalization of text. It can be used to make text appear in all-uppercase or all-lowercase, or with each
    // word capitalized.
    // - Default: normal
    Layout::Shapes::Shape::Legendgrouptitle::Font& textcase(enum Textcase f);

    // Sets the variant of the font.
    // - Default: normal
    Layout::Shapes::Shape::Legendgrouptitle::Font& variant(enum Variant f);

    // Sets the weight (or boldness) of the font.
    Layout::Shapes::Shape::Legendgrouptitle::Font& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Shapes::Shape::Legendgrouptitle::Font& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Shapes::Shape::Line {
 public:
    Line() = default;
    Line(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Sets the line color.
    Layout::Shapes::Shape::Line& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Shapes::Shape::Line& color(Callable&& c);

    // Sets the dash style of lines. Set to a dash type string (*solid*, *dot*, *dash*, *longdash*, *dashdot*, or
    // *longdashdot*) or a dash length list in px (eg *5px,10px,2px,2px*).
    Layout::Shapes::Shape::Line& dash(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Shapes::Shape::Line& dash(Callable&& c);

    // Sets the line width (in px).
    Layout::Shapes::Shape::Line& width(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Shapes::Shape::Line& width(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Sliders {
 public:
    Sliders() = default;
    Sliders(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    class Slider;

    Layout::Sliders& slider(Slider f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Slider&>>>
    Layout::Sliders& slider(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Sliders::Slider {
 public:
    Slider() = default;
    Slider(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Lenmode {
        Fraction,
        Pixels,
    };
    static std::string to_string(Lenmode e);

    enum class Xanchor {
        Auto,
        Left,
        Center,
        Right,
    };
    static std::string to_string(Xanchor e);

    enum class Yanchor {
        Auto,
        Top,
        Middle,
        Bottom,
    };
    static std::string to_string(Yanchor e);

    class Currentvalue;
    // Sets the font of the slider step labels.
    class Font;
    // Set the padding of the slider component along each side.
    class Pad;
    class Steps;
    class Transition;

    // Determines which button (by index starting from 0) is considered active.
    Layout::Sliders::Slider& active(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Sliders::Slider& active(Callable&& c);

    // Sets the background color of the slider grip while dragging.
    Layout::Sliders::Slider& activebgcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Sliders::Slider& activebgcolor(Callable&& c);

    // Sets the background color of the slider.
    Layout::Sliders::Slider& bgcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Sliders::Slider& bgcolor(Callable&& c);

    // Sets the color of the border enclosing the slider.
    Layout::Sliders::Slider& bordercolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Sliders::Slider& bordercolor(Callable&& c);

    // Sets the width (in px) of the border enclosing the slider.
    Layout::Sliders::Slider& borderwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Sliders::Slider& borderwidth(Callable&& c);

    Layout::Sliders::Slider& currentvalue(Currentvalue f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Currentvalue&>>>
    Layout::Sliders::Slider& currentvalue(Callable&& c);

    // Sets the font of the slider step labels.
    Layout::Sliders::Slider& font(Font f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Font&>>>
    Layout::Sliders::Slider& font(Callable&& c);

    // Sets the length of the slider This measure excludes the padding of both ends. That is, the slider's length is
    // this length minus the padding on both ends.
    Layout::Sliders::Slider& len(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Sliders::Slider& len(Callable&& c);

    // Determines whether this slider length is set in units of plot *fraction* or in *pixels. Use `len` to set the
    // value.
    // - Default: fraction
    Layout::Sliders::Slider& lenmode(enum Lenmode f);

    // Sets the length in pixels of minor step tick marks
    Layout::Sliders::Slider& minorticklen(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Sliders::Slider& minorticklen(Callable&& c);

    // When used in a template, named items are created in the output figure in addition to any items the figure already
    // has in this array. You can modify these items in the output figure by making your own item with
    // `templateitemname` matching this `name` alongside your modifications (including `visible: false` or `enabled:
    // false` to hide it). Has no effect outside of a template.
    Layout::Sliders::Slider& name(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Sliders::Slider& name(Callable&& c);

    // Set the padding of the slider component along each side.
    Layout::Sliders::Slider& pad(Pad f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Pad&>>>
    Layout::Sliders::Slider& pad(Callable&& c);

    Layout::Sliders::Slider& steps(Steps f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Steps&>>>
    Layout::Sliders::Slider& steps(Callable&& c);

    // Used to refer to a named item in this array in the template. Named items from the template will be created even
    // without a matching item in the input figure, but you can modify one by making an item with `templateitemname`
    // matching its `name`, alongside your modifications (including `visible: false` or `enabled: false` to hide it). If
    // there is no template or no matching item, this item will be hidden unless you explicitly show it with `visible:
    // true`.
    Layout::Sliders::Slider& templateitemname(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Sliders::Slider& templateitemname(Callable&& c);

    // Sets the color of the border enclosing the slider.
    Layout::Sliders::Slider& tickcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Sliders::Slider& tickcolor(Callable&& c);

    // Sets the length in pixels of step tick marks
    Layout::Sliders::Slider& ticklen(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Sliders::Slider& ticklen(Callable&& c);

    // Sets the tick width (in px).
    Layout::Sliders::Slider& tickwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Sliders::Slider& tickwidth(Callable&& c);

    Layout::Sliders::Slider& transition(Transition f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Transition&>>>
    Layout::Sliders::Slider& transition(Callable&& c);

    // Determines whether or not the slider is visible.
    Layout::Sliders::Slider& visible(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Sliders::Slider& visible(Callable&& c);

    // Sets the x position (in normalized coordinates) of the slider.
    Layout::Sliders::Slider& x(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Sliders::Slider& x(Callable&& c);

    // Sets the slider's horizontal position anchor. This anchor binds the `x` position to the *left*, *center* or
    // *right* of the range selector.
    // - Default: left
    Layout::Sliders::Slider& xanchor(enum Xanchor f);

    // Sets the y position (in normalized coordinates) of the slider.
    Layout::Sliders::Slider& y(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Sliders::Slider& y(Callable&& c);

    // Sets the slider's vertical position anchor This anchor binds the `y` position to the *top*, *middle* or *bottom*
    // of the range selector.
    // - Default: top
    Layout::Sliders::Slider& yanchor(enum Yanchor f);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Sliders::Slider::Currentvalue {
 public:
    Currentvalue() = default;
    Currentvalue(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Xanchor {
        Left,
        Center,
        Right,
    };
    static std::string to_string(Xanchor e);

    // Sets the font of the current value label text.
    class Font;

    // Sets the font of the current value label text.
    Layout::Sliders::Slider::Currentvalue& font(Font f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Font&>>>
    Layout::Sliders::Slider::Currentvalue& font(Callable&& c);

    // The amount of space, in pixels, between the current value label and the slider.
    Layout::Sliders::Slider::Currentvalue& offset(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Sliders::Slider::Currentvalue& offset(Callable&& c);

    // When currentvalue.visible is true, this sets the prefix of the label.
    Layout::Sliders::Slider::Currentvalue& prefix(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Sliders::Slider::Currentvalue& prefix(Callable&& c);

    // When currentvalue.visible is true, this sets the suffix of the label.
    Layout::Sliders::Slider::Currentvalue& suffix(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Sliders::Slider::Currentvalue& suffix(Callable&& c);

    // Shows the currently-selected value above the slider.
    Layout::Sliders::Slider::Currentvalue& visible(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Sliders::Slider::Currentvalue& visible(Callable&& c);

    // The alignment of the value readout relative to the length of the slider.
    // - Default: left
    Layout::Sliders::Slider::Currentvalue& xanchor(enum Xanchor f);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets the font of the current value label text.
class Layout::Sliders::Slider::Currentvalue::Font {
 public:
    Font() = default;
    Font(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    enum class Textcase {
        Normal,
        WordCaps,
        Upper,
        Lower,
    };
    static std::string to_string(Textcase e);

    enum class Variant {
        Normal,
        SmallCaps,
        AllSmallCaps,
        AllPetiteCaps,
        PetiteCaps,
        Unicase,
    };
    static std::string to_string(Variant e);

    Layout::Sliders::Slider::Currentvalue::Font& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Sliders::Slider::Currentvalue::Font& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Sliders::Slider::Currentvalue::Font& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Sliders::Slider::Currentvalue::Font& family(Callable&& c);

    // Sets the kind of decoration line(s) with text, such as an *under*, *over* or *through* as well as combinations
    // e.g. *under+over*, etc.
    // - Default: none
    // - Flags: ['under', 'over', 'through']
    // - Extras ['none']
    Layout::Sliders::Slider::Currentvalue::Font& lineposition(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Sliders::Slider::Currentvalue::Font& lineposition(Callable&& c);

    // Sets the shape and color of the shadow behind text. *auto* places minimal shadow and applies contrast text font
    // color. See https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow for additional options.
    Layout::Sliders::Slider::Currentvalue::Font& shadow(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Sliders::Slider::Currentvalue::Font& shadow(Callable&& c);

    Layout::Sliders::Slider::Currentvalue::Font& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Sliders::Slider::Currentvalue::Font& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Sliders::Slider::Currentvalue::Font& style(enum Style f);

    // Sets capitalization of text. It can be used to make text appear in all-uppercase or all-lowercase, or with each
    // word capitalized.
    // - Default: normal
    Layout::Sliders::Slider::Currentvalue::Font& textcase(enum Textcase f);

    // Sets the variant of the font.
    // - Default: normal
    Layout::Sliders::Slider::Currentvalue::Font& variant(enum Variant f);

    // Sets the weight (or boldness) of the font.
    Layout::Sliders::Slider::Currentvalue::Font& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Sliders::Slider::Currentvalue::Font& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets the font of the slider step labels.
class Layout::Sliders::Slider::Font {
 public:
    Font() = default;
    Font(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    enum class Textcase {
        Normal,
        WordCaps,
        Upper,
        Lower,
    };
    static std::string to_string(Textcase e);

    enum class Variant {
        Normal,
        SmallCaps,
        AllSmallCaps,
        AllPetiteCaps,
        PetiteCaps,
        Unicase,
    };
    static std::string to_string(Variant e);

    Layout::Sliders::Slider::Font& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Sliders::Slider::Font& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Sliders::Slider::Font& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Sliders::Slider::Font& family(Callable&& c);

    // Sets the kind of decoration line(s) with text, such as an *under*, *over* or *through* as well as combinations
    // e.g. *under+over*, etc.
    // - Default: none
    // - Flags: ['under', 'over', 'through']
    // - Extras ['none']
    Layout::Sliders::Slider::Font& lineposition(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Sliders::Slider::Font& lineposition(Callable&& c);

    // Sets the shape and color of the shadow behind text. *auto* places minimal shadow and applies contrast text font
    // color. See https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow for additional options.
    Layout::Sliders::Slider::Font& shadow(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Sliders::Slider::Font& shadow(Callable&& c);

    Layout::Sliders::Slider::Font& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Sliders::Slider::Font& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Sliders::Slider::Font& style(enum Style f);

    // Sets capitalization of text. It can be used to make text appear in all-uppercase or all-lowercase, or with each
    // word capitalized.
    // - Default: normal
    Layout::Sliders::Slider::Font& textcase(enum Textcase f);

    // Sets the variant of the font.
    // - Default: normal
    Layout::Sliders::Slider::Font& variant(enum Variant f);

    // Sets the weight (or boldness) of the font.
    Layout::Sliders::Slider::Font& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Sliders::Slider::Font& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Set the padding of the slider component along each side.
class Layout::Sliders::Slider::Pad {
 public:
    Pad() = default;
    Pad(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // The amount of padding (in px) along the bottom of the component.
    Layout::Sliders::Slider::Pad& b(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Sliders::Slider::Pad& b(Callable&& c);

    // The amount of padding (in px) on the left side of the component.
    Layout::Sliders::Slider::Pad& l(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Sliders::Slider::Pad& l(Callable&& c);

    // The amount of padding (in px) on the right side of the component.
    Layout::Sliders::Slider::Pad& r(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Sliders::Slider::Pad& r(Callable&& c);

    // The amount of padding (in px) along the top of the component.
    Layout::Sliders::Slider::Pad& t(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Sliders::Slider::Pad& t(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Sliders::Slider::Steps {
 public:
    Steps() = default;
    Steps(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    class Step;

    Layout::Sliders::Slider::Steps& step(Step f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Step&>>>
    Layout::Sliders::Slider::Steps& step(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Sliders::Slider::Steps::Step {
 public:
    Step() = default;
    Step(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Method {
        Restyle,
        Relayout,
        Animate,
        Update,
        Skip,
    };
    static std::string to_string(Method e);

    // Sets the arguments values to be passed to the Plotly method set in `method` on slide.
    Layout::Sliders::Slider::Steps::Step& args(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Sliders::Slider::Steps::Step& args(Callable&& c);

    // When true, the API method is executed. When false, all other behaviors are the same and command execution is
    // skipped. This may be useful when hooking into, for example, the `plotly_sliderchange` method and executing the
    // API command manually without losing the benefit of the slider automatically binding to the state of the plot
    // through the specification of `method` and `args`.
    Layout::Sliders::Slider::Steps::Step& execute(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Sliders::Slider::Steps::Step& execute(Callable&& c);

    // Sets the text label to appear on the slider
    Layout::Sliders::Slider::Steps::Step& label(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Sliders::Slider::Steps::Step& label(Callable&& c);

    // Sets the Plotly method to be called when the slider value is changed. If the `skip` method is used, the API
    // slider will function as normal but will perform no API calls and will not bind automatically to state updates.
    // This may be used to create a component interface and attach to slider events manually via JavaScript.
    // - Default: restyle
    Layout::Sliders::Slider::Steps::Step& method(enum Method f);

    // When used in a template, named items are created in the output figure in addition to any items the figure already
    // has in this array. You can modify these items in the output figure by making your own item with
    // `templateitemname` matching this `name` alongside your modifications (including `visible: false` or `enabled:
    // false` to hide it). Has no effect outside of a template.
    Layout::Sliders::Slider::Steps::Step& name(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Sliders::Slider::Steps::Step& name(Callable&& c);

    // Used to refer to a named item in this array in the template. Named items from the template will be created even
    // without a matching item in the input figure, but you can modify one by making an item with `templateitemname`
    // matching its `name`, alongside your modifications (including `visible: false` or `enabled: false` to hide it). If
    // there is no template or no matching item, this item will be hidden unless you explicitly show it with `visible:
    // true`.
    Layout::Sliders::Slider::Steps::Step& templateitemname(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Sliders::Slider::Steps::Step& templateitemname(Callable&& c);

    // Sets the value of the slider step, used to refer to the step programatically. Defaults to the slider label if not
    // provided.
    Layout::Sliders::Slider::Steps::Step& value(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Sliders::Slider::Steps::Step& value(Callable&& c);

    // Determines whether or not this step is included in the slider.
    Layout::Sliders::Slider::Steps::Step& visible(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Sliders::Slider::Steps::Step& visible(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Sliders::Slider::Transition {
 public:
    Transition() = default;
    Transition(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Easing {
        Linear,
        Quad,
        Cubic,
        Sin,
        Exp,
        Circle,
        Elastic,
        Back,
        Bounce,
        LinearIn,
        QuadIn,
        CubicIn,
        SinIn,
        ExpIn,
        CircleIn,
        ElasticIn,
        BackIn,
        BounceIn,
        LinearOut,
        QuadOut,
        CubicOut,
        SinOut,
        ExpOut,
        CircleOut,
        ElasticOut,
        BackOut,
        BounceOut,
        LinearInOut,
        QuadInOut,
        CubicInOut,
        SinInOut,
        ExpInOut,
        CircleInOut,
        ElasticInOut,
        BackInOut,
        BounceInOut,
    };
    static std::string to_string(Easing e);

    // Sets the duration of the slider transition
    Layout::Sliders::Slider::Transition& duration(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Sliders::Slider::Transition& duration(Callable&& c);

    // Sets the easing function of the slider transition
    // - Default: cubic-in-out
    Layout::Sliders::Slider::Transition& easing(enum Easing f);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Smith {
 public:
    Smith() = default;
    Smith(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    class Domain;
    class Imaginaryaxis;
    class Realaxis;

    // Set the background color of the subplot
    Layout::Smith& bgcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Smith& bgcolor(Callable&& c);

    Layout::Smith& domain(Domain f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Domain&>>>
    Layout::Smith& domain(Callable&& c);

    Layout::Smith& imaginaryaxis(Imaginaryaxis f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Imaginaryaxis&>>>
    Layout::Smith& imaginaryaxis(Callable&& c);

    Layout::Smith& realaxis(Realaxis f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Realaxis&>>>
    Layout::Smith& realaxis(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Smith::Domain {
 public:
    Domain() = default;
    Domain(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // If there is a layout grid, use the domain for this column in the grid for this smith subplot .
    Layout::Smith::Domain& column(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Smith::Domain& column(Callable&& c);

    // If there is a layout grid, use the domain for this row in the grid for this smith subplot .
    Layout::Smith::Domain& row(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Smith::Domain& row(Callable&& c);

    // Sets the horizontal domain of this smith subplot (in plot fraction).
    Layout::Smith::Domain& x(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Smith::Domain& x(Callable&& c);

    // Sets the vertical domain of this smith subplot (in plot fraction).
    Layout::Smith::Domain& y(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Smith::Domain& y(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Smith::Imaginaryaxis {
 public:
    Imaginaryaxis() = default;
    Imaginaryaxis(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Layer {
        AboveTraces,
        BelowTraces,
    };
    static std::string to_string(Layer e);

    enum class Showtickprefix {
        All,
        First,
        Last,
        None,
    };
    static std::string to_string(Showtickprefix e);

    enum class Showticksuffix {
        All,
        First,
        Last,
        None,
    };
    static std::string to_string(Showticksuffix e);

    enum class Ticks {
        Outside,
        Inside,
        Empty,
    };
    static std::string to_string(Ticks e);

    // Sets the tick font.
    class Tickfont;

    // Sets default for all colors associated with this axis all at once: line, font, tick, and grid colors. Grid color
    // is lightened by blending this with the plot background Individual pieces can override this.
    Layout::Smith::Imaginaryaxis& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Smith::Imaginaryaxis& color(Callable&& c);

    // Sets the color of the grid lines.
    Layout::Smith::Imaginaryaxis& gridcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Smith::Imaginaryaxis& gridcolor(Callable&& c);

    // Sets the dash style of lines. Set to a dash type string (*solid*, *dot*, *dash*, *longdash*, *dashdot*, or
    // *longdashdot*) or a dash length list in px (eg *5px,10px,2px,2px*).
    Layout::Smith::Imaginaryaxis& griddash(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Smith::Imaginaryaxis& griddash(Callable&& c);

    // Sets the width (in px) of the grid lines.
    Layout::Smith::Imaginaryaxis& gridwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Smith::Imaginaryaxis& gridwidth(Callable&& c);

    // Sets the hover text formatting rule using d3 formatting mini-languages which are very similar to those in Python.
    // For numbers, see: https://github.com/d3/d3-format/tree/v1.4.5#d3-format. And for dates see:
    // https://github.com/d3/d3-time-format/tree/v2.2.3#locale_format. We add two items to d3's date formatter: *%h* for
    // half of the year as a decimal number as well as *%{n}f* for fractional seconds with n digits. For example,
    // *2016-10-13 09:15:23.456* with tickformat *%H~%M~%S.%2f* would display *09~15~23.46*
    Layout::Smith::Imaginaryaxis& hoverformat(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Smith::Imaginaryaxis& hoverformat(Callable&& c);

    // Replacement text for specific tick or hover labels. For example using {US: 'USA', CA: 'Canada'} changes US to USA
    // and CA to Canada. The labels we would have shown must match the keys exactly, after adding any tickprefix or
    // ticksuffix. For negative numbers the minus sign symbol used (U+2212) is wider than the regular ascii dash. That
    // means you need to use 1 instead of -1. labelalias can be used with any axis type, and both keys (if needed) and
    // values (if desired) can include html-like tags or MathJax.
    template <typename T>
    Layout::Smith::Imaginaryaxis& labelalias(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Smith::Imaginaryaxis& labelalias(Callable&& c);

    // Sets the layer on which this axis is displayed. If *above traces*, this axis is displayed above all the subplot's
    // traces If *below traces*, this axis is displayed below all the subplot's traces, but above the grid lines. Useful
    // when used together with scatter-like traces with `cliponaxis` set to *false* to show markers and/or text nodes
    // above this axis.
    // - Default: above traces
    Layout::Smith::Imaginaryaxis& layer(enum Layer f);

    // Sets the axis line color.
    Layout::Smith::Imaginaryaxis& linecolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Smith::Imaginaryaxis& linecolor(Callable&& c);

    // Sets the width (in px) of the axis line.
    Layout::Smith::Imaginaryaxis& linewidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Smith::Imaginaryaxis& linewidth(Callable&& c);

    // Determines whether or not grid lines are drawn. If *true*, the grid lines are drawn at every tick mark.
    Layout::Smith::Imaginaryaxis& showgrid(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Smith::Imaginaryaxis& showgrid(Callable&& c);

    // Determines whether or not a line bounding this axis is drawn.
    Layout::Smith::Imaginaryaxis& showline(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Smith::Imaginaryaxis& showline(Callable&& c);

    // Determines whether or not the tick labels are drawn.
    Layout::Smith::Imaginaryaxis& showticklabels(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Smith::Imaginaryaxis& showticklabels(Callable&& c);

    // If *all*, all tick labels are displayed with a prefix. If *first*, only the first tick is displayed with a
    // prefix. If *last*, only the last tick is displayed with a suffix. If *none*, tick prefixes are hidden.
    // - Default: all
    Layout::Smith::Imaginaryaxis& showtickprefix(enum Showtickprefix f);

    // Same as `showtickprefix` but for tick suffixes.
    // - Default: all
    Layout::Smith::Imaginaryaxis& showticksuffix(enum Showticksuffix f);

    // Sets the tick color.
    Layout::Smith::Imaginaryaxis& tickcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Smith::Imaginaryaxis& tickcolor(Callable&& c);

    // Sets the tick font.
    Layout::Smith::Imaginaryaxis& tickfont(Tickfont f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Tickfont&>>>
    Layout::Smith::Imaginaryaxis& tickfont(Callable&& c);

    // Sets the tick label formatting rule using d3 formatting mini-languages which are very similar to those in Python.
    // For numbers, see: https://github.com/d3/d3-format/tree/v1.4.5#d3-format. And for dates see:
    // https://github.com/d3/d3-time-format/tree/v2.2.3#locale_format. We add two items to d3's date formatter: *%h* for
    // half of the year as a decimal number as well as *%{n}f* for fractional seconds with n digits. For example,
    // *2016-10-13 09:15:23.456* with tickformat *%H~%M~%S.%2f* would display *09~15~23.46*
    Layout::Smith::Imaginaryaxis& tickformat(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Smith::Imaginaryaxis& tickformat(Callable&& c);

    // Sets the tick length (in px).
    Layout::Smith::Imaginaryaxis& ticklen(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Smith::Imaginaryaxis& ticklen(Callable&& c);

    // Sets a tick label prefix.
    Layout::Smith::Imaginaryaxis& tickprefix(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Smith::Imaginaryaxis& tickprefix(Callable&& c);

    // Determines whether ticks are drawn or not. If **, this axis' ticks are not drawn. If *outside* (*inside*), this
    // axis' are drawn outside (inside) the axis lines.
    Layout::Smith::Imaginaryaxis& ticks(enum Ticks f);

    // Sets a tick label suffix.
    Layout::Smith::Imaginaryaxis& ticksuffix(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Smith::Imaginaryaxis& ticksuffix(Callable&& c);

    // Sets the values at which ticks on this axis appear. Defaults to `realaxis.tickvals` plus the same as negatives
    // and zero.
    template <typename T, typename = std::enable_if_t<is_data_array_element_v<T>>>
    Layout::Smith::Imaginaryaxis& tickvals(const std::vector<T>& f);
    template <
        typename T, typename Callable,
        typename = std::enable_if_t<is_data_array_element_v<T> && (std::is_invocable_v<Callable, std::vector<T>&>)>>
    Layout::Smith::Imaginaryaxis& tickvals(Callable&& c);

    // Sets the source reference on Chart Studio Cloud for `tickvals`.
    Layout::Smith::Imaginaryaxis& tickvalssrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Smith::Imaginaryaxis& tickvalssrc(Callable&& c);

    // Sets the tick width (in px).
    Layout::Smith::Imaginaryaxis& tickwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Smith::Imaginaryaxis& tickwidth(Callable&& c);

    // A single toggle to hide the axis while preserving interaction like dragging. Default is true when a cheater plot
    // is present on the axis, otherwise false
    Layout::Smith::Imaginaryaxis& visible(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Smith::Imaginaryaxis& visible(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets the tick font.
class Layout::Smith::Imaginaryaxis::Tickfont {
 public:
    Tickfont() = default;
    Tickfont(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    enum class Textcase {
        Normal,
        WordCaps,
        Upper,
        Lower,
    };
    static std::string to_string(Textcase e);

    enum class Variant {
        Normal,
        SmallCaps,
        AllSmallCaps,
        AllPetiteCaps,
        PetiteCaps,
        Unicase,
    };
    static std::string to_string(Variant e);

    Layout::Smith::Imaginaryaxis::Tickfont& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Smith::Imaginaryaxis::Tickfont& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Smith::Imaginaryaxis::Tickfont& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Smith::Imaginaryaxis::Tickfont& family(Callable&& c);

    // Sets the kind of decoration line(s) with text, such as an *under*, *over* or *through* as well as combinations
    // e.g. *under+over*, etc.
    // - Default: none
    // - Flags: ['under', 'over', 'through']
    // - Extras ['none']
    Layout::Smith::Imaginaryaxis::Tickfont& lineposition(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Smith::Imaginaryaxis::Tickfont& lineposition(Callable&& c);

    // Sets the shape and color of the shadow behind text. *auto* places minimal shadow and applies contrast text font
    // color. See https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow for additional options.
    Layout::Smith::Imaginaryaxis::Tickfont& shadow(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Smith::Imaginaryaxis::Tickfont& shadow(Callable&& c);

    Layout::Smith::Imaginaryaxis::Tickfont& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Smith::Imaginaryaxis::Tickfont& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Smith::Imaginaryaxis::Tickfont& style(enum Style f);

    // Sets capitalization of text. It can be used to make text appear in all-uppercase or all-lowercase, or with each
    // word capitalized.
    // - Default: normal
    Layout::Smith::Imaginaryaxis::Tickfont& textcase(enum Textcase f);

    // Sets the variant of the font.
    // - Default: normal
    Layout::Smith::Imaginaryaxis::Tickfont& variant(enum Variant f);

    // Sets the weight (or boldness) of the font.
    Layout::Smith::Imaginaryaxis::Tickfont& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Smith::Imaginaryaxis::Tickfont& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Smith::Realaxis {
 public:
    Realaxis() = default;
    Realaxis(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Layer {
        AboveTraces,
        BelowTraces,
    };
    static std::string to_string(Layer e);

    enum class Showtickprefix {
        All,
        First,
        Last,
        None,
    };
    static std::string to_string(Showtickprefix e);

    enum class Showticksuffix {
        All,
        First,
        Last,
        None,
    };
    static std::string to_string(Showticksuffix e);

    enum class Side {
        Top,
        Bottom,
    };
    static std::string to_string(Side e);

    enum class Ticks {
        Top,
        Bottom,
        Empty,
    };
    static std::string to_string(Ticks e);

    // Sets the tick font.
    class Tickfont;

    // Sets default for all colors associated with this axis all at once: line, font, tick, and grid colors. Grid color
    // is lightened by blending this with the plot background Individual pieces can override this.
    Layout::Smith::Realaxis& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Smith::Realaxis& color(Callable&& c);

    // Sets the color of the grid lines.
    Layout::Smith::Realaxis& gridcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Smith::Realaxis& gridcolor(Callable&& c);

    // Sets the dash style of lines. Set to a dash type string (*solid*, *dot*, *dash*, *longdash*, *dashdot*, or
    // *longdashdot*) or a dash length list in px (eg *5px,10px,2px,2px*).
    Layout::Smith::Realaxis& griddash(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Smith::Realaxis& griddash(Callable&& c);

    // Sets the width (in px) of the grid lines.
    Layout::Smith::Realaxis& gridwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Smith::Realaxis& gridwidth(Callable&& c);

    // Sets the hover text formatting rule using d3 formatting mini-languages which are very similar to those in Python.
    // For numbers, see: https://github.com/d3/d3-format/tree/v1.4.5#d3-format. And for dates see:
    // https://github.com/d3/d3-time-format/tree/v2.2.3#locale_format. We add two items to d3's date formatter: *%h* for
    // half of the year as a decimal number as well as *%{n}f* for fractional seconds with n digits. For example,
    // *2016-10-13 09:15:23.456* with tickformat *%H~%M~%S.%2f* would display *09~15~23.46*
    Layout::Smith::Realaxis& hoverformat(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Smith::Realaxis& hoverformat(Callable&& c);

    // Replacement text for specific tick or hover labels. For example using {US: 'USA', CA: 'Canada'} changes US to USA
    // and CA to Canada. The labels we would have shown must match the keys exactly, after adding any tickprefix or
    // ticksuffix. For negative numbers the minus sign symbol used (U+2212) is wider than the regular ascii dash. That
    // means you need to use 1 instead of -1. labelalias can be used with any axis type, and both keys (if needed) and
    // values (if desired) can include html-like tags or MathJax.
    template <typename T>
    Layout::Smith::Realaxis& labelalias(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Smith::Realaxis& labelalias(Callable&& c);

    // Sets the layer on which this axis is displayed. If *above traces*, this axis is displayed above all the subplot's
    // traces If *below traces*, this axis is displayed below all the subplot's traces, but above the grid lines. Useful
    // when used together with scatter-like traces with `cliponaxis` set to *false* to show markers and/or text nodes
    // above this axis.
    // - Default: above traces
    Layout::Smith::Realaxis& layer(enum Layer f);

    // Sets the axis line color.
    Layout::Smith::Realaxis& linecolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Smith::Realaxis& linecolor(Callable&& c);

    // Sets the width (in px) of the axis line.
    Layout::Smith::Realaxis& linewidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Smith::Realaxis& linewidth(Callable&& c);

    // Determines whether or not grid lines are drawn. If *true*, the grid lines are drawn at every tick mark.
    Layout::Smith::Realaxis& showgrid(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Smith::Realaxis& showgrid(Callable&& c);

    // Determines whether or not a line bounding this axis is drawn.
    Layout::Smith::Realaxis& showline(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Smith::Realaxis& showline(Callable&& c);

    // Determines whether or not the tick labels are drawn.
    Layout::Smith::Realaxis& showticklabels(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Smith::Realaxis& showticklabels(Callable&& c);

    // If *all*, all tick labels are displayed with a prefix. If *first*, only the first tick is displayed with a
    // prefix. If *last*, only the last tick is displayed with a suffix. If *none*, tick prefixes are hidden.
    // - Default: all
    Layout::Smith::Realaxis& showtickprefix(enum Showtickprefix f);

    // Same as `showtickprefix` but for tick suffixes.
    // - Default: all
    Layout::Smith::Realaxis& showticksuffix(enum Showticksuffix f);

    // Determines on which side of real axis line the tick and tick labels appear.
    // - Default: top
    Layout::Smith::Realaxis& side(enum Side f);

    // Sets the angle of the tick labels with respect to the horizontal. For example, a `tickangle` of -90 draws the
    // tick labels vertically.
    Layout::Smith::Realaxis& tickangle(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Smith::Realaxis& tickangle(Callable&& c);

    // Sets the tick color.
    Layout::Smith::Realaxis& tickcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Smith::Realaxis& tickcolor(Callable&& c);

    // Sets the tick font.
    Layout::Smith::Realaxis& tickfont(Tickfont f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Tickfont&>>>
    Layout::Smith::Realaxis& tickfont(Callable&& c);

    // Sets the tick label formatting rule using d3 formatting mini-languages which are very similar to those in Python.
    // For numbers, see: https://github.com/d3/d3-format/tree/v1.4.5#d3-format. And for dates see:
    // https://github.com/d3/d3-time-format/tree/v2.2.3#locale_format. We add two items to d3's date formatter: *%h* for
    // half of the year as a decimal number as well as *%{n}f* for fractional seconds with n digits. For example,
    // *2016-10-13 09:15:23.456* with tickformat *%H~%M~%S.%2f* would display *09~15~23.46*
    Layout::Smith::Realaxis& tickformat(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Smith::Realaxis& tickformat(Callable&& c);

    // Sets the tick length (in px).
    Layout::Smith::Realaxis& ticklen(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Smith::Realaxis& ticklen(Callable&& c);

    // Sets a tick label prefix.
    Layout::Smith::Realaxis& tickprefix(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Smith::Realaxis& tickprefix(Callable&& c);

    // Determines whether ticks are drawn or not. If **, this axis' ticks are not drawn. If *top* (*bottom*), this axis'
    // are drawn above (below) the axis line.
    Layout::Smith::Realaxis& ticks(enum Ticks f);

    // Sets a tick label suffix.
    Layout::Smith::Realaxis& ticksuffix(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Smith::Realaxis& ticksuffix(Callable&& c);

    // Sets the values at which ticks on this axis appear.
    template <typename T, typename = std::enable_if_t<is_data_array_element_v<T>>>
    Layout::Smith::Realaxis& tickvals(const std::vector<T>& f);
    template <
        typename T, typename Callable,
        typename = std::enable_if_t<is_data_array_element_v<T> && (std::is_invocable_v<Callable, std::vector<T>&>)>>
    Layout::Smith::Realaxis& tickvals(Callable&& c);

    // Sets the source reference on Chart Studio Cloud for `tickvals`.
    Layout::Smith::Realaxis& tickvalssrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Smith::Realaxis& tickvalssrc(Callable&& c);

    // Sets the tick width (in px).
    Layout::Smith::Realaxis& tickwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Smith::Realaxis& tickwidth(Callable&& c);

    // A single toggle to hide the axis while preserving interaction like dragging. Default is true when a cheater plot
    // is present on the axis, otherwise false
    Layout::Smith::Realaxis& visible(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Smith::Realaxis& visible(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets the tick font.
class Layout::Smith::Realaxis::Tickfont {
 public:
    Tickfont() = default;
    Tickfont(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    enum class Textcase {
        Normal,
        WordCaps,
        Upper,
        Lower,
    };
    static std::string to_string(Textcase e);

    enum class Variant {
        Normal,
        SmallCaps,
        AllSmallCaps,
        AllPetiteCaps,
        PetiteCaps,
        Unicase,
    };
    static std::string to_string(Variant e);

    Layout::Smith::Realaxis::Tickfont& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Smith::Realaxis::Tickfont& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Smith::Realaxis::Tickfont& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Smith::Realaxis::Tickfont& family(Callable&& c);

    // Sets the kind of decoration line(s) with text, such as an *under*, *over* or *through* as well as combinations
    // e.g. *under+over*, etc.
    // - Default: none
    // - Flags: ['under', 'over', 'through']
    // - Extras ['none']
    Layout::Smith::Realaxis::Tickfont& lineposition(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Smith::Realaxis::Tickfont& lineposition(Callable&& c);

    // Sets the shape and color of the shadow behind text. *auto* places minimal shadow and applies contrast text font
    // color. See https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow for additional options.
    Layout::Smith::Realaxis::Tickfont& shadow(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Smith::Realaxis::Tickfont& shadow(Callable&& c);

    Layout::Smith::Realaxis::Tickfont& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Smith::Realaxis::Tickfont& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Smith::Realaxis::Tickfont& style(enum Style f);

    // Sets capitalization of text. It can be used to make text appear in all-uppercase or all-lowercase, or with each
    // word capitalized.
    // - Default: normal
    Layout::Smith::Realaxis::Tickfont& textcase(enum Textcase f);

    // Sets the variant of the font.
    // - Default: normal
    Layout::Smith::Realaxis::Tickfont& variant(enum Variant f);

    // Sets the weight (or boldness) of the font.
    Layout::Smith::Realaxis::Tickfont& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Smith::Realaxis::Tickfont& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Ternary {
 public:
    Ternary() = default;
    Ternary(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    class Aaxis;
    class Baxis;
    class Caxis;
    class Domain;

    Layout::Ternary& aaxis(Aaxis f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Aaxis&>>>
    Layout::Ternary& aaxis(Callable&& c);

    Layout::Ternary& baxis(Baxis f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Baxis&>>>
    Layout::Ternary& baxis(Callable&& c);

    // Set the background color of the subplot
    Layout::Ternary& bgcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary& bgcolor(Callable&& c);

    Layout::Ternary& caxis(Caxis f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Caxis&>>>
    Layout::Ternary& caxis(Callable&& c);

    Layout::Ternary& domain(Domain f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Domain&>>>
    Layout::Ternary& domain(Callable&& c);

    // The number each triplet should sum to, and the maximum range of each axis
    Layout::Ternary& sum(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Ternary& sum(Callable&& c);

    // Controls persistence of user-driven changes in axis `min` and `title`, if not overridden in the individual axes.
    // Defaults to `layout.uirevision`.
    template <typename T>
    Layout::Ternary& uirevision(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Ternary& uirevision(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Ternary::Aaxis {
 public:
    Aaxis() = default;
    Aaxis(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Exponentformat {
        None,
        E,
        Power,
        Si,
        B,
    };
    static std::string to_string(Exponentformat e);

    enum class Layer {
        AboveTraces,
        BelowTraces,
    };
    static std::string to_string(Layer e);

    enum class Showexponent {
        All,
        First,
        Last,
        None,
    };
    static std::string to_string(Showexponent e);

    enum class Showtickprefix {
        All,
        First,
        Last,
        None,
    };
    static std::string to_string(Showtickprefix e);

    enum class Showticksuffix {
        All,
        First,
        Last,
        None,
    };
    static std::string to_string(Showticksuffix e);

    enum class Tickmode {
        Auto,
        Linear,
        Array,
    };
    static std::string to_string(Tickmode e);

    enum class Ticks {
        Outside,
        Inside,
        Empty,
    };
    static std::string to_string(Ticks e);

    // Sets the tick font.
    class Tickfont;
    class Tickformatstops;
    class Title;

    // Sets default for all colors associated with this axis all at once: line, font, tick, and grid colors. Grid color
    // is lightened by blending this with the plot background Individual pieces can override this.
    Layout::Ternary::Aaxis& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Aaxis& color(Callable&& c);

    // Sets the step in-between ticks on this axis. Use with `tick0`. Must be a positive number, or special strings
    // available to *log* and *date* axes. If the axis `type` is *log*, then ticks are set every 10^(n*dtick) where n is
    // the tick number. For example, to set a tick mark at 1, 10, 100, 1000, ... set dtick to 1. To set tick marks at 1,
    // 100, 10000, ... set dtick to 2. To set tick marks at 1, 5, 25, 125, 625, 3125, ... set dtick to log_10(5), or
    // 0.69897000433. *log* has several special values; *L<f>*, where `f` is a positive number, gives ticks linearly
    // spaced in value (but not position). For example `tick0` = 0.1, `dtick` = *L0.5* will put ticks at 0.1,
    // 0.6, 1.1, 1.6 etc. To show powers of 10 plus small digits between, use *D1* (all digits) or *D2* (only 2 and 5).
    // `tick0` is ignored for *D1* and *D2*. If the axis `type` is *date*, then you must convert the time to
    // milliseconds. For example, to set the interval between ticks to one day, set `dtick` to 86400000.0. *date* also
    // has special values *M<n>* gives ticks spaced by a number of months. `n` must be a positive integer. To set ticks
    // on the 15th of every third month, set `tick0` to *2000-01-15* and `dtick` to *M3*. To set ticks every 4 years,
    // set `dtick` to *M48*
    template <typename T>
    Layout::Ternary::Aaxis& dtick(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Ternary::Aaxis& dtick(Callable&& c);

    // Determines a formatting rule for the tick exponents. For example, consider the number 1,000,000,000. If *none*,
    // it appears as 1,000,000,000. If *e*, 1e+9. If *E*, 1E+9. If *power*, 1x10^9 (with 9 in a super script). If *SI*,
    // 1G. If *B*, 1B.
    // - Default: B
    Layout::Ternary::Aaxis& exponentformat(enum Exponentformat f);

    // Sets the color of the grid lines.
    Layout::Ternary::Aaxis& gridcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Aaxis& gridcolor(Callable&& c);

    // Sets the dash style of lines. Set to a dash type string (*solid*, *dot*, *dash*, *longdash*, *dashdot*, or
    // *longdashdot*) or a dash length list in px (eg *5px,10px,2px,2px*).
    Layout::Ternary::Aaxis& griddash(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Aaxis& griddash(Callable&& c);

    // Sets the width (in px) of the grid lines.
    Layout::Ternary::Aaxis& gridwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Ternary::Aaxis& gridwidth(Callable&& c);

    // Sets the hover text formatting rule using d3 formatting mini-languages which are very similar to those in Python.
    // For numbers, see: https://github.com/d3/d3-format/tree/v1.4.5#d3-format. And for dates see:
    // https://github.com/d3/d3-time-format/tree/v2.2.3#locale_format. We add two items to d3's date formatter: *%h* for
    // half of the year as a decimal number as well as *%{n}f* for fractional seconds with n digits. For example,
    // *2016-10-13 09:15:23.456* with tickformat *%H~%M~%S.%2f* would display *09~15~23.46*
    Layout::Ternary::Aaxis& hoverformat(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Aaxis& hoverformat(Callable&& c);

    // Replacement text for specific tick or hover labels. For example using {US: 'USA', CA: 'Canada'} changes US to USA
    // and CA to Canada. The labels we would have shown must match the keys exactly, after adding any tickprefix or
    // ticksuffix. For negative numbers the minus sign symbol used (U+2212) is wider than the regular ascii dash. That
    // means you need to use 1 instead of -1. labelalias can be used with any axis type, and both keys (if needed) and
    // values (if desired) can include html-like tags or MathJax.
    template <typename T>
    Layout::Ternary::Aaxis& labelalias(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Ternary::Aaxis& labelalias(Callable&& c);

    // Sets the layer on which this axis is displayed. If *above traces*, this axis is displayed above all the subplot's
    // traces If *below traces*, this axis is displayed below all the subplot's traces, but above the grid lines. Useful
    // when used together with scatter-like traces with `cliponaxis` set to *false* to show markers and/or text nodes
    // above this axis.
    // - Default: above traces
    Layout::Ternary::Aaxis& layer(enum Layer f);

    // Sets the axis line color.
    Layout::Ternary::Aaxis& linecolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Aaxis& linecolor(Callable&& c);

    // Sets the width (in px) of the axis line.
    Layout::Ternary::Aaxis& linewidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Ternary::Aaxis& linewidth(Callable&& c);

    // The minimum value visible on this axis. The maximum is determined by the sum minus the minimum values of the
    // other two axes. The full view corresponds to all the minima set to zero.
    Layout::Ternary::Aaxis& min(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Ternary::Aaxis& min(Callable&& c);

    // Hide SI prefix for 10^n if |n| is below this number. This only has an effect when `tickformat` is *SI* or *B*.
    Layout::Ternary::Aaxis& minexponent(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Ternary::Aaxis& minexponent(Callable&& c);

    // Specifies the maximum number of ticks for the particular axis. The actual number of ticks will be chosen
    // automatically to be less than or equal to `nticks`. Has an effect only if `tickmode` is set to *auto*.
    Layout::Ternary::Aaxis& nticks(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Ternary::Aaxis& nticks(Callable&& c);

    // If "true", even 4-digit integers are separated
    Layout::Ternary::Aaxis& separatethousands(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Ternary::Aaxis& separatethousands(Callable&& c);

    // If *all*, all exponents are shown besides their significands. If *first*, only the exponent of the first tick is
    // shown. If *last*, only the exponent of the last tick is shown. If *none*, no exponents appear.
    // - Default: all
    Layout::Ternary::Aaxis& showexponent(enum Showexponent f);

    // Determines whether or not grid lines are drawn. If *true*, the grid lines are drawn at every tick mark.
    Layout::Ternary::Aaxis& showgrid(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Ternary::Aaxis& showgrid(Callable&& c);

    // Determines whether or not a line bounding this axis is drawn.
    Layout::Ternary::Aaxis& showline(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Ternary::Aaxis& showline(Callable&& c);

    // Determines whether or not the tick labels are drawn.
    Layout::Ternary::Aaxis& showticklabels(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Ternary::Aaxis& showticklabels(Callable&& c);

    // If *all*, all tick labels are displayed with a prefix. If *first*, only the first tick is displayed with a
    // prefix. If *last*, only the last tick is displayed with a suffix. If *none*, tick prefixes are hidden.
    // - Default: all
    Layout::Ternary::Aaxis& showtickprefix(enum Showtickprefix f);

    // Same as `showtickprefix` but for tick suffixes.
    // - Default: all
    Layout::Ternary::Aaxis& showticksuffix(enum Showticksuffix f);

    // Sets the placement of the first tick on this axis. Use with `dtick`. If the axis `type` is *log*, then you must
    // take the log of your starting tick (e.g. to set the starting tick to 100, set the `tick0` to 2) except when
    // `dtick`=*L<f>* (see `dtick` for more info). If the axis `type` is *date*, it should be a date string, like date
    // data. If the axis `type` is *category*, it should be a number, using the scale where each category is assigned a
    // serial number from zero in the order it appears.
    template <typename T>
    Layout::Ternary::Aaxis& tick0(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Ternary::Aaxis& tick0(Callable&& c);

    // Sets the angle of the tick labels with respect to the horizontal. For example, a `tickangle` of -90 draws the
    // tick labels vertically.
    Layout::Ternary::Aaxis& tickangle(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Ternary::Aaxis& tickangle(Callable&& c);

    // Sets the tick color.
    Layout::Ternary::Aaxis& tickcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Aaxis& tickcolor(Callable&& c);

    // Sets the tick font.
    Layout::Ternary::Aaxis& tickfont(Tickfont f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Tickfont&>>>
    Layout::Ternary::Aaxis& tickfont(Callable&& c);

    // Sets the tick label formatting rule using d3 formatting mini-languages which are very similar to those in Python.
    // For numbers, see: https://github.com/d3/d3-format/tree/v1.4.5#d3-format. And for dates see:
    // https://github.com/d3/d3-time-format/tree/v2.2.3#locale_format. We add two items to d3's date formatter: *%h* for
    // half of the year as a decimal number as well as *%{n}f* for fractional seconds with n digits. For example,
    // *2016-10-13 09:15:23.456* with tickformat *%H~%M~%S.%2f* would display *09~15~23.46*
    Layout::Ternary::Aaxis& tickformat(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Aaxis& tickformat(Callable&& c);

    Layout::Ternary::Aaxis& tickformatstops(Tickformatstops f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Tickformatstops&>>>
    Layout::Ternary::Aaxis& tickformatstops(Callable&& c);

    // Sets the spacing between tick labels as compared to the spacing between ticks. A value of 1 (default) means each
    // tick gets a label. A value of 2 means shows every 2nd label. A larger value n means only every nth tick is
    // labeled. `tick0` determines which labels are shown. Not implemented for axes with `type` *log* or
    // *multicategory*, or when `tickmode` is *array*.
    Layout::Ternary::Aaxis& ticklabelstep(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Ternary::Aaxis& ticklabelstep(Callable&& c);

    // Sets the tick length (in px).
    Layout::Ternary::Aaxis& ticklen(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Ternary::Aaxis& ticklen(Callable&& c);

    // Sets the tick mode for this axis. If *auto*, the number of ticks is set via `nticks`. If *linear*, the placement
    // of the ticks is determined by a starting position `tick0` and a tick step `dtick` (*linear* is the default value
    // if `tick0` and `dtick` are provided). If *array*, the placement of the ticks is set via `tickvals` and the tick
    // text is `ticktext`. (*array* is the default value if `tickvals` is provided).
    Layout::Ternary::Aaxis& tickmode(enum Tickmode f);

    // Sets a tick label prefix.
    Layout::Ternary::Aaxis& tickprefix(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Aaxis& tickprefix(Callable&& c);

    // Determines whether ticks are drawn or not. If **, this axis' ticks are not drawn. If *outside* (*inside*), this
    // axis' are drawn outside (inside) the axis lines.
    Layout::Ternary::Aaxis& ticks(enum Ticks f);

    // Sets a tick label suffix.
    Layout::Ternary::Aaxis& ticksuffix(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Aaxis& ticksuffix(Callable&& c);

    // Sets the text displayed at the ticks position via `tickvals`. Only has an effect if `tickmode` is set to *array*.
    // Used with `tickvals`.
    template <typename T, typename = std::enable_if_t<is_data_array_element_v<T>>>
    Layout::Ternary::Aaxis& ticktext(const std::vector<T>& f);
    template <
        typename T, typename Callable,
        typename = std::enable_if_t<is_data_array_element_v<T> && (std::is_invocable_v<Callable, std::vector<T>&>)>>
    Layout::Ternary::Aaxis& ticktext(Callable&& c);

    // Sets the source reference on Chart Studio Cloud for `ticktext`.
    Layout::Ternary::Aaxis& ticktextsrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Aaxis& ticktextsrc(Callable&& c);

    // Sets the values at which ticks on this axis appear. Only has an effect if `tickmode` is set to *array*. Used with
    // `ticktext`.
    template <typename T, typename = std::enable_if_t<is_data_array_element_v<T>>>
    Layout::Ternary::Aaxis& tickvals(const std::vector<T>& f);
    template <
        typename T, typename Callable,
        typename = std::enable_if_t<is_data_array_element_v<T> && (std::is_invocable_v<Callable, std::vector<T>&>)>>
    Layout::Ternary::Aaxis& tickvals(Callable&& c);

    // Sets the source reference on Chart Studio Cloud for `tickvals`.
    Layout::Ternary::Aaxis& tickvalssrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Aaxis& tickvalssrc(Callable&& c);

    // Sets the tick width (in px).
    Layout::Ternary::Aaxis& tickwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Ternary::Aaxis& tickwidth(Callable&& c);

    Layout::Ternary::Aaxis& title(Title f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Title&>>>
    Layout::Ternary::Aaxis& title(Callable&& c);

    // Controls persistence of user-driven changes in axis `min`, and `title` if in `editable: true` configuration.
    // Defaults to `ternary<N>.uirevision`.
    template <typename T>
    Layout::Ternary::Aaxis& uirevision(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Ternary::Aaxis& uirevision(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets the tick font.
class Layout::Ternary::Aaxis::Tickfont {
 public:
    Tickfont() = default;
    Tickfont(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    enum class Textcase {
        Normal,
        WordCaps,
        Upper,
        Lower,
    };
    static std::string to_string(Textcase e);

    enum class Variant {
        Normal,
        SmallCaps,
        AllSmallCaps,
        AllPetiteCaps,
        PetiteCaps,
        Unicase,
    };
    static std::string to_string(Variant e);

    Layout::Ternary::Aaxis::Tickfont& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Aaxis::Tickfont& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Ternary::Aaxis::Tickfont& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Aaxis::Tickfont& family(Callable&& c);

    // Sets the kind of decoration line(s) with text, such as an *under*, *over* or *through* as well as combinations
    // e.g. *under+over*, etc.
    // - Default: none
    // - Flags: ['under', 'over', 'through']
    // - Extras ['none']
    Layout::Ternary::Aaxis::Tickfont& lineposition(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Aaxis::Tickfont& lineposition(Callable&& c);

    // Sets the shape and color of the shadow behind text. *auto* places minimal shadow and applies contrast text font
    // color. See https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow for additional options.
    Layout::Ternary::Aaxis::Tickfont& shadow(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Aaxis::Tickfont& shadow(Callable&& c);

    Layout::Ternary::Aaxis::Tickfont& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Ternary::Aaxis::Tickfont& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Ternary::Aaxis::Tickfont& style(enum Style f);

    // Sets capitalization of text. It can be used to make text appear in all-uppercase or all-lowercase, or with each
    // word capitalized.
    // - Default: normal
    Layout::Ternary::Aaxis::Tickfont& textcase(enum Textcase f);

    // Sets the variant of the font.
    // - Default: normal
    Layout::Ternary::Aaxis::Tickfont& variant(enum Variant f);

    // Sets the weight (or boldness) of the font.
    Layout::Ternary::Aaxis::Tickfont& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Ternary::Aaxis::Tickfont& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Ternary::Aaxis::Tickformatstops {
 public:
    Tickformatstops() = default;
    Tickformatstops(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    class Tickformatstop;

    Layout::Ternary::Aaxis::Tickformatstops& tickformatstop(Tickformatstop f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Tickformatstop&>>>
    Layout::Ternary::Aaxis::Tickformatstops& tickformatstop(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Ternary::Aaxis::Tickformatstops::Tickformatstop {
 public:
    Tickformatstop() = default;
    Tickformatstop(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // range [*min*, *max*], where *min*, *max* - dtick values which describe some zoom level, it is possible to omit
    // *min* or *max* value by passing *null*
    Layout::Ternary::Aaxis::Tickformatstops::Tickformatstop& dtickrange(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Ternary::Aaxis::Tickformatstops::Tickformatstop& dtickrange(Callable&& c);

    // Determines whether or not this stop is used. If `false`, this stop is ignored even within its `dtickrange`.
    Layout::Ternary::Aaxis::Tickformatstops::Tickformatstop& enabled(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Ternary::Aaxis::Tickformatstops::Tickformatstop& enabled(Callable&& c);

    // When used in a template, named items are created in the output figure in addition to any items the figure already
    // has in this array. You can modify these items in the output figure by making your own item with
    // `templateitemname` matching this `name` alongside your modifications (including `visible: false` or `enabled:
    // false` to hide it). Has no effect outside of a template.
    Layout::Ternary::Aaxis::Tickformatstops::Tickformatstop& name(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Aaxis::Tickformatstops::Tickformatstop& name(Callable&& c);

    // Used to refer to a named item in this array in the template. Named items from the template will be created even
    // without a matching item in the input figure, but you can modify one by making an item with `templateitemname`
    // matching its `name`, alongside your modifications (including `visible: false` or `enabled: false` to hide it). If
    // there is no template or no matching item, this item will be hidden unless you explicitly show it with `visible:
    // true`.
    Layout::Ternary::Aaxis::Tickformatstops::Tickformatstop& templateitemname(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Aaxis::Tickformatstops::Tickformatstop& templateitemname(Callable&& c);

    // string - dtickformat for described zoom level, the same as *tickformat*
    Layout::Ternary::Aaxis::Tickformatstops::Tickformatstop& value(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Aaxis::Tickformatstops::Tickformatstop& value(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Ternary::Aaxis::Title {
 public:
    Title() = default;
    Title(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Sets this axis' title font.
    class Font;

    // Sets this axis' title font.
    Layout::Ternary::Aaxis::Title& font(Font f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Font&>>>
    Layout::Ternary::Aaxis::Title& font(Callable&& c);

    // Sets the title of this axis.
    Layout::Ternary::Aaxis::Title& text(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Aaxis::Title& text(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets this axis' title font.
class Layout::Ternary::Aaxis::Title::Font {
 public:
    Font() = default;
    Font(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    enum class Textcase {
        Normal,
        WordCaps,
        Upper,
        Lower,
    };
    static std::string to_string(Textcase e);

    enum class Variant {
        Normal,
        SmallCaps,
        AllSmallCaps,
        AllPetiteCaps,
        PetiteCaps,
        Unicase,
    };
    static std::string to_string(Variant e);

    Layout::Ternary::Aaxis::Title::Font& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Aaxis::Title::Font& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Ternary::Aaxis::Title::Font& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Aaxis::Title::Font& family(Callable&& c);

    // Sets the kind of decoration line(s) with text, such as an *under*, *over* or *through* as well as combinations
    // e.g. *under+over*, etc.
    // - Default: none
    // - Flags: ['under', 'over', 'through']
    // - Extras ['none']
    Layout::Ternary::Aaxis::Title::Font& lineposition(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Aaxis::Title::Font& lineposition(Callable&& c);

    // Sets the shape and color of the shadow behind text. *auto* places minimal shadow and applies contrast text font
    // color. See https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow for additional options.
    Layout::Ternary::Aaxis::Title::Font& shadow(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Aaxis::Title::Font& shadow(Callable&& c);

    Layout::Ternary::Aaxis::Title::Font& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Ternary::Aaxis::Title::Font& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Ternary::Aaxis::Title::Font& style(enum Style f);

    // Sets capitalization of text. It can be used to make text appear in all-uppercase or all-lowercase, or with each
    // word capitalized.
    // - Default: normal
    Layout::Ternary::Aaxis::Title::Font& textcase(enum Textcase f);

    // Sets the variant of the font.
    // - Default: normal
    Layout::Ternary::Aaxis::Title::Font& variant(enum Variant f);

    // Sets the weight (or boldness) of the font.
    Layout::Ternary::Aaxis::Title::Font& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Ternary::Aaxis::Title::Font& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Ternary::Baxis {
 public:
    Baxis() = default;
    Baxis(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Exponentformat {
        None,
        E,
        Power,
        Si,
        B,
    };
    static std::string to_string(Exponentformat e);

    enum class Layer {
        AboveTraces,
        BelowTraces,
    };
    static std::string to_string(Layer e);

    enum class Showexponent {
        All,
        First,
        Last,
        None,
    };
    static std::string to_string(Showexponent e);

    enum class Showtickprefix {
        All,
        First,
        Last,
        None,
    };
    static std::string to_string(Showtickprefix e);

    enum class Showticksuffix {
        All,
        First,
        Last,
        None,
    };
    static std::string to_string(Showticksuffix e);

    enum class Tickmode {
        Auto,
        Linear,
        Array,
    };
    static std::string to_string(Tickmode e);

    enum class Ticks {
        Outside,
        Inside,
        Empty,
    };
    static std::string to_string(Ticks e);

    // Sets the tick font.
    class Tickfont;
    class Tickformatstops;
    class Title;

    // Sets default for all colors associated with this axis all at once: line, font, tick, and grid colors. Grid color
    // is lightened by blending this with the plot background Individual pieces can override this.
    Layout::Ternary::Baxis& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Baxis& color(Callable&& c);

    // Sets the step in-between ticks on this axis. Use with `tick0`. Must be a positive number, or special strings
    // available to *log* and *date* axes. If the axis `type` is *log*, then ticks are set every 10^(n*dtick) where n is
    // the tick number. For example, to set a tick mark at 1, 10, 100, 1000, ... set dtick to 1. To set tick marks at 1,
    // 100, 10000, ... set dtick to 2. To set tick marks at 1, 5, 25, 125, 625, 3125, ... set dtick to log_10(5), or
    // 0.69897000433. *log* has several special values; *L<f>*, where `f` is a positive number, gives ticks linearly
    // spaced in value (but not position). For example `tick0` = 0.1, `dtick` = *L0.5* will put ticks at 0.1,
    // 0.6, 1.1, 1.6 etc. To show powers of 10 plus small digits between, use *D1* (all digits) or *D2* (only 2 and 5).
    // `tick0` is ignored for *D1* and *D2*. If the axis `type` is *date*, then you must convert the time to
    // milliseconds. For example, to set the interval between ticks to one day, set `dtick` to 86400000.0. *date* also
    // has special values *M<n>* gives ticks spaced by a number of months. `n` must be a positive integer. To set ticks
    // on the 15th of every third month, set `tick0` to *2000-01-15* and `dtick` to *M3*. To set ticks every 4 years,
    // set `dtick` to *M48*
    template <typename T>
    Layout::Ternary::Baxis& dtick(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Ternary::Baxis& dtick(Callable&& c);

    // Determines a formatting rule for the tick exponents. For example, consider the number 1,000,000,000. If *none*,
    // it appears as 1,000,000,000. If *e*, 1e+9. If *E*, 1E+9. If *power*, 1x10^9 (with 9 in a super script). If *SI*,
    // 1G. If *B*, 1B.
    // - Default: B
    Layout::Ternary::Baxis& exponentformat(enum Exponentformat f);

    // Sets the color of the grid lines.
    Layout::Ternary::Baxis& gridcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Baxis& gridcolor(Callable&& c);

    // Sets the dash style of lines. Set to a dash type string (*solid*, *dot*, *dash*, *longdash*, *dashdot*, or
    // *longdashdot*) or a dash length list in px (eg *5px,10px,2px,2px*).
    Layout::Ternary::Baxis& griddash(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Baxis& griddash(Callable&& c);

    // Sets the width (in px) of the grid lines.
    Layout::Ternary::Baxis& gridwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Ternary::Baxis& gridwidth(Callable&& c);

    // Sets the hover text formatting rule using d3 formatting mini-languages which are very similar to those in Python.
    // For numbers, see: https://github.com/d3/d3-format/tree/v1.4.5#d3-format. And for dates see:
    // https://github.com/d3/d3-time-format/tree/v2.2.3#locale_format. We add two items to d3's date formatter: *%h* for
    // half of the year as a decimal number as well as *%{n}f* for fractional seconds with n digits. For example,
    // *2016-10-13 09:15:23.456* with tickformat *%H~%M~%S.%2f* would display *09~15~23.46*
    Layout::Ternary::Baxis& hoverformat(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Baxis& hoverformat(Callable&& c);

    // Replacement text for specific tick or hover labels. For example using {US: 'USA', CA: 'Canada'} changes US to USA
    // and CA to Canada. The labels we would have shown must match the keys exactly, after adding any tickprefix or
    // ticksuffix. For negative numbers the minus sign symbol used (U+2212) is wider than the regular ascii dash. That
    // means you need to use 1 instead of -1. labelalias can be used with any axis type, and both keys (if needed) and
    // values (if desired) can include html-like tags or MathJax.
    template <typename T>
    Layout::Ternary::Baxis& labelalias(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Ternary::Baxis& labelalias(Callable&& c);

    // Sets the layer on which this axis is displayed. If *above traces*, this axis is displayed above all the subplot's
    // traces If *below traces*, this axis is displayed below all the subplot's traces, but above the grid lines. Useful
    // when used together with scatter-like traces with `cliponaxis` set to *false* to show markers and/or text nodes
    // above this axis.
    // - Default: above traces
    Layout::Ternary::Baxis& layer(enum Layer f);

    // Sets the axis line color.
    Layout::Ternary::Baxis& linecolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Baxis& linecolor(Callable&& c);

    // Sets the width (in px) of the axis line.
    Layout::Ternary::Baxis& linewidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Ternary::Baxis& linewidth(Callable&& c);

    // The minimum value visible on this axis. The maximum is determined by the sum minus the minimum values of the
    // other two axes. The full view corresponds to all the minima set to zero.
    Layout::Ternary::Baxis& min(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Ternary::Baxis& min(Callable&& c);

    // Hide SI prefix for 10^n if |n| is below this number. This only has an effect when `tickformat` is *SI* or *B*.
    Layout::Ternary::Baxis& minexponent(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Ternary::Baxis& minexponent(Callable&& c);

    // Specifies the maximum number of ticks for the particular axis. The actual number of ticks will be chosen
    // automatically to be less than or equal to `nticks`. Has an effect only if `tickmode` is set to *auto*.
    Layout::Ternary::Baxis& nticks(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Ternary::Baxis& nticks(Callable&& c);

    // If "true", even 4-digit integers are separated
    Layout::Ternary::Baxis& separatethousands(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Ternary::Baxis& separatethousands(Callable&& c);

    // If *all*, all exponents are shown besides their significands. If *first*, only the exponent of the first tick is
    // shown. If *last*, only the exponent of the last tick is shown. If *none*, no exponents appear.
    // - Default: all
    Layout::Ternary::Baxis& showexponent(enum Showexponent f);

    // Determines whether or not grid lines are drawn. If *true*, the grid lines are drawn at every tick mark.
    Layout::Ternary::Baxis& showgrid(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Ternary::Baxis& showgrid(Callable&& c);

    // Determines whether or not a line bounding this axis is drawn.
    Layout::Ternary::Baxis& showline(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Ternary::Baxis& showline(Callable&& c);

    // Determines whether or not the tick labels are drawn.
    Layout::Ternary::Baxis& showticklabels(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Ternary::Baxis& showticklabels(Callable&& c);

    // If *all*, all tick labels are displayed with a prefix. If *first*, only the first tick is displayed with a
    // prefix. If *last*, only the last tick is displayed with a suffix. If *none*, tick prefixes are hidden.
    // - Default: all
    Layout::Ternary::Baxis& showtickprefix(enum Showtickprefix f);

    // Same as `showtickprefix` but for tick suffixes.
    // - Default: all
    Layout::Ternary::Baxis& showticksuffix(enum Showticksuffix f);

    // Sets the placement of the first tick on this axis. Use with `dtick`. If the axis `type` is *log*, then you must
    // take the log of your starting tick (e.g. to set the starting tick to 100, set the `tick0` to 2) except when
    // `dtick`=*L<f>* (see `dtick` for more info). If the axis `type` is *date*, it should be a date string, like date
    // data. If the axis `type` is *category*, it should be a number, using the scale where each category is assigned a
    // serial number from zero in the order it appears.
    template <typename T>
    Layout::Ternary::Baxis& tick0(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Ternary::Baxis& tick0(Callable&& c);

    // Sets the angle of the tick labels with respect to the horizontal. For example, a `tickangle` of -90 draws the
    // tick labels vertically.
    Layout::Ternary::Baxis& tickangle(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Ternary::Baxis& tickangle(Callable&& c);

    // Sets the tick color.
    Layout::Ternary::Baxis& tickcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Baxis& tickcolor(Callable&& c);

    // Sets the tick font.
    Layout::Ternary::Baxis& tickfont(Tickfont f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Tickfont&>>>
    Layout::Ternary::Baxis& tickfont(Callable&& c);

    // Sets the tick label formatting rule using d3 formatting mini-languages which are very similar to those in Python.
    // For numbers, see: https://github.com/d3/d3-format/tree/v1.4.5#d3-format. And for dates see:
    // https://github.com/d3/d3-time-format/tree/v2.2.3#locale_format. We add two items to d3's date formatter: *%h* for
    // half of the year as a decimal number as well as *%{n}f* for fractional seconds with n digits. For example,
    // *2016-10-13 09:15:23.456* with tickformat *%H~%M~%S.%2f* would display *09~15~23.46*
    Layout::Ternary::Baxis& tickformat(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Baxis& tickformat(Callable&& c);

    Layout::Ternary::Baxis& tickformatstops(Tickformatstops f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Tickformatstops&>>>
    Layout::Ternary::Baxis& tickformatstops(Callable&& c);

    // Sets the spacing between tick labels as compared to the spacing between ticks. A value of 1 (default) means each
    // tick gets a label. A value of 2 means shows every 2nd label. A larger value n means only every nth tick is
    // labeled. `tick0` determines which labels are shown. Not implemented for axes with `type` *log* or
    // *multicategory*, or when `tickmode` is *array*.
    Layout::Ternary::Baxis& ticklabelstep(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Ternary::Baxis& ticklabelstep(Callable&& c);

    // Sets the tick length (in px).
    Layout::Ternary::Baxis& ticklen(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Ternary::Baxis& ticklen(Callable&& c);

    // Sets the tick mode for this axis. If *auto*, the number of ticks is set via `nticks`. If *linear*, the placement
    // of the ticks is determined by a starting position `tick0` and a tick step `dtick` (*linear* is the default value
    // if `tick0` and `dtick` are provided). If *array*, the placement of the ticks is set via `tickvals` and the tick
    // text is `ticktext`. (*array* is the default value if `tickvals` is provided).
    Layout::Ternary::Baxis& tickmode(enum Tickmode f);

    // Sets a tick label prefix.
    Layout::Ternary::Baxis& tickprefix(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Baxis& tickprefix(Callable&& c);

    // Determines whether ticks are drawn or not. If **, this axis' ticks are not drawn. If *outside* (*inside*), this
    // axis' are drawn outside (inside) the axis lines.
    Layout::Ternary::Baxis& ticks(enum Ticks f);

    // Sets a tick label suffix.
    Layout::Ternary::Baxis& ticksuffix(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Baxis& ticksuffix(Callable&& c);

    // Sets the text displayed at the ticks position via `tickvals`. Only has an effect if `tickmode` is set to *array*.
    // Used with `tickvals`.
    template <typename T, typename = std::enable_if_t<is_data_array_element_v<T>>>
    Layout::Ternary::Baxis& ticktext(const std::vector<T>& f);
    template <
        typename T, typename Callable,
        typename = std::enable_if_t<is_data_array_element_v<T> && (std::is_invocable_v<Callable, std::vector<T>&>)>>
    Layout::Ternary::Baxis& ticktext(Callable&& c);

    // Sets the source reference on Chart Studio Cloud for `ticktext`.
    Layout::Ternary::Baxis& ticktextsrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Baxis& ticktextsrc(Callable&& c);

    // Sets the values at which ticks on this axis appear. Only has an effect if `tickmode` is set to *array*. Used with
    // `ticktext`.
    template <typename T, typename = std::enable_if_t<is_data_array_element_v<T>>>
    Layout::Ternary::Baxis& tickvals(const std::vector<T>& f);
    template <
        typename T, typename Callable,
        typename = std::enable_if_t<is_data_array_element_v<T> && (std::is_invocable_v<Callable, std::vector<T>&>)>>
    Layout::Ternary::Baxis& tickvals(Callable&& c);

    // Sets the source reference on Chart Studio Cloud for `tickvals`.
    Layout::Ternary::Baxis& tickvalssrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Baxis& tickvalssrc(Callable&& c);

    // Sets the tick width (in px).
    Layout::Ternary::Baxis& tickwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Ternary::Baxis& tickwidth(Callable&& c);

    Layout::Ternary::Baxis& title(Title f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Title&>>>
    Layout::Ternary::Baxis& title(Callable&& c);

    // Controls persistence of user-driven changes in axis `min`, and `title` if in `editable: true` configuration.
    // Defaults to `ternary<N>.uirevision`.
    template <typename T>
    Layout::Ternary::Baxis& uirevision(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Ternary::Baxis& uirevision(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets the tick font.
class Layout::Ternary::Baxis::Tickfont {
 public:
    Tickfont() = default;
    Tickfont(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    enum class Textcase {
        Normal,
        WordCaps,
        Upper,
        Lower,
    };
    static std::string to_string(Textcase e);

    enum class Variant {
        Normal,
        SmallCaps,
        AllSmallCaps,
        AllPetiteCaps,
        PetiteCaps,
        Unicase,
    };
    static std::string to_string(Variant e);

    Layout::Ternary::Baxis::Tickfont& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Baxis::Tickfont& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Ternary::Baxis::Tickfont& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Baxis::Tickfont& family(Callable&& c);

    // Sets the kind of decoration line(s) with text, such as an *under*, *over* or *through* as well as combinations
    // e.g. *under+over*, etc.
    // - Default: none
    // - Flags: ['under', 'over', 'through']
    // - Extras ['none']
    Layout::Ternary::Baxis::Tickfont& lineposition(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Baxis::Tickfont& lineposition(Callable&& c);

    // Sets the shape and color of the shadow behind text. *auto* places minimal shadow and applies contrast text font
    // color. See https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow for additional options.
    Layout::Ternary::Baxis::Tickfont& shadow(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Baxis::Tickfont& shadow(Callable&& c);

    Layout::Ternary::Baxis::Tickfont& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Ternary::Baxis::Tickfont& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Ternary::Baxis::Tickfont& style(enum Style f);

    // Sets capitalization of text. It can be used to make text appear in all-uppercase or all-lowercase, or with each
    // word capitalized.
    // - Default: normal
    Layout::Ternary::Baxis::Tickfont& textcase(enum Textcase f);

    // Sets the variant of the font.
    // - Default: normal
    Layout::Ternary::Baxis::Tickfont& variant(enum Variant f);

    // Sets the weight (or boldness) of the font.
    Layout::Ternary::Baxis::Tickfont& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Ternary::Baxis::Tickfont& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Ternary::Baxis::Tickformatstops {
 public:
    Tickformatstops() = default;
    Tickformatstops(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    class Tickformatstop;

    Layout::Ternary::Baxis::Tickformatstops& tickformatstop(Tickformatstop f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Tickformatstop&>>>
    Layout::Ternary::Baxis::Tickformatstops& tickformatstop(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Ternary::Baxis::Tickformatstops::Tickformatstop {
 public:
    Tickformatstop() = default;
    Tickformatstop(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // range [*min*, *max*], where *min*, *max* - dtick values which describe some zoom level, it is possible to omit
    // *min* or *max* value by passing *null*
    Layout::Ternary::Baxis::Tickformatstops::Tickformatstop& dtickrange(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Ternary::Baxis::Tickformatstops::Tickformatstop& dtickrange(Callable&& c);

    // Determines whether or not this stop is used. If `false`, this stop is ignored even within its `dtickrange`.
    Layout::Ternary::Baxis::Tickformatstops::Tickformatstop& enabled(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Ternary::Baxis::Tickformatstops::Tickformatstop& enabled(Callable&& c);

    // When used in a template, named items are created in the output figure in addition to any items the figure already
    // has in this array. You can modify these items in the output figure by making your own item with
    // `templateitemname` matching this `name` alongside your modifications (including `visible: false` or `enabled:
    // false` to hide it). Has no effect outside of a template.
    Layout::Ternary::Baxis::Tickformatstops::Tickformatstop& name(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Baxis::Tickformatstops::Tickformatstop& name(Callable&& c);

    // Used to refer to a named item in this array in the template. Named items from the template will be created even
    // without a matching item in the input figure, but you can modify one by making an item with `templateitemname`
    // matching its `name`, alongside your modifications (including `visible: false` or `enabled: false` to hide it). If
    // there is no template or no matching item, this item will be hidden unless you explicitly show it with `visible:
    // true`.
    Layout::Ternary::Baxis::Tickformatstops::Tickformatstop& templateitemname(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Baxis::Tickformatstops::Tickformatstop& templateitemname(Callable&& c);

    // string - dtickformat for described zoom level, the same as *tickformat*
    Layout::Ternary::Baxis::Tickformatstops::Tickformatstop& value(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Baxis::Tickformatstops::Tickformatstop& value(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Ternary::Baxis::Title {
 public:
    Title() = default;
    Title(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Sets this axis' title font.
    class Font;

    // Sets this axis' title font.
    Layout::Ternary::Baxis::Title& font(Font f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Font&>>>
    Layout::Ternary::Baxis::Title& font(Callable&& c);

    // Sets the title of this axis.
    Layout::Ternary::Baxis::Title& text(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Baxis::Title& text(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets this axis' title font.
class Layout::Ternary::Baxis::Title::Font {
 public:
    Font() = default;
    Font(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    enum class Textcase {
        Normal,
        WordCaps,
        Upper,
        Lower,
    };
    static std::string to_string(Textcase e);

    enum class Variant {
        Normal,
        SmallCaps,
        AllSmallCaps,
        AllPetiteCaps,
        PetiteCaps,
        Unicase,
    };
    static std::string to_string(Variant e);

    Layout::Ternary::Baxis::Title::Font& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Baxis::Title::Font& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Ternary::Baxis::Title::Font& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Baxis::Title::Font& family(Callable&& c);

    // Sets the kind of decoration line(s) with text, such as an *under*, *over* or *through* as well as combinations
    // e.g. *under+over*, etc.
    // - Default: none
    // - Flags: ['under', 'over', 'through']
    // - Extras ['none']
    Layout::Ternary::Baxis::Title::Font& lineposition(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Baxis::Title::Font& lineposition(Callable&& c);

    // Sets the shape and color of the shadow behind text. *auto* places minimal shadow and applies contrast text font
    // color. See https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow for additional options.
    Layout::Ternary::Baxis::Title::Font& shadow(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Baxis::Title::Font& shadow(Callable&& c);

    Layout::Ternary::Baxis::Title::Font& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Ternary::Baxis::Title::Font& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Ternary::Baxis::Title::Font& style(enum Style f);

    // Sets capitalization of text. It can be used to make text appear in all-uppercase or all-lowercase, or with each
    // word capitalized.
    // - Default: normal
    Layout::Ternary::Baxis::Title::Font& textcase(enum Textcase f);

    // Sets the variant of the font.
    // - Default: normal
    Layout::Ternary::Baxis::Title::Font& variant(enum Variant f);

    // Sets the weight (or boldness) of the font.
    Layout::Ternary::Baxis::Title::Font& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Ternary::Baxis::Title::Font& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Ternary::Caxis {
 public:
    Caxis() = default;
    Caxis(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Exponentformat {
        None,
        E,
        Power,
        Si,
        B,
    };
    static std::string to_string(Exponentformat e);

    enum class Layer {
        AboveTraces,
        BelowTraces,
    };
    static std::string to_string(Layer e);

    enum class Showexponent {
        All,
        First,
        Last,
        None,
    };
    static std::string to_string(Showexponent e);

    enum class Showtickprefix {
        All,
        First,
        Last,
        None,
    };
    static std::string to_string(Showtickprefix e);

    enum class Showticksuffix {
        All,
        First,
        Last,
        None,
    };
    static std::string to_string(Showticksuffix e);

    enum class Tickmode {
        Auto,
        Linear,
        Array,
    };
    static std::string to_string(Tickmode e);

    enum class Ticks {
        Outside,
        Inside,
        Empty,
    };
    static std::string to_string(Ticks e);

    // Sets the tick font.
    class Tickfont;
    class Tickformatstops;
    class Title;

    // Sets default for all colors associated with this axis all at once: line, font, tick, and grid colors. Grid color
    // is lightened by blending this with the plot background Individual pieces can override this.
    Layout::Ternary::Caxis& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Caxis& color(Callable&& c);

    // Sets the step in-between ticks on this axis. Use with `tick0`. Must be a positive number, or special strings
    // available to *log* and *date* axes. If the axis `type` is *log*, then ticks are set every 10^(n*dtick) where n is
    // the tick number. For example, to set a tick mark at 1, 10, 100, 1000, ... set dtick to 1. To set tick marks at 1,
    // 100, 10000, ... set dtick to 2. To set tick marks at 1, 5, 25, 125, 625, 3125, ... set dtick to log_10(5), or
    // 0.69897000433. *log* has several special values; *L<f>*, where `f` is a positive number, gives ticks linearly
    // spaced in value (but not position). For example `tick0` = 0.1, `dtick` = *L0.5* will put ticks at 0.1,
    // 0.6, 1.1, 1.6 etc. To show powers of 10 plus small digits between, use *D1* (all digits) or *D2* (only 2 and 5).
    // `tick0` is ignored for *D1* and *D2*. If the axis `type` is *date*, then you must convert the time to
    // milliseconds. For example, to set the interval between ticks to one day, set `dtick` to 86400000.0. *date* also
    // has special values *M<n>* gives ticks spaced by a number of months. `n` must be a positive integer. To set ticks
    // on the 15th of every third month, set `tick0` to *2000-01-15* and `dtick` to *M3*. To set ticks every 4 years,
    // set `dtick` to *M48*
    template <typename T>
    Layout::Ternary::Caxis& dtick(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Ternary::Caxis& dtick(Callable&& c);

    // Determines a formatting rule for the tick exponents. For example, consider the number 1,000,000,000. If *none*,
    // it appears as 1,000,000,000. If *e*, 1e+9. If *E*, 1E+9. If *power*, 1x10^9 (with 9 in a super script). If *SI*,
    // 1G. If *B*, 1B.
    // - Default: B
    Layout::Ternary::Caxis& exponentformat(enum Exponentformat f);

    // Sets the color of the grid lines.
    Layout::Ternary::Caxis& gridcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Caxis& gridcolor(Callable&& c);

    // Sets the dash style of lines. Set to a dash type string (*solid*, *dot*, *dash*, *longdash*, *dashdot*, or
    // *longdashdot*) or a dash length list in px (eg *5px,10px,2px,2px*).
    Layout::Ternary::Caxis& griddash(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Caxis& griddash(Callable&& c);

    // Sets the width (in px) of the grid lines.
    Layout::Ternary::Caxis& gridwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Ternary::Caxis& gridwidth(Callable&& c);

    // Sets the hover text formatting rule using d3 formatting mini-languages which are very similar to those in Python.
    // For numbers, see: https://github.com/d3/d3-format/tree/v1.4.5#d3-format. And for dates see:
    // https://github.com/d3/d3-time-format/tree/v2.2.3#locale_format. We add two items to d3's date formatter: *%h* for
    // half of the year as a decimal number as well as *%{n}f* for fractional seconds with n digits. For example,
    // *2016-10-13 09:15:23.456* with tickformat *%H~%M~%S.%2f* would display *09~15~23.46*
    Layout::Ternary::Caxis& hoverformat(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Caxis& hoverformat(Callable&& c);

    // Replacement text for specific tick or hover labels. For example using {US: 'USA', CA: 'Canada'} changes US to USA
    // and CA to Canada. The labels we would have shown must match the keys exactly, after adding any tickprefix or
    // ticksuffix. For negative numbers the minus sign symbol used (U+2212) is wider than the regular ascii dash. That
    // means you need to use 1 instead of -1. labelalias can be used with any axis type, and both keys (if needed) and
    // values (if desired) can include html-like tags or MathJax.
    template <typename T>
    Layout::Ternary::Caxis& labelalias(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Ternary::Caxis& labelalias(Callable&& c);

    // Sets the layer on which this axis is displayed. If *above traces*, this axis is displayed above all the subplot's
    // traces If *below traces*, this axis is displayed below all the subplot's traces, but above the grid lines. Useful
    // when used together with scatter-like traces with `cliponaxis` set to *false* to show markers and/or text nodes
    // above this axis.
    // - Default: above traces
    Layout::Ternary::Caxis& layer(enum Layer f);

    // Sets the axis line color.
    Layout::Ternary::Caxis& linecolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Caxis& linecolor(Callable&& c);

    // Sets the width (in px) of the axis line.
    Layout::Ternary::Caxis& linewidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Ternary::Caxis& linewidth(Callable&& c);

    // The minimum value visible on this axis. The maximum is determined by the sum minus the minimum values of the
    // other two axes. The full view corresponds to all the minima set to zero.
    Layout::Ternary::Caxis& min(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Ternary::Caxis& min(Callable&& c);

    // Hide SI prefix for 10^n if |n| is below this number. This only has an effect when `tickformat` is *SI* or *B*.
    Layout::Ternary::Caxis& minexponent(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Ternary::Caxis& minexponent(Callable&& c);

    // Specifies the maximum number of ticks for the particular axis. The actual number of ticks will be chosen
    // automatically to be less than or equal to `nticks`. Has an effect only if `tickmode` is set to *auto*.
    Layout::Ternary::Caxis& nticks(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Ternary::Caxis& nticks(Callable&& c);

    // If "true", even 4-digit integers are separated
    Layout::Ternary::Caxis& separatethousands(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Ternary::Caxis& separatethousands(Callable&& c);

    // If *all*, all exponents are shown besides their significands. If *first*, only the exponent of the first tick is
    // shown. If *last*, only the exponent of the last tick is shown. If *none*, no exponents appear.
    // - Default: all
    Layout::Ternary::Caxis& showexponent(enum Showexponent f);

    // Determines whether or not grid lines are drawn. If *true*, the grid lines are drawn at every tick mark.
    Layout::Ternary::Caxis& showgrid(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Ternary::Caxis& showgrid(Callable&& c);

    // Determines whether or not a line bounding this axis is drawn.
    Layout::Ternary::Caxis& showline(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Ternary::Caxis& showline(Callable&& c);

    // Determines whether or not the tick labels are drawn.
    Layout::Ternary::Caxis& showticklabels(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Ternary::Caxis& showticklabels(Callable&& c);

    // If *all*, all tick labels are displayed with a prefix. If *first*, only the first tick is displayed with a
    // prefix. If *last*, only the last tick is displayed with a suffix. If *none*, tick prefixes are hidden.
    // - Default: all
    Layout::Ternary::Caxis& showtickprefix(enum Showtickprefix f);

    // Same as `showtickprefix` but for tick suffixes.
    // - Default: all
    Layout::Ternary::Caxis& showticksuffix(enum Showticksuffix f);

    // Sets the placement of the first tick on this axis. Use with `dtick`. If the axis `type` is *log*, then you must
    // take the log of your starting tick (e.g. to set the starting tick to 100, set the `tick0` to 2) except when
    // `dtick`=*L<f>* (see `dtick` for more info). If the axis `type` is *date*, it should be a date string, like date
    // data. If the axis `type` is *category*, it should be a number, using the scale where each category is assigned a
    // serial number from zero in the order it appears.
    template <typename T>
    Layout::Ternary::Caxis& tick0(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Ternary::Caxis& tick0(Callable&& c);

    // Sets the angle of the tick labels with respect to the horizontal. For example, a `tickangle` of -90 draws the
    // tick labels vertically.
    Layout::Ternary::Caxis& tickangle(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Ternary::Caxis& tickangle(Callable&& c);

    // Sets the tick color.
    Layout::Ternary::Caxis& tickcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Caxis& tickcolor(Callable&& c);

    // Sets the tick font.
    Layout::Ternary::Caxis& tickfont(Tickfont f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Tickfont&>>>
    Layout::Ternary::Caxis& tickfont(Callable&& c);

    // Sets the tick label formatting rule using d3 formatting mini-languages which are very similar to those in Python.
    // For numbers, see: https://github.com/d3/d3-format/tree/v1.4.5#d3-format. And for dates see:
    // https://github.com/d3/d3-time-format/tree/v2.2.3#locale_format. We add two items to d3's date formatter: *%h* for
    // half of the year as a decimal number as well as *%{n}f* for fractional seconds with n digits. For example,
    // *2016-10-13 09:15:23.456* with tickformat *%H~%M~%S.%2f* would display *09~15~23.46*
    Layout::Ternary::Caxis& tickformat(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Caxis& tickformat(Callable&& c);

    Layout::Ternary::Caxis& tickformatstops(Tickformatstops f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Tickformatstops&>>>
    Layout::Ternary::Caxis& tickformatstops(Callable&& c);

    // Sets the spacing between tick labels as compared to the spacing between ticks. A value of 1 (default) means each
    // tick gets a label. A value of 2 means shows every 2nd label. A larger value n means only every nth tick is
    // labeled. `tick0` determines which labels are shown. Not implemented for axes with `type` *log* or
    // *multicategory*, or when `tickmode` is *array*.
    Layout::Ternary::Caxis& ticklabelstep(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Ternary::Caxis& ticklabelstep(Callable&& c);

    // Sets the tick length (in px).
    Layout::Ternary::Caxis& ticklen(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Ternary::Caxis& ticklen(Callable&& c);

    // Sets the tick mode for this axis. If *auto*, the number of ticks is set via `nticks`. If *linear*, the placement
    // of the ticks is determined by a starting position `tick0` and a tick step `dtick` (*linear* is the default value
    // if `tick0` and `dtick` are provided). If *array*, the placement of the ticks is set via `tickvals` and the tick
    // text is `ticktext`. (*array* is the default value if `tickvals` is provided).
    Layout::Ternary::Caxis& tickmode(enum Tickmode f);

    // Sets a tick label prefix.
    Layout::Ternary::Caxis& tickprefix(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Caxis& tickprefix(Callable&& c);

    // Determines whether ticks are drawn or not. If **, this axis' ticks are not drawn. If *outside* (*inside*), this
    // axis' are drawn outside (inside) the axis lines.
    Layout::Ternary::Caxis& ticks(enum Ticks f);

    // Sets a tick label suffix.
    Layout::Ternary::Caxis& ticksuffix(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Caxis& ticksuffix(Callable&& c);

    // Sets the text displayed at the ticks position via `tickvals`. Only has an effect if `tickmode` is set to *array*.
    // Used with `tickvals`.
    template <typename T, typename = std::enable_if_t<is_data_array_element_v<T>>>
    Layout::Ternary::Caxis& ticktext(const std::vector<T>& f);
    template <
        typename T, typename Callable,
        typename = std::enable_if_t<is_data_array_element_v<T> && (std::is_invocable_v<Callable, std::vector<T>&>)>>
    Layout::Ternary::Caxis& ticktext(Callable&& c);

    // Sets the source reference on Chart Studio Cloud for `ticktext`.
    Layout::Ternary::Caxis& ticktextsrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Caxis& ticktextsrc(Callable&& c);

    // Sets the values at which ticks on this axis appear. Only has an effect if `tickmode` is set to *array*. Used with
    // `ticktext`.
    template <typename T, typename = std::enable_if_t<is_data_array_element_v<T>>>
    Layout::Ternary::Caxis& tickvals(const std::vector<T>& f);
    template <
        typename T, typename Callable,
        typename = std::enable_if_t<is_data_array_element_v<T> && (std::is_invocable_v<Callable, std::vector<T>&>)>>
    Layout::Ternary::Caxis& tickvals(Callable&& c);

    // Sets the source reference on Chart Studio Cloud for `tickvals`.
    Layout::Ternary::Caxis& tickvalssrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Caxis& tickvalssrc(Callable&& c);

    // Sets the tick width (in px).
    Layout::Ternary::Caxis& tickwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Ternary::Caxis& tickwidth(Callable&& c);

    Layout::Ternary::Caxis& title(Title f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Title&>>>
    Layout::Ternary::Caxis& title(Callable&& c);

    // Controls persistence of user-driven changes in axis `min`, and `title` if in `editable: true` configuration.
    // Defaults to `ternary<N>.uirevision`.
    template <typename T>
    Layout::Ternary::Caxis& uirevision(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Ternary::Caxis& uirevision(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets the tick font.
class Layout::Ternary::Caxis::Tickfont {
 public:
    Tickfont() = default;
    Tickfont(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    enum class Textcase {
        Normal,
        WordCaps,
        Upper,
        Lower,
    };
    static std::string to_string(Textcase e);

    enum class Variant {
        Normal,
        SmallCaps,
        AllSmallCaps,
        AllPetiteCaps,
        PetiteCaps,
        Unicase,
    };
    static std::string to_string(Variant e);

    Layout::Ternary::Caxis::Tickfont& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Caxis::Tickfont& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Ternary::Caxis::Tickfont& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Caxis::Tickfont& family(Callable&& c);

    // Sets the kind of decoration line(s) with text, such as an *under*, *over* or *through* as well as combinations
    // e.g. *under+over*, etc.
    // - Default: none
    // - Flags: ['under', 'over', 'through']
    // - Extras ['none']
    Layout::Ternary::Caxis::Tickfont& lineposition(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Caxis::Tickfont& lineposition(Callable&& c);

    // Sets the shape and color of the shadow behind text. *auto* places minimal shadow and applies contrast text font
    // color. See https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow for additional options.
    Layout::Ternary::Caxis::Tickfont& shadow(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Caxis::Tickfont& shadow(Callable&& c);

    Layout::Ternary::Caxis::Tickfont& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Ternary::Caxis::Tickfont& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Ternary::Caxis::Tickfont& style(enum Style f);

    // Sets capitalization of text. It can be used to make text appear in all-uppercase or all-lowercase, or with each
    // word capitalized.
    // - Default: normal
    Layout::Ternary::Caxis::Tickfont& textcase(enum Textcase f);

    // Sets the variant of the font.
    // - Default: normal
    Layout::Ternary::Caxis::Tickfont& variant(enum Variant f);

    // Sets the weight (or boldness) of the font.
    Layout::Ternary::Caxis::Tickfont& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Ternary::Caxis::Tickfont& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Ternary::Caxis::Tickformatstops {
 public:
    Tickformatstops() = default;
    Tickformatstops(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    class Tickformatstop;

    Layout::Ternary::Caxis::Tickformatstops& tickformatstop(Tickformatstop f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Tickformatstop&>>>
    Layout::Ternary::Caxis::Tickformatstops& tickformatstop(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Ternary::Caxis::Tickformatstops::Tickformatstop {
 public:
    Tickformatstop() = default;
    Tickformatstop(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // range [*min*, *max*], where *min*, *max* - dtick values which describe some zoom level, it is possible to omit
    // *min* or *max* value by passing *null*
    Layout::Ternary::Caxis::Tickformatstops::Tickformatstop& dtickrange(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Ternary::Caxis::Tickformatstops::Tickformatstop& dtickrange(Callable&& c);

    // Determines whether or not this stop is used. If `false`, this stop is ignored even within its `dtickrange`.
    Layout::Ternary::Caxis::Tickformatstops::Tickformatstop& enabled(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Ternary::Caxis::Tickformatstops::Tickformatstop& enabled(Callable&& c);

    // When used in a template, named items are created in the output figure in addition to any items the figure already
    // has in this array. You can modify these items in the output figure by making your own item with
    // `templateitemname` matching this `name` alongside your modifications (including `visible: false` or `enabled:
    // false` to hide it). Has no effect outside of a template.
    Layout::Ternary::Caxis::Tickformatstops::Tickformatstop& name(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Caxis::Tickformatstops::Tickformatstop& name(Callable&& c);

    // Used to refer to a named item in this array in the template. Named items from the template will be created even
    // without a matching item in the input figure, but you can modify one by making an item with `templateitemname`
    // matching its `name`, alongside your modifications (including `visible: false` or `enabled: false` to hide it). If
    // there is no template or no matching item, this item will be hidden unless you explicitly show it with `visible:
    // true`.
    Layout::Ternary::Caxis::Tickformatstops::Tickformatstop& templateitemname(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Caxis::Tickformatstops::Tickformatstop& templateitemname(Callable&& c);

    // string - dtickformat for described zoom level, the same as *tickformat*
    Layout::Ternary::Caxis::Tickformatstops::Tickformatstop& value(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Caxis::Tickformatstops::Tickformatstop& value(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Ternary::Caxis::Title {
 public:
    Title() = default;
    Title(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Sets this axis' title font.
    class Font;

    // Sets this axis' title font.
    Layout::Ternary::Caxis::Title& font(Font f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Font&>>>
    Layout::Ternary::Caxis::Title& font(Callable&& c);

    // Sets the title of this axis.
    Layout::Ternary::Caxis::Title& text(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Caxis::Title& text(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets this axis' title font.
class Layout::Ternary::Caxis::Title::Font {
 public:
    Font() = default;
    Font(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    enum class Textcase {
        Normal,
        WordCaps,
        Upper,
        Lower,
    };
    static std::string to_string(Textcase e);

    enum class Variant {
        Normal,
        SmallCaps,
        AllSmallCaps,
        AllPetiteCaps,
        PetiteCaps,
        Unicase,
    };
    static std::string to_string(Variant e);

    Layout::Ternary::Caxis::Title::Font& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Caxis::Title::Font& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Ternary::Caxis::Title::Font& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Caxis::Title::Font& family(Callable&& c);

    // Sets the kind of decoration line(s) with text, such as an *under*, *over* or *through* as well as combinations
    // e.g. *under+over*, etc.
    // - Default: none
    // - Flags: ['under', 'over', 'through']
    // - Extras ['none']
    Layout::Ternary::Caxis::Title::Font& lineposition(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Caxis::Title::Font& lineposition(Callable&& c);

    // Sets the shape and color of the shadow behind text. *auto* places minimal shadow and applies contrast text font
    // color. See https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow for additional options.
    Layout::Ternary::Caxis::Title::Font& shadow(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Ternary::Caxis::Title::Font& shadow(Callable&& c);

    Layout::Ternary::Caxis::Title::Font& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Ternary::Caxis::Title::Font& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Ternary::Caxis::Title::Font& style(enum Style f);

    // Sets capitalization of text. It can be used to make text appear in all-uppercase or all-lowercase, or with each
    // word capitalized.
    // - Default: normal
    Layout::Ternary::Caxis::Title::Font& textcase(enum Textcase f);

    // Sets the variant of the font.
    // - Default: normal
    Layout::Ternary::Caxis::Title::Font& variant(enum Variant f);

    // Sets the weight (or boldness) of the font.
    Layout::Ternary::Caxis::Title::Font& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Ternary::Caxis::Title::Font& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Ternary::Domain {
 public:
    Domain() = default;
    Domain(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // If there is a layout grid, use the domain for this column in the grid for this ternary subplot .
    Layout::Ternary::Domain& column(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Ternary::Domain& column(Callable&& c);

    // If there is a layout grid, use the domain for this row in the grid for this ternary subplot .
    Layout::Ternary::Domain& row(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Ternary::Domain& row(Callable&& c);

    // Sets the horizontal domain of this ternary subplot (in plot fraction).
    Layout::Ternary::Domain& x(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Ternary::Domain& x(Callable&& c);

    // Sets the vertical domain of this ternary subplot (in plot fraction).
    Layout::Ternary::Domain& y(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Ternary::Domain& y(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Title {
 public:
    Title() = default;
    Title(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Xanchor {
        Auto,
        Left,
        Center,
        Right,
    };
    static std::string to_string(Xanchor e);

    enum class Xref {
        Container,
        Paper,
    };
    static std::string to_string(Xref e);

    enum class Yanchor {
        Auto,
        Top,
        Middle,
        Bottom,
    };
    static std::string to_string(Yanchor e);

    enum class Yref {
        Container,
        Paper,
    };
    static std::string to_string(Yref e);

    // Sets the title font.
    class Font;
    // Sets the padding of the title. Each padding value only applies when the corresponding `xanchor`/`yanchor` value
    // is set accordingly. E.g. for left padding to take effect, `xanchor` must be set to *left*. The same rule applies
    // if `xanchor`/`yanchor` is determined automatically. Padding is muted if the respective anchor value is
    // *middle*/*center*.
    class Pad;
    class Subtitle;

    // Determines whether the title can automatically push the figure margins. If `yref='paper'` then the margin will
    // expand to ensure that the title doesnt overlap with the edges of the container. If `yref='container'` then the
    // margins will ensure that the title doesnt overlap with the plot area, tick labels, and axis titles. If
    // `automargin=true` and the margins need to be expanded, then y will be set to a default 1 and yanchor will be set
    // to an appropriate default to ensure that minimal margin space is needed. Note that when `yref='paper'`, only 1 or
    // 0 are allowed y values. Invalid values will be reset to the default 1.
    Layout::Title& automargin(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Title& automargin(Callable&& c);

    // Sets the title font.
    Layout::Title& font(Font f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Font&>>>
    Layout::Title& font(Callable&& c);

    // Sets the padding of the title. Each padding value only applies when the corresponding `xanchor`/`yanchor` value
    // is set accordingly. E.g. for left padding to take effect, `xanchor` must be set to *left*. The same rule applies
    // if `xanchor`/`yanchor` is determined automatically. Padding is muted if the respective anchor value is
    // *middle*/*center*.
    Layout::Title& pad(Pad f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Pad&>>>
    Layout::Title& pad(Callable&& c);

    Layout::Title& subtitle(Subtitle f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Subtitle&>>>
    Layout::Title& subtitle(Callable&& c);

    // Sets the plot's title.
    Layout::Title& text(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Title& text(Callable&& c);

    // Sets the x position with respect to `xref` in normalized coordinates from *0* (left) to *1* (right).
    Layout::Title& x(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Title& x(Callable&& c);

    // Sets the title's horizontal alignment with respect to its x position. *left* means that the title starts at x,
    // *right* means that the title ends at x and *center* means that the title's center is at x. *auto* divides `xref`
    // by three and calculates the `xanchor` value automatically based on the value of `x`.
    // - Default: auto
    Layout::Title& xanchor(enum Xanchor f);

    // Sets the container `x` refers to. *container* spans the entire `width` of the plot. *paper* refers to the width
    // of the plotting area only.
    // - Default: container
    Layout::Title& xref(enum Xref f);

    // Sets the y position with respect to `yref` in normalized coordinates from *0* (bottom) to *1* (top). *auto*
    // places the baseline of the title onto the vertical center of the top margin.
    Layout::Title& y(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Title& y(Callable&& c);

    // Sets the title's vertical alignment with respect to its y position. *top* means that the title's cap line is at
    // y, *bottom* means that the title's baseline is at y and *middle* means that the title's midline is at y. *auto*
    // divides `yref` by three and calculates the `yanchor` value automatically based on the value of `y`.
    // - Default: auto
    Layout::Title& yanchor(enum Yanchor f);

    // Sets the container `y` refers to. *container* spans the entire `height` of the plot. *paper* refers to the height
    // of the plotting area only.
    // - Default: container
    Layout::Title& yref(enum Yref f);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets the title font.
class Layout::Title::Font {
 public:
    Font() = default;
    Font(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    enum class Textcase {
        Normal,
        WordCaps,
        Upper,
        Lower,
    };
    static std::string to_string(Textcase e);

    enum class Variant {
        Normal,
        SmallCaps,
        AllSmallCaps,
        AllPetiteCaps,
        PetiteCaps,
        Unicase,
    };
    static std::string to_string(Variant e);

    Layout::Title::Font& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Title::Font& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Title::Font& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Title::Font& family(Callable&& c);

    // Sets the kind of decoration line(s) with text, such as an *under*, *over* or *through* as well as combinations
    // e.g. *under+over*, etc.
    // - Default: none
    // - Flags: ['under', 'over', 'through']
    // - Extras ['none']
    Layout::Title::Font& lineposition(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Title::Font& lineposition(Callable&& c);

    // Sets the shape and color of the shadow behind text. *auto* places minimal shadow and applies contrast text font
    // color. See https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow for additional options.
    Layout::Title::Font& shadow(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Title::Font& shadow(Callable&& c);

    Layout::Title::Font& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Title::Font& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Title::Font& style(enum Style f);

    // Sets capitalization of text. It can be used to make text appear in all-uppercase or all-lowercase, or with each
    // word capitalized.
    // - Default: normal
    Layout::Title::Font& textcase(enum Textcase f);

    // Sets the variant of the font.
    // - Default: normal
    Layout::Title::Font& variant(enum Variant f);

    // Sets the weight (or boldness) of the font.
    Layout::Title::Font& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Title::Font& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets the padding of the title. Each padding value only applies when the corresponding `xanchor`/`yanchor` value is
// set accordingly. E.g. for left padding to take effect, `xanchor` must be set to *left*. The same rule applies if
// `xanchor`/`yanchor` is determined automatically. Padding is muted if the respective anchor value is
// *middle*/*center*.
class Layout::Title::Pad {
 public:
    Pad() = default;
    Pad(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // The amount of padding (in px) along the bottom of the component.
    Layout::Title::Pad& b(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Title::Pad& b(Callable&& c);

    // The amount of padding (in px) on the left side of the component.
    Layout::Title::Pad& l(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Title::Pad& l(Callable&& c);

    // The amount of padding (in px) on the right side of the component.
    Layout::Title::Pad& r(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Title::Pad& r(Callable&& c);

    // The amount of padding (in px) along the top of the component.
    Layout::Title::Pad& t(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Title::Pad& t(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Title::Subtitle {
 public:
    Subtitle() = default;
    Subtitle(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Sets the subtitle font.
    class Font;

    // Sets the subtitle font.
    Layout::Title::Subtitle& font(Font f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Font&>>>
    Layout::Title::Subtitle& font(Callable&& c);

    // Sets the plot's subtitle.
    Layout::Title::Subtitle& text(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Title::Subtitle& text(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets the subtitle font.
class Layout::Title::Subtitle::Font {
 public:
    Font() = default;
    Font(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    enum class Textcase {
        Normal,
        WordCaps,
        Upper,
        Lower,
    };
    static std::string to_string(Textcase e);

    enum class Variant {
        Normal,
        SmallCaps,
        AllSmallCaps,
        AllPetiteCaps,
        PetiteCaps,
        Unicase,
    };
    static std::string to_string(Variant e);

    Layout::Title::Subtitle::Font& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Title::Subtitle::Font& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Title::Subtitle::Font& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Title::Subtitle::Font& family(Callable&& c);

    // Sets the kind of decoration line(s) with text, such as an *under*, *over* or *through* as well as combinations
    // e.g. *under+over*, etc.
    // - Default: none
    // - Flags: ['under', 'over', 'through']
    // - Extras ['none']
    Layout::Title::Subtitle::Font& lineposition(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Title::Subtitle::Font& lineposition(Callable&& c);

    // Sets the shape and color of the shadow behind text. *auto* places minimal shadow and applies contrast text font
    // color. See https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow for additional options.
    Layout::Title::Subtitle::Font& shadow(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Title::Subtitle::Font& shadow(Callable&& c);

    Layout::Title::Subtitle::Font& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Title::Subtitle::Font& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Title::Subtitle::Font& style(enum Style f);

    // Sets capitalization of text. It can be used to make text appear in all-uppercase or all-lowercase, or with each
    // word capitalized.
    // - Default: normal
    Layout::Title::Subtitle::Font& textcase(enum Textcase f);

    // Sets the variant of the font.
    // - Default: normal
    Layout::Title::Subtitle::Font& variant(enum Variant f);

    // Sets the weight (or boldness) of the font.
    Layout::Title::Subtitle::Font& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Title::Subtitle::Font& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets transition options used during Plotly.react updates.
class Layout::Transition {
 public:
    Transition() = default;
    Transition(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Easing {
        Linear,
        Quad,
        Cubic,
        Sin,
        Exp,
        Circle,
        Elastic,
        Back,
        Bounce,
        LinearIn,
        QuadIn,
        CubicIn,
        SinIn,
        ExpIn,
        CircleIn,
        ElasticIn,
        BackIn,
        BounceIn,
        LinearOut,
        QuadOut,
        CubicOut,
        SinOut,
        ExpOut,
        CircleOut,
        ElasticOut,
        BackOut,
        BounceOut,
        LinearInOut,
        QuadInOut,
        CubicInOut,
        SinInOut,
        ExpInOut,
        CircleInOut,
        ElasticInOut,
        BackInOut,
        BounceInOut,
    };
    static std::string to_string(Easing e);

    enum class Ordering {
        LayoutFirst,
        TracesFirst,
    };
    static std::string to_string(Ordering e);

    // The duration of the transition, in milliseconds. If equal to zero, updates are synchronous.
    Layout::Transition& duration(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Transition& duration(Callable&& c);

    // The easing function used for the transition
    // - Default: cubic-in-out
    Layout::Transition& easing(enum Easing f);

    // Determines whether the figure's layout or traces smoothly transitions during updates that make both traces and
    // layout change.
    // - Default: layout first
    Layout::Transition& ordering(enum Ordering f);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Uniformtext {
 public:
    Uniformtext() = default;
    Uniformtext(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Mode {
        False,
        Hide,
        Show,
    };
    static std::string to_string(Mode e);

    // Sets the minimum text size between traces of the same type.
    Layout::Uniformtext& minsize(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Uniformtext& minsize(Callable&& c);

    // Determines how the font size for various text elements are uniformed between each trace type. If the computed
    // text sizes were smaller than the minimum size defined by `uniformtext.minsize` using *hide* option hides the
    // text; and using *show* option shows the text without further downscaling. Please note that if the size defined by
    // `minsize` is greater than the font size defined by trace, then the `minsize` is used.
    // - Default: False
    Layout::Uniformtext& mode(enum Mode f);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Updatemenus {
 public:
    Updatemenus() = default;
    Updatemenus(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    class Updatemenu;

    Layout::Updatemenus& updatemenu(Updatemenu f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Updatemenu&>>>
    Layout::Updatemenus& updatemenu(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Updatemenus::Updatemenu {
 public:
    Updatemenu() = default;
    Updatemenu(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Direction {
        Left,
        Right,
        Up,
        Down,
    };
    static std::string to_string(Direction e);

    enum class Type {
        Dropdown,
        Buttons,
    };
    static std::string to_string(Type e);

    enum class Xanchor {
        Auto,
        Left,
        Center,
        Right,
    };
    static std::string to_string(Xanchor e);

    enum class Yanchor {
        Auto,
        Top,
        Middle,
        Bottom,
    };
    static std::string to_string(Yanchor e);

    class Buttons;
    // Sets the font of the update menu button text.
    class Font;
    // Sets the padding around the buttons or dropdown menu.
    class Pad;

    // Determines which button (by index starting from 0) is considered active.
    Layout::Updatemenus::Updatemenu& active(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Updatemenus::Updatemenu& active(Callable&& c);

    // Sets the background color of the update menu buttons.
    Layout::Updatemenus::Updatemenu& bgcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Updatemenus::Updatemenu& bgcolor(Callable&& c);

    // Sets the color of the border enclosing the update menu.
    Layout::Updatemenus::Updatemenu& bordercolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Updatemenus::Updatemenu& bordercolor(Callable&& c);

    // Sets the width (in px) of the border enclosing the update menu.
    Layout::Updatemenus::Updatemenu& borderwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Updatemenus::Updatemenu& borderwidth(Callable&& c);

    Layout::Updatemenus::Updatemenu& buttons(Buttons f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Buttons&>>>
    Layout::Updatemenus::Updatemenu& buttons(Callable&& c);

    // Determines the direction in which the buttons are laid out, whether in a dropdown menu or a row/column of
    // buttons. For `left` and `up`, the buttons will still appear in left-to-right or top-to-bottom order respectively.
    // - Default: down
    Layout::Updatemenus::Updatemenu& direction(enum Direction f);

    // Sets the font of the update menu button text.
    Layout::Updatemenus::Updatemenu& font(Font f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Font&>>>
    Layout::Updatemenus::Updatemenu& font(Callable&& c);

    // When used in a template, named items are created in the output figure in addition to any items the figure already
    // has in this array. You can modify these items in the output figure by making your own item with
    // `templateitemname` matching this `name` alongside your modifications (including `visible: false` or `enabled:
    // false` to hide it). Has no effect outside of a template.
    Layout::Updatemenus::Updatemenu& name(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Updatemenus::Updatemenu& name(Callable&& c);

    // Sets the padding around the buttons or dropdown menu.
    Layout::Updatemenus::Updatemenu& pad(Pad f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Pad&>>>
    Layout::Updatemenus::Updatemenu& pad(Callable&& c);

    // Highlights active dropdown item or active button if true.
    Layout::Updatemenus::Updatemenu& showactive(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Updatemenus::Updatemenu& showactive(Callable&& c);

    // Used to refer to a named item in this array in the template. Named items from the template will be created even
    // without a matching item in the input figure, but you can modify one by making an item with `templateitemname`
    // matching its `name`, alongside your modifications (including `visible: false` or `enabled: false` to hide it). If
    // there is no template or no matching item, this item will be hidden unless you explicitly show it with `visible:
    // true`.
    Layout::Updatemenus::Updatemenu& templateitemname(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Updatemenus::Updatemenu& templateitemname(Callable&& c);

    // Determines whether the buttons are accessible via a dropdown menu or whether the buttons are stacked horizontally
    // or vertically
    // - Default: dropdown
    Layout::Updatemenus::Updatemenu& type(enum Type f);

    // Determines whether or not the update menu is visible.
    Layout::Updatemenus::Updatemenu& visible(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Updatemenus::Updatemenu& visible(Callable&& c);

    // Sets the x position (in normalized coordinates) of the update menu.
    Layout::Updatemenus::Updatemenu& x(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Updatemenus::Updatemenu& x(Callable&& c);

    // Sets the update menu's horizontal position anchor. This anchor binds the `x` position to the *left*, *center* or
    // *right* of the range selector.
    // - Default: right
    Layout::Updatemenus::Updatemenu& xanchor(enum Xanchor f);

    // Sets the y position (in normalized coordinates) of the update menu.
    Layout::Updatemenus::Updatemenu& y(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Updatemenus::Updatemenu& y(Callable&& c);

    // Sets the update menu's vertical position anchor This anchor binds the `y` position to the *top*, *middle* or
    // *bottom* of the range selector.
    // - Default: top
    Layout::Updatemenus::Updatemenu& yanchor(enum Yanchor f);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Updatemenus::Updatemenu::Buttons {
 public:
    Buttons() = default;
    Buttons(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    class Button;

    Layout::Updatemenus::Updatemenu::Buttons& button(Button f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Button&>>>
    Layout::Updatemenus::Updatemenu::Buttons& button(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Updatemenus::Updatemenu::Buttons::Button {
 public:
    Button() = default;
    Button(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Method {
        Restyle,
        Relayout,
        Animate,
        Update,
        Skip,
    };
    static std::string to_string(Method e);

    // Sets the arguments values to be passed to the Plotly method set in `method` on click.
    Layout::Updatemenus::Updatemenu::Buttons::Button& args(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Updatemenus::Updatemenu::Buttons::Button& args(Callable&& c);

    // Sets a 2nd set of `args`, these arguments values are passed to the Plotly method set in `method` when clicking
    // this button while in the active state. Use this to create toggle buttons.
    Layout::Updatemenus::Updatemenu::Buttons::Button& args2(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Updatemenus::Updatemenu::Buttons::Button& args2(Callable&& c);

    // When true, the API method is executed. When false, all other behaviors are the same and command execution is
    // skipped. This may be useful when hooking into, for example, the `plotly_buttonclicked` method and executing the
    // API command manually without losing the benefit of the updatemenu automatically binding to the state of the plot
    // through the specification of `method` and `args`.
    Layout::Updatemenus::Updatemenu::Buttons::Button& execute(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Updatemenus::Updatemenu::Buttons::Button& execute(Callable&& c);

    // Sets the text label to appear on the button.
    Layout::Updatemenus::Updatemenu::Buttons::Button& label(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Updatemenus::Updatemenu::Buttons::Button& label(Callable&& c);

    // Sets the Plotly method to be called on click. If the `skip` method is used, the API updatemenu will function as
    // normal but will perform no API calls and will not bind automatically to state updates. This may be used to create
    // a component interface and attach to updatemenu events manually via JavaScript.
    // - Default: restyle
    Layout::Updatemenus::Updatemenu::Buttons::Button& method(enum Method f);

    // When used in a template, named items are created in the output figure in addition to any items the figure already
    // has in this array. You can modify these items in the output figure by making your own item with
    // `templateitemname` matching this `name` alongside your modifications (including `visible: false` or `enabled:
    // false` to hide it). Has no effect outside of a template.
    Layout::Updatemenus::Updatemenu::Buttons::Button& name(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Updatemenus::Updatemenu::Buttons::Button& name(Callable&& c);

    // Used to refer to a named item in this array in the template. Named items from the template will be created even
    // without a matching item in the input figure, but you can modify one by making an item with `templateitemname`
    // matching its `name`, alongside your modifications (including `visible: false` or `enabled: false` to hide it). If
    // there is no template or no matching item, this item will be hidden unless you explicitly show it with `visible:
    // true`.
    Layout::Updatemenus::Updatemenu::Buttons::Button& templateitemname(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Updatemenus::Updatemenu::Buttons::Button& templateitemname(Callable&& c);

    // Determines whether or not this button is visible.
    Layout::Updatemenus::Updatemenu::Buttons::Button& visible(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Updatemenus::Updatemenu::Buttons::Button& visible(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets the font of the update menu button text.
class Layout::Updatemenus::Updatemenu::Font {
 public:
    Font() = default;
    Font(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    enum class Textcase {
        Normal,
        WordCaps,
        Upper,
        Lower,
    };
    static std::string to_string(Textcase e);

    enum class Variant {
        Normal,
        SmallCaps,
        AllSmallCaps,
        AllPetiteCaps,
        PetiteCaps,
        Unicase,
    };
    static std::string to_string(Variant e);

    Layout::Updatemenus::Updatemenu::Font& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Updatemenus::Updatemenu::Font& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Updatemenus::Updatemenu::Font& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Updatemenus::Updatemenu::Font& family(Callable&& c);

    // Sets the kind of decoration line(s) with text, such as an *under*, *over* or *through* as well as combinations
    // e.g. *under+over*, etc.
    // - Default: none
    // - Flags: ['under', 'over', 'through']
    // - Extras ['none']
    Layout::Updatemenus::Updatemenu::Font& lineposition(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Updatemenus::Updatemenu::Font& lineposition(Callable&& c);

    // Sets the shape and color of the shadow behind text. *auto* places minimal shadow and applies contrast text font
    // color. See https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow for additional options.
    Layout::Updatemenus::Updatemenu::Font& shadow(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Updatemenus::Updatemenu::Font& shadow(Callable&& c);

    Layout::Updatemenus::Updatemenu::Font& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Updatemenus::Updatemenu::Font& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Updatemenus::Updatemenu::Font& style(enum Style f);

    // Sets capitalization of text. It can be used to make text appear in all-uppercase or all-lowercase, or with each
    // word capitalized.
    // - Default: normal
    Layout::Updatemenus::Updatemenu::Font& textcase(enum Textcase f);

    // Sets the variant of the font.
    // - Default: normal
    Layout::Updatemenus::Updatemenu::Font& variant(enum Variant f);

    // Sets the weight (or boldness) of the font.
    Layout::Updatemenus::Updatemenu::Font& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Updatemenus::Updatemenu::Font& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets the padding around the buttons or dropdown menu.
class Layout::Updatemenus::Updatemenu::Pad {
 public:
    Pad() = default;
    Pad(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // The amount of padding (in px) along the bottom of the component.
    Layout::Updatemenus::Updatemenu::Pad& b(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Updatemenus::Updatemenu::Pad& b(Callable&& c);

    // The amount of padding (in px) on the left side of the component.
    Layout::Updatemenus::Updatemenu::Pad& l(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Updatemenus::Updatemenu::Pad& l(Callable&& c);

    // The amount of padding (in px) on the right side of the component.
    Layout::Updatemenus::Updatemenu::Pad& r(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Updatemenus::Updatemenu::Pad& r(Callable&& c);

    // The amount of padding (in px) along the top of the component.
    Layout::Updatemenus::Updatemenu::Pad& t(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Updatemenus::Updatemenu::Pad& t(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Xaxis {
 public:
    Xaxis() = default;
    Xaxis(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Autorange {
        True,
        False,
        Reversed,
        MinReversed,
        MaxReversed,
        Min,
        Max,
    };
    static std::string to_string(Autorange e);

    enum class Autotypenumbers {
        ConvertTypes,
        Strict,
    };
    static std::string to_string(Autotypenumbers e);

    enum class Calendar {
        Chinese,
        Coptic,
        Discworld,
        Ethiopian,
        Gregorian,
        Hebrew,
        Islamic,
        Jalali,
        Julian,
        Mayan,
        Nanakshahi,
        Nepali,
        Persian,
        Taiwan,
        Thai,
        Ummalqura,
    };
    static std::string to_string(Calendar e);

    enum class Categoryorder {
        Trace,
        CategoryAscending,
        CategoryDescending,
        Array,
        TotalAscending,
        TotalDescending,
        MinAscending,
        MinDescending,
        MaxAscending,
        MaxDescending,
        SumAscending,
        SumDescending,
        MeanAscending,
        MeanDescending,
        GeometricMeanAscending,
        GeometricMeanDescending,
        MedianAscending,
        MedianDescending,
    };
    static std::string to_string(Categoryorder e);

    enum class Constrain {
        Range,
        Domain,
    };
    static std::string to_string(Constrain e);

    enum class Constraintoward {
        Left,
        Center,
        Right,
        Top,
        Middle,
        Bottom,
    };
    static std::string to_string(Constraintoward e);

    enum class Exponentformat {
        None,
        E,
        Power,
        Si,
        B,
    };
    static std::string to_string(Exponentformat e);

    enum class Layer {
        AboveTraces,
        BelowTraces,
    };
    static std::string to_string(Layer e);

    enum class Mirror {
        True,
        Ticks,
        False,
        All,
        Allticks,
    };
    static std::string to_string(Mirror e);

    enum class Rangemode {
        Normal,
        Tozero,
        Nonnegative,
    };
    static std::string to_string(Rangemode e);

    enum class Showexponent {
        All,
        First,
        Last,
        None,
    };
    static std::string to_string(Showexponent e);

    enum class Showtickprefix {
        All,
        First,
        Last,
        None,
    };
    static std::string to_string(Showtickprefix e);

    enum class Showticksuffix {
        All,
        First,
        Last,
        None,
    };
    static std::string to_string(Showticksuffix e);

    enum class Side {
        Top,
        Bottom,
        Left,
        Right,
    };
    static std::string to_string(Side e);

    enum class Spikesnap {
        Data,
        Cursor,
        HoveredData,
    };
    static std::string to_string(Spikesnap e);

    enum class Ticklabelmode {
        Instant,
        Period,
    };
    static std::string to_string(Ticklabelmode e);

    enum class Ticklabeloverflow {
        Allow,
        HidePastDiv,
        HidePastDomain,
    };
    static std::string to_string(Ticklabeloverflow e);

    enum class Ticklabelposition {
        Outside,
        Inside,
        OutsideTop,
        InsideTop,
        OutsideLeft,
        InsideLeft,
        OutsideRight,
        InsideRight,
        OutsideBottom,
        InsideBottom,
    };
    static std::string to_string(Ticklabelposition e);

    enum class Tickmode {
        Auto,
        Linear,
        Array,
        Sync,
    };
    static std::string to_string(Tickmode e);

    enum class Ticks {
        Outside,
        Inside,
        Empty,
    };
    static std::string to_string(Ticks e);

    enum class Tickson {
        Labels,
        Boundaries,
    };
    static std::string to_string(Tickson e);

    enum class Type {
        Hyphen,
        Linear,
        Log,
        Date,
        Category,
        Multicategory,
    };
    static std::string to_string(Type e);

    class Autorangeoptions;
    class Minor;
    class Rangebreaks;
    class Rangeselector;
    class Rangeslider;
    // Sets the tick font.
    class Tickfont;
    class Tickformatstops;
    class Title;

    // If set to an opposite-letter axis id (e.g. `x2`, `y`), this axis is bound to the corresponding opposite-letter
    // axis. If set to *free*, this axis' position is determined by `position`.
    Layout::Xaxis& anchor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis& anchor(Callable&& c);

    // Determines whether long tick labels automatically grow the figure margins.
    // - Default: False
    // - Flags: ['height', 'width', 'left', 'right', 'top', 'bottom']
    // - Extras [True, False]
    Layout::Xaxis& automargin(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis& automargin(Callable&& c);

    // Determines whether or not the range of this axis is computed in relation to the input data. See `rangemode` for
    // more info. If `range` is provided and it has a value for both the lower and upper bound, `autorange` is set to
    // *false*. Using *min* applies autorange only to set the minimum. Using *max* applies autorange only to set the
    // maximum. Using *min reversed* applies autorange only to set the minimum on a reversed axis. Using *max reversed*
    // applies autorange only to set the maximum on a reversed axis. Using *reversed* applies autorange on both ends and
    // reverses the axis direction.
    // - Default: True
    Layout::Xaxis& autorange(enum Autorange f);

    Layout::Xaxis& autorangeoptions(Autorangeoptions f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Autorangeoptions&>>>
    Layout::Xaxis& autorangeoptions(Callable&& c);

    // When `tickangle` is set to *auto*, it will be set to the first angle in this array that is large enough to
    // prevent label overlap.
    Layout::Xaxis& autotickangles(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Xaxis& autotickangles(Callable&& c);

    // Using *strict* a numeric string in trace data is not converted to a number. Using *convert types* a numeric
    // string in trace data may be treated as a number during automatic axis `type` detection. Defaults to
    // layout.autotypenumbers.
    // - Default: convert types
    Layout::Xaxis& autotypenumbers(enum Autotypenumbers f);

    // Sets the calendar system to use for `range` and `tick0` if this is a date axis. This does not set the calendar
    // for interpreting data on this axis, that's specified in the trace or via the global `layout.calendar`
    // - Default: gregorian
    Layout::Xaxis& calendar(enum Calendar f);

    // Sets the order in which categories on this axis appear. Only has an effect if `categoryorder` is set to *array*.
    // Used with `categoryorder`.
    template <typename T, typename = std::enable_if_t<is_data_array_element_v<T>>>
    Layout::Xaxis& categoryarray(const std::vector<T>& f);
    template <
        typename T, typename Callable,
        typename = std::enable_if_t<is_data_array_element_v<T> && (std::is_invocable_v<Callable, std::vector<T>&>)>>
    Layout::Xaxis& categoryarray(Callable&& c);

    // Sets the source reference on Chart Studio Cloud for `categoryarray`.
    Layout::Xaxis& categoryarraysrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis& categoryarraysrc(Callable&& c);

    // Specifies the ordering logic for the case of categorical variables. By default, plotly uses *trace*, which
    // specifies the order that is present in the data supplied. Set `categoryorder` to *category ascending* or
    // *category descending* if order should be determined by the alphanumerical order of the category names. Set
    // `categoryorder` to *array* to derive the ordering from the attribute `categoryarray`. If a category is not found
    // in the `categoryarray` array, the sorting behavior for that attribute will be identical to the *trace* mode. The
    // unspecified categories will follow the categories in `categoryarray`. Set `categoryorder` to *total ascending* or
    // *total descending* if order should be determined by the numerical order of the values. Similarly, the order can
    // be determined by the min, max, sum, mean, geometric mean or median of all the values.
    // - Default: trace
    Layout::Xaxis& categoryorder(enum Categoryorder f);

    // Sets default for all colors associated with this axis all at once: line, font, tick, and grid colors. Grid color
    // is lightened by blending this with the plot background Individual pieces can override this.
    Layout::Xaxis& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis& color(Callable&& c);

    // If this axis needs to be compressed (either due to its own `scaleanchor` and `scaleratio` or those of the other
    // axis), determines how that happens: by increasing the *range*, or by decreasing the *domain*. Default is *domain*
    // for axes containing image traces, *range* otherwise.
    Layout::Xaxis& constrain(enum Constrain f);

    // If this axis needs to be compressed (either due to its own `scaleanchor` and `scaleratio` or those of the other
    // axis), determines which direction we push the originally specified plot area. Options are *left*, *center*
    // (default), and *right* for x axes, and *top*, *middle* (default), and *bottom* for y axes.
    Layout::Xaxis& constraintoward(enum Constraintoward f);

    // Sets the color of the dividers Only has an effect on *multicategory* axes.
    Layout::Xaxis& dividercolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis& dividercolor(Callable&& c);

    // Sets the width (in px) of the dividers Only has an effect on *multicategory* axes.
    Layout::Xaxis& dividerwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Xaxis& dividerwidth(Callable&& c);

    // Sets the domain of this axis (in plot fraction).
    Layout::Xaxis& domain(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Xaxis& domain(Callable&& c);

    // Sets the step in-between ticks on this axis. Use with `tick0`. Must be a positive number, or special strings
    // available to *log* and *date* axes. If the axis `type` is *log*, then ticks are set every 10^(n*dtick) where n is
    // the tick number. For example, to set a tick mark at 1, 10, 100, 1000, ... set dtick to 1. To set tick marks at 1,
    // 100, 10000, ... set dtick to 2. To set tick marks at 1, 5, 25, 125, 625, 3125, ... set dtick to log_10(5), or
    // 0.69897000433. *log* has several special values; *L<f>*, where `f` is a positive number, gives ticks linearly
    // spaced in value (but not position). For example `tick0` = 0.1, `dtick` = *L0.5* will put ticks at 0.1,
    // 0.6, 1.1, 1.6 etc. To show powers of 10 plus small digits between, use *D1* (all digits) or *D2* (only 2 and 5).
    // `tick0` is ignored for *D1* and *D2*. If the axis `type` is *date*, then you must convert the time to
    // milliseconds. For example, to set the interval between ticks to one day, set `dtick` to 86400000.0. *date* also
    // has special values *M<n>* gives ticks spaced by a number of months. `n` must be a positive integer. To set ticks
    // on the 15th of every third month, set `tick0` to *2000-01-15* and `dtick` to *M3*. To set ticks every 4 years,
    // set `dtick` to *M48*
    template <typename T>
    Layout::Xaxis& dtick(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Xaxis& dtick(Callable&& c);

    // Determines a formatting rule for the tick exponents. For example, consider the number 1,000,000,000. If *none*,
    // it appears as 1,000,000,000. If *e*, 1e+9. If *E*, 1E+9. If *power*, 1x10^9 (with 9 in a super script). If *SI*,
    // 1G. If *B*, 1B.
    // - Default: B
    Layout::Xaxis& exponentformat(enum Exponentformat f);

    // Determines whether or not this axis is zoom-able. If true, then zoom is disabled.
    Layout::Xaxis& fixedrange(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Xaxis& fixedrange(Callable&& c);

    // Sets the color of the grid lines.
    Layout::Xaxis& gridcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis& gridcolor(Callable&& c);

    // Sets the dash style of lines. Set to a dash type string (*solid*, *dot*, *dash*, *longdash*, *dashdot*, or
    // *longdashdot*) or a dash length list in px (eg *5px,10px,2px,2px*).
    Layout::Xaxis& griddash(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis& griddash(Callable&& c);

    // Sets the width (in px) of the grid lines.
    Layout::Xaxis& gridwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Xaxis& gridwidth(Callable&& c);

    // Sets the hover text formatting rule using d3 formatting mini-languages which are very similar to those in Python.
    // For numbers, see: https://github.com/d3/d3-format/tree/v1.4.5#d3-format. And for dates see:
    // https://github.com/d3/d3-time-format/tree/v2.2.3#locale_format. We add two items to d3's date formatter: *%h* for
    // half of the year as a decimal number as well as *%{n}f* for fractional seconds with n digits. For example,
    // *2016-10-13 09:15:23.456* with tickformat *%H~%M~%S.%2f* would display *09~15~23.46*
    Layout::Xaxis& hoverformat(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis& hoverformat(Callable&& c);

    // Could be used to set the desired inside range of this axis (excluding the labels) when `ticklabelposition` of the
    // anchored axis has *inside*. Not implemented for axes with `type` *log*. This would be ignored when `range` is
    // provided.
    Layout::Xaxis& insiderange(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Xaxis& insiderange(Callable&& c);

    // Replacement text for specific tick or hover labels. For example using {US: 'USA', CA: 'Canada'} changes US to USA
    // and CA to Canada. The labels we would have shown must match the keys exactly, after adding any tickprefix or
    // ticksuffix. For negative numbers the minus sign symbol used (U+2212) is wider than the regular ascii dash. That
    // means you need to use 1 instead of -1. labelalias can be used with any axis type, and both keys (if needed) and
    // values (if desired) can include html-like tags or MathJax.
    template <typename T>
    Layout::Xaxis& labelalias(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Xaxis& labelalias(Callable&& c);

    // Sets the layer on which this axis is displayed. If *above traces*, this axis is displayed above all the subplot's
    // traces If *below traces*, this axis is displayed below all the subplot's traces, but above the grid lines. Useful
    // when used together with scatter-like traces with `cliponaxis` set to *false* to show markers and/or text nodes
    // above this axis.
    // - Default: above traces
    Layout::Xaxis& layer(enum Layer f);

    // Sets the axis line color.
    Layout::Xaxis& linecolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis& linecolor(Callable&& c);

    // Sets the width (in px) of the axis line.
    Layout::Xaxis& linewidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Xaxis& linewidth(Callable&& c);

    // If set to another axis id (e.g. `x2`, `y`), the range of this axis will match the range of the corresponding axis
    // in data-coordinates space. Moreover, matching axes share auto-range values, category lists and histogram
    // auto-bins. Note that setting axes simultaneously in both a `scaleanchor` and a `matches` constraint is currently
    // forbidden. Moreover, note that matching axes must have the same `type`.
    Layout::Xaxis& matches(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis& matches(Callable&& c);

    // Determines the maximum range of this axis.
    template <typename T>
    Layout::Xaxis& maxallowed(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Xaxis& maxallowed(Callable&& c);

    // Determines the minimum range of this axis.
    template <typename T>
    Layout::Xaxis& minallowed(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Xaxis& minallowed(Callable&& c);

    // Hide SI prefix for 10^n if |n| is below this number. This only has an effect when `tickformat` is *SI* or *B*.
    Layout::Xaxis& minexponent(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Xaxis& minexponent(Callable&& c);

    Layout::Xaxis& minor(Minor f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Minor&>>>
    Layout::Xaxis& minor(Callable&& c);

    // Determines if the axis lines or/and ticks are mirrored to the opposite side of the plotting area. If *true*, the
    // axis lines are mirrored. If *ticks*, the axis lines and ticks are mirrored. If *false*, mirroring is disable. If
    // *all*, axis lines are mirrored on all shared-axes subplots. If *allticks*, axis lines and ticks are mirrored on
    // all shared-axes subplots.
    // - Default: False
    Layout::Xaxis& mirror(enum Mirror f);

    // Specifies the maximum number of ticks for the particular axis. The actual number of ticks will be chosen
    // automatically to be less than or equal to `nticks`. Has an effect only if `tickmode` is set to *auto*.
    Layout::Xaxis& nticks(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Xaxis& nticks(Callable&& c);

    // If set a same-letter axis id, this axis is overlaid on top of the corresponding same-letter axis, with traces and
    // axes visible for both axes. If *false*, this axis does not overlay any same-letter axes. In this case, for axes
    // with overlapping domains only the highest-numbered axis will be visible.
    Layout::Xaxis& overlaying(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis& overlaying(Callable&& c);

    // Sets the position of this axis in the plotting space (in normalized coordinates). Only has an effect if `anchor`
    // is set to *free*.
    Layout::Xaxis& position(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Xaxis& position(Callable&& c);

    // Sets the range of this axis. If the axis `type` is *log*, then you must take the log of your desired range (e.g.
    // to set the range from 1 to 100, set the range from 0 to 2). If the axis `type` is *date*, it should be date
    // strings, like date data, though Date objects and unix milliseconds will be accepted and converted to strings. If
    // the axis `type` is *category*, it should be numbers, using the scale where each category is assigned a serial
    // number from zero in the order it appears. Leaving either or both elements `null` impacts the default `autorange`.
    Layout::Xaxis& range(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Xaxis& range(Callable&& c);

    Layout::Xaxis& rangebreaks(Rangebreaks f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Rangebreaks&>>>
    Layout::Xaxis& rangebreaks(Callable&& c);

    // If *normal*, the range is computed in relation to the extrema of the input data. If *tozero*`, the range extends
    // to 0, regardless of the input data If *nonnegative*, the range is non-negative, regardless of the input data.
    // Applies only to linear axes.
    // - Default: normal
    Layout::Xaxis& rangemode(enum Rangemode f);

    Layout::Xaxis& rangeselector(Rangeselector f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Rangeselector&>>>
    Layout::Xaxis& rangeselector(Callable&& c);

    Layout::Xaxis& rangeslider(Rangeslider f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Rangeslider&>>>
    Layout::Xaxis& rangeslider(Callable&& c);

    // If set to another axis id (e.g. `x2`, `y`), the range of this axis changes together with the range of the
    // corresponding axis such that the scale of pixels per unit is in a constant ratio. Both axes are still zoomable,
    // but when you zoom one, the other will zoom the same amount, keeping a fixed midpoint. `constrain` and
    // `constraintoward` determine how we enforce the constraint. You can chain these, ie `yaxis: {scaleanchor: *x*},
    // xaxis2: {scaleanchor: *y*}` but you can only link axes of the same `type`. The linked axis can have the opposite
    // letter (to constrain the aspect ratio) or the same letter (to match scales across subplots). Loops (`yaxis:
    // {scaleanchor: *x*}, xaxis: {scaleanchor: *y*}` or longer) are redundant and the last constraint encountered will
    // be ignored to avoid possible inconsistent constraints via `scaleratio`. Note that setting axes simultaneously in
    // both a `scaleanchor` and a `matches` constraint is currently forbidden. Setting `false` allows to remove a
    // default constraint (occasionally, you may need to prevent a default `scaleanchor` constraint from being applied,
    // eg. when having an image trace `yaxis: {scaleanchor: "x"}` is set automatically in order for pixels to be
    // rendered as squares, setting `yaxis: {scaleanchor: false}` allows to remove the constraint).
    Layout::Xaxis& scaleanchor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis& scaleanchor(Callable&& c);

    // If this axis is linked to another by `scaleanchor`, this determines the pixel to unit scale ratio. For example,
    // if this value is 10, then every unit on this axis spans 10 times the number of pixels as a unit on the linked
    // axis. Use this for example to create an elevation profile where the vertical scale is exaggerated a fixed amount
    // with respect to the horizontal.
    Layout::Xaxis& scaleratio(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Xaxis& scaleratio(Callable&& c);

    // If "true", even 4-digit integers are separated
    Layout::Xaxis& separatethousands(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Xaxis& separatethousands(Callable&& c);

    // Determines whether or not a dividers are drawn between the category levels of this axis. Only has an effect on
    // *multicategory* axes.
    Layout::Xaxis& showdividers(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Xaxis& showdividers(Callable&& c);

    // If *all*, all exponents are shown besides their significands. If *first*, only the exponent of the first tick is
    // shown. If *last*, only the exponent of the last tick is shown. If *none*, no exponents appear.
    // - Default: all
    Layout::Xaxis& showexponent(enum Showexponent f);

    // Determines whether or not grid lines are drawn. If *true*, the grid lines are drawn at every tick mark.
    Layout::Xaxis& showgrid(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Xaxis& showgrid(Callable&& c);

    // Determines whether or not a line bounding this axis is drawn.
    Layout::Xaxis& showline(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Xaxis& showline(Callable&& c);

    // Determines whether or not spikes (aka droplines) are drawn for this axis. Note: This only takes affect when
    // hovermode = closest
    Layout::Xaxis& showspikes(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Xaxis& showspikes(Callable&& c);

    // Determines whether or not the tick labels are drawn.
    Layout::Xaxis& showticklabels(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Xaxis& showticklabels(Callable&& c);

    // If *all*, all tick labels are displayed with a prefix. If *first*, only the first tick is displayed with a
    // prefix. If *last*, only the last tick is displayed with a suffix. If *none*, tick prefixes are hidden.
    // - Default: all
    Layout::Xaxis& showtickprefix(enum Showtickprefix f);

    // Same as `showtickprefix` but for tick suffixes.
    // - Default: all
    Layout::Xaxis& showticksuffix(enum Showticksuffix f);

    // Determines whether a x (y) axis is positioned at the *bottom* (*left*) or *top* (*right*) of the plotting area.
    Layout::Xaxis& side(enum Side f);

    // Sets the spike color. If undefined, will use the series color
    Layout::Xaxis& spikecolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis& spikecolor(Callable&& c);

    // Sets the dash style of lines. Set to a dash type string (*solid*, *dot*, *dash*, *longdash*, *dashdot*, or
    // *longdashdot*) or a dash length list in px (eg *5px,10px,2px,2px*).
    Layout::Xaxis& spikedash(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis& spikedash(Callable&& c);

    // Determines the drawing mode for the spike line If *toaxis*, the line is drawn from the data point to the axis the
    // series is plotted on. If *across*, the line is drawn across the entire plot area, and supercedes *toaxis*. If
    // *marker*, then a marker dot is drawn on the axis the series is plotted on
    // - Default: toaxis
    // - Flags: ['toaxis', 'across', 'marker']
    Layout::Xaxis& spikemode(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis& spikemode(Callable&& c);

    // Determines whether spikelines are stuck to the cursor or to the closest datapoints.
    // - Default: hovered data
    Layout::Xaxis& spikesnap(enum Spikesnap f);

    // Sets the width (in px) of the zero line.
    Layout::Xaxis& spikethickness(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Xaxis& spikethickness(Callable&& c);

    // Sets the placement of the first tick on this axis. Use with `dtick`. If the axis `type` is *log*, then you must
    // take the log of your starting tick (e.g. to set the starting tick to 100, set the `tick0` to 2) except when
    // `dtick`=*L<f>* (see `dtick` for more info). If the axis `type` is *date*, it should be a date string, like date
    // data. If the axis `type` is *category*, it should be a number, using the scale where each category is assigned a
    // serial number from zero in the order it appears.
    template <typename T>
    Layout::Xaxis& tick0(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Xaxis& tick0(Callable&& c);

    // Sets the angle of the tick labels with respect to the horizontal. For example, a `tickangle` of -90 draws the
    // tick labels vertically.
    Layout::Xaxis& tickangle(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Xaxis& tickangle(Callable&& c);

    // Sets the tick color.
    Layout::Xaxis& tickcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis& tickcolor(Callable&& c);

    // Sets the tick font.
    Layout::Xaxis& tickfont(Tickfont f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Tickfont&>>>
    Layout::Xaxis& tickfont(Callable&& c);

    // Sets the tick label formatting rule using d3 formatting mini-languages which are very similar to those in Python.
    // For numbers, see: https://github.com/d3/d3-format/tree/v1.4.5#d3-format. And for dates see:
    // https://github.com/d3/d3-time-format/tree/v2.2.3#locale_format. We add two items to d3's date formatter: *%h* for
    // half of the year as a decimal number as well as *%{n}f* for fractional seconds with n digits. For example,
    // *2016-10-13 09:15:23.456* with tickformat *%H~%M~%S.%2f* would display *09~15~23.46*
    Layout::Xaxis& tickformat(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis& tickformat(Callable&& c);

    Layout::Xaxis& tickformatstops(Tickformatstops f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Tickformatstops&>>>
    Layout::Xaxis& tickformatstops(Callable&& c);

    // Only for axes with `type` *date* or *linear*. Instead of drawing the major tick label, draw the label for the
    // minor tick that is n positions away from the major tick. E.g. to always draw the label for the minor tick before
    // each major tick, choose `ticklabelindex` -1. This is useful for date axes with `ticklabelmode` *period* if you
    // want to label the period that ends with each major tick instead of the period that begins there.
    Layout::Xaxis& ticklabelindex(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Xaxis& ticklabelindex(Callable&& c);
    Layout::Xaxis& ticklabelindex(const std::vector<int>& f);

    // Sets the source reference on Chart Studio Cloud for `ticklabelindex`.
    Layout::Xaxis& ticklabelindexsrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis& ticklabelindexsrc(Callable&& c);

    // Determines where tick labels are drawn with respect to their corresponding ticks and grid lines. Only has an
    // effect for axes of `type` *date* When set to *period*, tick labels are drawn in the middle of the period between
    // ticks.
    // - Default: instant
    Layout::Xaxis& ticklabelmode(enum Ticklabelmode f);

    // Determines how we handle tick labels that would overflow either the graph div or the domain of the axis. The
    // default value for inside tick labels is *hide past domain*. Otherwise on *category* and *multicategory* axes the
    // default is *allow*. In other cases the default is *hide past div*.
    Layout::Xaxis& ticklabeloverflow(enum Ticklabeloverflow f);

    // Determines where tick labels are drawn with respect to the axis Please note that top or bottom has no effect on x
    // axes or when `ticklabelmode` is set to *period*. Similarly left or right has no effect on y axes or when
    // `ticklabelmode` is set to *period*. Has no effect on *multicategory* axes or when `tickson` is set to
    // *boundaries*. When used on axes linked by `matches` or `scaleanchor`, no extra padding for inside labels would be
    // added by autorange, so that the scales could match.
    // - Default: outside
    Layout::Xaxis& ticklabelposition(enum Ticklabelposition f);

    // Shifts the tick labels by the specified number of pixels in parallel to the axis. Positive values move the labels
    // in the positive direction of the axis.
    Layout::Xaxis& ticklabelshift(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Xaxis& ticklabelshift(Callable&& c);

    // Sets the standoff distance (in px) between the axis tick labels and their default position. A positive
    // `ticklabelstandoff` moves the labels farther away from the plot area if `ticklabelposition` is *outside*, and
    // deeper into the plot area if `ticklabelposition` is *inside*. A negative `ticklabelstandoff` works in the
    // opposite direction, moving outside ticks towards the plot area and inside ticks towards the outside. If the
    // negative value is large enough, inside ticks can even end up outside and vice versa.
    Layout::Xaxis& ticklabelstandoff(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Xaxis& ticklabelstandoff(Callable&& c);

    // Sets the spacing between tick labels as compared to the spacing between ticks. A value of 1 (default) means each
    // tick gets a label. A value of 2 means shows every 2nd label. A larger value n means only every nth tick is
    // labeled. `tick0` determines which labels are shown. Not implemented for axes with `type` *log* or
    // *multicategory*, or when `tickmode` is *array*.
    Layout::Xaxis& ticklabelstep(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Xaxis& ticklabelstep(Callable&& c);

    // Sets the tick length (in px).
    Layout::Xaxis& ticklen(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Xaxis& ticklen(Callable&& c);

    // Sets the tick mode for this axis. If *auto*, the number of ticks is set via `nticks`. If *linear*, the placement
    // of the ticks is determined by a starting position `tick0` and a tick step `dtick` (*linear* is the default value
    // if `tick0` and `dtick` are provided). If *array*, the placement of the ticks is set via `tickvals` and the tick
    // text is `ticktext`. (*array* is the default value if `tickvals` is provided). If *sync*, the number of ticks will
    // sync with the overlayed axis set by `overlaying` property.
    Layout::Xaxis& tickmode(enum Tickmode f);

    // Sets a tick label prefix.
    Layout::Xaxis& tickprefix(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis& tickprefix(Callable&& c);

    // Determines whether ticks are drawn or not. If **, this axis' ticks are not drawn. If *outside* (*inside*), this
    // axis' are drawn outside (inside) the axis lines.
    Layout::Xaxis& ticks(enum Ticks f);

    // Determines where ticks and grid lines are drawn with respect to their corresponding tick labels. Only has an
    // effect for axes of `type` *category* or *multicategory*. When set to *boundaries*, ticks and grid lines are drawn
    // half a category to the left/bottom of labels.
    // - Default: labels
    Layout::Xaxis& tickson(enum Tickson f);

    // Sets a tick label suffix.
    Layout::Xaxis& ticksuffix(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis& ticksuffix(Callable&& c);

    // Sets the text displayed at the ticks position via `tickvals`. Only has an effect if `tickmode` is set to *array*.
    // Used with `tickvals`.
    template <typename T, typename = std::enable_if_t<is_data_array_element_v<T>>>
    Layout::Xaxis& ticktext(const std::vector<T>& f);
    template <
        typename T, typename Callable,
        typename = std::enable_if_t<is_data_array_element_v<T> && (std::is_invocable_v<Callable, std::vector<T>&>)>>
    Layout::Xaxis& ticktext(Callable&& c);

    // Sets the source reference on Chart Studio Cloud for `ticktext`.
    Layout::Xaxis& ticktextsrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis& ticktextsrc(Callable&& c);

    // Sets the values at which ticks on this axis appear. Only has an effect if `tickmode` is set to *array*. Used with
    // `ticktext`.
    template <typename T, typename = std::enable_if_t<is_data_array_element_v<T>>>
    Layout::Xaxis& tickvals(const std::vector<T>& f);
    template <
        typename T, typename Callable,
        typename = std::enable_if_t<is_data_array_element_v<T> && (std::is_invocable_v<Callable, std::vector<T>&>)>>
    Layout::Xaxis& tickvals(Callable&& c);

    // Sets the source reference on Chart Studio Cloud for `tickvals`.
    Layout::Xaxis& tickvalssrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis& tickvalssrc(Callable&& c);

    // Sets the tick width (in px).
    Layout::Xaxis& tickwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Xaxis& tickwidth(Callable&& c);

    Layout::Xaxis& title(Title f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Title&>>>
    Layout::Xaxis& title(Callable&& c);

    // Sets the axis type. By default, plotly attempts to determined the axis type by looking into the data of the
    // traces that referenced the axis in question.
    // - Default: -
    Layout::Xaxis& type(enum Type f);

    // Controls persistence of user-driven changes in axis `range`, `autorange`, and `title` if in `editable: true`
    // configuration. Defaults to `layout.uirevision`.
    template <typename T>
    Layout::Xaxis& uirevision(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Xaxis& uirevision(Callable&& c);

    // A single toggle to hide the axis while preserving interaction like dragging. Default is true when a cheater plot
    // is present on the axis, otherwise false
    Layout::Xaxis& visible(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Xaxis& visible(Callable&& c);

    // Determines whether or not a line is drawn at along the 0 value of this axis. If *true*, the zero line is drawn on
    // top of the grid lines.
    Layout::Xaxis& zeroline(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Xaxis& zeroline(Callable&& c);

    // Sets the line color of the zero line.
    Layout::Xaxis& zerolinecolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis& zerolinecolor(Callable&& c);

    // Sets the width (in px) of the zero line.
    Layout::Xaxis& zerolinewidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Xaxis& zerolinewidth(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Xaxis::Autorangeoptions {
 public:
    Autorangeoptions() = default;
    Autorangeoptions(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Clip autorange maximum if it goes beyond this value. Has no effect when `autorangeoptions.maxallowed` is
    // provided.
    template <typename T>
    Layout::Xaxis::Autorangeoptions& clipmax(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Xaxis::Autorangeoptions& clipmax(Callable&& c);

    // Clip autorange minimum if it goes beyond this value. Has no effect when `autorangeoptions.minallowed` is
    // provided.
    template <typename T>
    Layout::Xaxis::Autorangeoptions& clipmin(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Xaxis::Autorangeoptions& clipmin(Callable&& c);

    // Ensure this value is included in autorange.
    template <typename T>
    Layout::Xaxis::Autorangeoptions& include(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Xaxis::Autorangeoptions& include(Callable&& c);
    template <typename T>
    Layout::Xaxis::Autorangeoptions& include(const std::vector<T>& f);

    // Sets the source reference on Chart Studio Cloud for `include`.
    Layout::Xaxis::Autorangeoptions& includesrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis::Autorangeoptions& includesrc(Callable&& c);

    // Use this value exactly as autorange maximum.
    template <typename T>
    Layout::Xaxis::Autorangeoptions& maxallowed(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Xaxis::Autorangeoptions& maxallowed(Callable&& c);

    // Use this value exactly as autorange minimum.
    template <typename T>
    Layout::Xaxis::Autorangeoptions& minallowed(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Xaxis::Autorangeoptions& minallowed(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Xaxis::Minor {
 public:
    Minor() = default;
    Minor(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Tickmode {
        Auto,
        Linear,
        Array,
    };
    static std::string to_string(Tickmode e);

    enum class Ticks {
        Outside,
        Inside,
        Empty,
    };
    static std::string to_string(Ticks e);

    // Sets the step in-between ticks on this axis. Use with `tick0`. Must be a positive number, or special strings
    // available to *log* and *date* axes. If the axis `type` is *log*, then ticks are set every 10^(n*dtick) where n is
    // the tick number. For example, to set a tick mark at 1, 10, 100, 1000, ... set dtick to 1. To set tick marks at 1,
    // 100, 10000, ... set dtick to 2. To set tick marks at 1, 5, 25, 125, 625, 3125, ... set dtick to log_10(5), or
    // 0.69897000433. *log* has several special values; *L<f>*, where `f` is a positive number, gives ticks linearly
    // spaced in value (but not position). For example `tick0` = 0.1, `dtick` = *L0.5* will put ticks at 0.1,
    // 0.6, 1.1, 1.6 etc. To show powers of 10 plus small digits between, use *D1* (all digits) or *D2* (only 2 and 5).
    // `tick0` is ignored for *D1* and *D2*. If the axis `type` is *date*, then you must convert the time to
    // milliseconds. For example, to set the interval between ticks to one day, set `dtick` to 86400000.0. *date* also
    // has special values *M<n>* gives ticks spaced by a number of months. `n` must be a positive integer. To set ticks
    // on the 15th of every third month, set `tick0` to *2000-01-15* and `dtick` to *M3*. To set ticks every 4 years,
    // set `dtick` to *M48*
    template <typename T>
    Layout::Xaxis::Minor& dtick(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Xaxis::Minor& dtick(Callable&& c);

    // Sets the color of the grid lines.
    Layout::Xaxis::Minor& gridcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis::Minor& gridcolor(Callable&& c);

    // Sets the dash style of lines. Set to a dash type string (*solid*, *dot*, *dash*, *longdash*, *dashdot*, or
    // *longdashdot*) or a dash length list in px (eg *5px,10px,2px,2px*).
    Layout::Xaxis::Minor& griddash(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis::Minor& griddash(Callable&& c);

    // Sets the width (in px) of the grid lines.
    Layout::Xaxis::Minor& gridwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Xaxis::Minor& gridwidth(Callable&& c);

    // Specifies the maximum number of ticks for the particular axis. The actual number of ticks will be chosen
    // automatically to be less than or equal to `nticks`. Has an effect only if `tickmode` is set to *auto*.
    Layout::Xaxis::Minor& nticks(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Xaxis::Minor& nticks(Callable&& c);

    // Determines whether or not grid lines are drawn. If *true*, the grid lines are drawn at every tick mark.
    Layout::Xaxis::Minor& showgrid(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Xaxis::Minor& showgrid(Callable&& c);

    // Sets the placement of the first tick on this axis. Use with `dtick`. If the axis `type` is *log*, then you must
    // take the log of your starting tick (e.g. to set the starting tick to 100, set the `tick0` to 2) except when
    // `dtick`=*L<f>* (see `dtick` for more info). If the axis `type` is *date*, it should be a date string, like date
    // data. If the axis `type` is *category*, it should be a number, using the scale where each category is assigned a
    // serial number from zero in the order it appears.
    template <typename T>
    Layout::Xaxis::Minor& tick0(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Xaxis::Minor& tick0(Callable&& c);

    // Sets the tick color.
    Layout::Xaxis::Minor& tickcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis::Minor& tickcolor(Callable&& c);

    // Sets the tick length (in px).
    Layout::Xaxis::Minor& ticklen(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Xaxis::Minor& ticklen(Callable&& c);

    // Sets the tick mode for this axis. If *auto*, the number of ticks is set via `nticks`. If *linear*, the placement
    // of the ticks is determined by a starting position `tick0` and a tick step `dtick` (*linear* is the default value
    // if `tick0` and `dtick` are provided). If *array*, the placement of the ticks is set via `tickvals` and the tick
    // text is `ticktext`. (*array* is the default value if `tickvals` is provided).
    Layout::Xaxis::Minor& tickmode(enum Tickmode f);

    // Determines whether ticks are drawn or not. If **, this axis' ticks are not drawn. If *outside* (*inside*), this
    // axis' are drawn outside (inside) the axis lines.
    Layout::Xaxis::Minor& ticks(enum Ticks f);

    // Sets the values at which ticks on this axis appear. Only has an effect if `tickmode` is set to *array*. Used with
    // `ticktext`.
    template <typename T, typename = std::enable_if_t<is_data_array_element_v<T>>>
    Layout::Xaxis::Minor& tickvals(const std::vector<T>& f);
    template <
        typename T, typename Callable,
        typename = std::enable_if_t<is_data_array_element_v<T> && (std::is_invocable_v<Callable, std::vector<T>&>)>>
    Layout::Xaxis::Minor& tickvals(Callable&& c);

    // Sets the source reference on Chart Studio Cloud for `tickvals`.
    Layout::Xaxis::Minor& tickvalssrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis::Minor& tickvalssrc(Callable&& c);

    // Sets the tick width (in px).
    Layout::Xaxis::Minor& tickwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Xaxis::Minor& tickwidth(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Xaxis::Rangebreaks {
 public:
    Rangebreaks() = default;
    Rangebreaks(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    class Rangebreak;

    Layout::Xaxis::Rangebreaks& rangebreak(Rangebreak f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Rangebreak&>>>
    Layout::Xaxis::Rangebreaks& rangebreak(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Xaxis::Rangebreaks::Rangebreak {
 public:
    Rangebreak() = default;
    Rangebreak(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Pattern {
        DayOfWeek,
        Hour,
        Empty,
    };
    static std::string to_string(Pattern e);

    // Sets the lower and upper bounds of this axis rangebreak. Can be used with `pattern`.
    Layout::Xaxis::Rangebreaks::Rangebreak& bounds(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Xaxis::Rangebreaks::Rangebreak& bounds(Callable&& c);

    // Sets the size of each `values` item. The default is one day in milliseconds.
    Layout::Xaxis::Rangebreaks::Rangebreak& dvalue(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Xaxis::Rangebreaks::Rangebreak& dvalue(Callable&& c);

    // Determines whether this axis rangebreak is enabled or disabled. Please note that `rangebreaks` only work for
    // *date* axis type.
    Layout::Xaxis::Rangebreaks::Rangebreak& enabled(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Xaxis::Rangebreaks::Rangebreak& enabled(Callable&& c);

    // When used in a template, named items are created in the output figure in addition to any items the figure already
    // has in this array. You can modify these items in the output figure by making your own item with
    // `templateitemname` matching this `name` alongside your modifications (including `visible: false` or `enabled:
    // false` to hide it). Has no effect outside of a template.
    Layout::Xaxis::Rangebreaks::Rangebreak& name(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis::Rangebreaks::Rangebreak& name(Callable&& c);

    // Determines a pattern on the time line that generates breaks. If *day of week* - days of the week in English e.g.
    // 'Sunday' or `sun` (matching is case-insensitive and considers only the first three characters), as well as
    // Sunday-based integers between 0 and 6. If *hour* - hour (24-hour clock) as decimal numbers between 0 and 24. for
    // more info. Examples: - { pattern: 'day of week', bounds: [6, 1] }  or simply { bounds: ['sat', 'mon'] }   breaks
    // from Saturday to Monday (i.e. skips the weekends). - { pattern: 'hour', bounds: [17, 8] }   breaks from 5pm to
    // 8am (i.e. skips non-work hours).
    Layout::Xaxis::Rangebreaks::Rangebreak& pattern(enum Pattern f);

    // Used to refer to a named item in this array in the template. Named items from the template will be created even
    // without a matching item in the input figure, but you can modify one by making an item with `templateitemname`
    // matching its `name`, alongside your modifications (including `visible: false` or `enabled: false` to hide it). If
    // there is no template or no matching item, this item will be hidden unless you explicitly show it with `visible:
    // true`.
    Layout::Xaxis::Rangebreaks::Rangebreak& templateitemname(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis::Rangebreaks::Rangebreak& templateitemname(Callable&& c);

    // Sets the coordinate values corresponding to the rangebreaks. An alternative to `bounds`. Use `dvalue` to set the
    // size of the values along the axis.
    Layout::Xaxis::Rangebreaks::Rangebreak& values(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Xaxis::Rangebreaks::Rangebreak& values(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Xaxis::Rangeselector {
 public:
    Rangeselector() = default;
    Rangeselector(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Xanchor {
        Auto,
        Left,
        Center,
        Right,
    };
    static std::string to_string(Xanchor e);

    enum class Yanchor {
        Auto,
        Top,
        Middle,
        Bottom,
    };
    static std::string to_string(Yanchor e);

    class Buttons;
    // Sets the font of the range selector button text.
    class Font;

    // Sets the background color of the active range selector button.
    Layout::Xaxis::Rangeselector& activecolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis::Rangeselector& activecolor(Callable&& c);

    // Sets the background color of the range selector buttons.
    Layout::Xaxis::Rangeselector& bgcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis::Rangeselector& bgcolor(Callable&& c);

    // Sets the color of the border enclosing the range selector.
    Layout::Xaxis::Rangeselector& bordercolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis::Rangeselector& bordercolor(Callable&& c);

    // Sets the width (in px) of the border enclosing the range selector.
    Layout::Xaxis::Rangeselector& borderwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Xaxis::Rangeselector& borderwidth(Callable&& c);

    Layout::Xaxis::Rangeselector& buttons(Buttons f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Buttons&>>>
    Layout::Xaxis::Rangeselector& buttons(Callable&& c);

    // Sets the font of the range selector button text.
    Layout::Xaxis::Rangeselector& font(Font f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Font&>>>
    Layout::Xaxis::Rangeselector& font(Callable&& c);

    // Determines whether or not this range selector is visible. Note that range selectors are only available for x axes
    // of `type` set to or auto-typed to *date*.
    Layout::Xaxis::Rangeselector& visible(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Xaxis::Rangeselector& visible(Callable&& c);

    // Sets the x position (in normalized coordinates) of the range selector.
    Layout::Xaxis::Rangeselector& x(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Xaxis::Rangeselector& x(Callable&& c);

    // Sets the range selector's horizontal position anchor. This anchor binds the `x` position to the *left*, *center*
    // or *right* of the range selector.
    // - Default: left
    Layout::Xaxis::Rangeselector& xanchor(enum Xanchor f);

    // Sets the y position (in normalized coordinates) of the range selector.
    Layout::Xaxis::Rangeselector& y(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Xaxis::Rangeselector& y(Callable&& c);

    // Sets the range selector's vertical position anchor This anchor binds the `y` position to the *top*, *middle* or
    // *bottom* of the range selector.
    // - Default: bottom
    Layout::Xaxis::Rangeselector& yanchor(enum Yanchor f);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Xaxis::Rangeselector::Buttons {
 public:
    Buttons() = default;
    Buttons(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Sets the specifications for each buttons. By default, a range selector comes with no buttons.
    class Button;

    // Sets the specifications for each buttons. By default, a range selector comes with no buttons.
    Layout::Xaxis::Rangeselector::Buttons& button(Button f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Button&>>>
    Layout::Xaxis::Rangeselector::Buttons& button(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets the specifications for each buttons. By default, a range selector comes with no buttons.
class Layout::Xaxis::Rangeselector::Buttons::Button {
 public:
    Button() = default;
    Button(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Step {
        Month,
        Year,
        Day,
        Hour,
        Minute,
        Second,
        All,
    };
    static std::string to_string(Step e);

    enum class Stepmode {
        Backward,
        Todate,
    };
    static std::string to_string(Stepmode e);

    // Sets the number of steps to take to update the range. Use with `step` to specify the update interval.
    Layout::Xaxis::Rangeselector::Buttons::Button& count(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Xaxis::Rangeselector::Buttons::Button& count(Callable&& c);

    // Sets the text label to appear on the button.
    Layout::Xaxis::Rangeselector::Buttons::Button& label(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis::Rangeselector::Buttons::Button& label(Callable&& c);

    // When used in a template, named items are created in the output figure in addition to any items the figure already
    // has in this array. You can modify these items in the output figure by making your own item with
    // `templateitemname` matching this `name` alongside your modifications (including `visible: false` or `enabled:
    // false` to hide it). Has no effect outside of a template.
    Layout::Xaxis::Rangeselector::Buttons::Button& name(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis::Rangeselector::Buttons::Button& name(Callable&& c);

    // The unit of measurement that the `count` value will set the range by.
    // - Default: month
    Layout::Xaxis::Rangeselector::Buttons::Button& step(enum Step f);

    // Sets the range update mode. If *backward*, the range update shifts the start of range back *count* times *step*
    // milliseconds. If *todate*, the range update shifts the start of range back to the first timestamp from *count*
    // times *step* milliseconds back. For example, with `step` set to *year* and `count` set to *1* the range update
    // shifts the start of the range back to January 01 of the current year. Month and year *todate* are currently
    // available only for the built-in (Gregorian) calendar.
    // - Default: backward
    Layout::Xaxis::Rangeselector::Buttons::Button& stepmode(enum Stepmode f);

    // Used to refer to a named item in this array in the template. Named items from the template will be created even
    // without a matching item in the input figure, but you can modify one by making an item with `templateitemname`
    // matching its `name`, alongside your modifications (including `visible: false` or `enabled: false` to hide it). If
    // there is no template or no matching item, this item will be hidden unless you explicitly show it with `visible:
    // true`.
    Layout::Xaxis::Rangeselector::Buttons::Button& templateitemname(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis::Rangeselector::Buttons::Button& templateitemname(Callable&& c);

    // Determines whether or not this button is visible.
    Layout::Xaxis::Rangeselector::Buttons::Button& visible(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Xaxis::Rangeselector::Buttons::Button& visible(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets the font of the range selector button text.
class Layout::Xaxis::Rangeselector::Font {
 public:
    Font() = default;
    Font(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    enum class Textcase {
        Normal,
        WordCaps,
        Upper,
        Lower,
    };
    static std::string to_string(Textcase e);

    enum class Variant {
        Normal,
        SmallCaps,
        AllSmallCaps,
        AllPetiteCaps,
        PetiteCaps,
        Unicase,
    };
    static std::string to_string(Variant e);

    Layout::Xaxis::Rangeselector::Font& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis::Rangeselector::Font& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Xaxis::Rangeselector::Font& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis::Rangeselector::Font& family(Callable&& c);

    // Sets the kind of decoration line(s) with text, such as an *under*, *over* or *through* as well as combinations
    // e.g. *under+over*, etc.
    // - Default: none
    // - Flags: ['under', 'over', 'through']
    // - Extras ['none']
    Layout::Xaxis::Rangeselector::Font& lineposition(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis::Rangeselector::Font& lineposition(Callable&& c);

    // Sets the shape and color of the shadow behind text. *auto* places minimal shadow and applies contrast text font
    // color. See https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow for additional options.
    Layout::Xaxis::Rangeselector::Font& shadow(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis::Rangeselector::Font& shadow(Callable&& c);

    Layout::Xaxis::Rangeselector::Font& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Xaxis::Rangeselector::Font& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Xaxis::Rangeselector::Font& style(enum Style f);

    // Sets capitalization of text. It can be used to make text appear in all-uppercase or all-lowercase, or with each
    // word capitalized.
    // - Default: normal
    Layout::Xaxis::Rangeselector::Font& textcase(enum Textcase f);

    // Sets the variant of the font.
    // - Default: normal
    Layout::Xaxis::Rangeselector::Font& variant(enum Variant f);

    // Sets the weight (or boldness) of the font.
    Layout::Xaxis::Rangeselector::Font& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Xaxis::Rangeselector::Font& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Xaxis::Rangeslider {
 public:
    Rangeslider() = default;
    Rangeslider(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    class Yaxis;

    // Determines whether or not the range slider range is computed in relation to the input data. If `range` is
    // provided, then `autorange` is set to *false*.
    Layout::Xaxis::Rangeslider& autorange(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Xaxis::Rangeslider& autorange(Callable&& c);

    // Sets the background color of the range slider.
    Layout::Xaxis::Rangeslider& bgcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis::Rangeslider& bgcolor(Callable&& c);

    // Sets the border color of the range slider.
    Layout::Xaxis::Rangeslider& bordercolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis::Rangeslider& bordercolor(Callable&& c);

    // Sets the border width of the range slider.
    Layout::Xaxis::Rangeslider& borderwidth(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Xaxis::Rangeslider& borderwidth(Callable&& c);

    // Sets the range of the range slider. If not set, defaults to the full xaxis range. If the axis `type` is *log*,
    // then you must take the log of your desired range. If the axis `type` is *date*, it should be date strings, like
    // date data, though Date objects and unix milliseconds will be accepted and converted to strings. If the axis
    // `type` is *category*, it should be numbers, using the scale where each category is assigned a serial number from
    // zero in the order it appears.
    Layout::Xaxis::Rangeslider& range(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Xaxis::Rangeslider& range(Callable&& c);

    // The height of the range slider as a fraction of the total plot area height.
    Layout::Xaxis::Rangeslider& thickness(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Xaxis::Rangeslider& thickness(Callable&& c);

    // Determines whether or not the range slider will be visible. If visible, perpendicular axes will be set to
    // `fixedrange`
    Layout::Xaxis::Rangeslider& visible(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Xaxis::Rangeslider& visible(Callable&& c);

    Layout::Xaxis::Rangeslider& yaxis(Yaxis f);
    Layout::Xaxis::Rangeslider& yaxis(int index, Yaxis f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Yaxis&>>>
    Layout::Xaxis::Rangeslider& yaxis(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Xaxis::Rangeslider::Yaxis {
 public:
    Yaxis() = default;
    Yaxis(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Rangemode {
        Auto,
        Fixed,
        Match,
    };
    static std::string to_string(Rangemode e);

    // Sets the range of this axis for the rangeslider.
    Layout::Xaxis::Rangeslider::Yaxis& range(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Xaxis::Rangeslider::Yaxis& range(Callable&& c);

    // Determines whether or not the range of this axis in the rangeslider use the same value than in the main plot when
    // zooming in/out. If *auto*, the autorange will be used. If *fixed*, the `range` is used. If *match*, the current
    // range of the corresponding y-axis on the main subplot is used.
    // - Default: match
    Layout::Xaxis::Rangeslider::Yaxis& rangemode(enum Rangemode f);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets the tick font.
class Layout::Xaxis::Tickfont {
 public:
    Tickfont() = default;
    Tickfont(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    enum class Textcase {
        Normal,
        WordCaps,
        Upper,
        Lower,
    };
    static std::string to_string(Textcase e);

    enum class Variant {
        Normal,
        SmallCaps,
        AllSmallCaps,
        AllPetiteCaps,
        PetiteCaps,
        Unicase,
    };
    static std::string to_string(Variant e);

    Layout::Xaxis::Tickfont& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis::Tickfont& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Xaxis::Tickfont& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis::Tickfont& family(Callable&& c);

    // Sets the kind of decoration line(s) with text, such as an *under*, *over* or *through* as well as combinations
    // e.g. *under+over*, etc.
    // - Default: none
    // - Flags: ['under', 'over', 'through']
    // - Extras ['none']
    Layout::Xaxis::Tickfont& lineposition(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis::Tickfont& lineposition(Callable&& c);

    // Sets the shape and color of the shadow behind text. *auto* places minimal shadow and applies contrast text font
    // color. See https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow for additional options.
    Layout::Xaxis::Tickfont& shadow(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis::Tickfont& shadow(Callable&& c);

    Layout::Xaxis::Tickfont& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Xaxis::Tickfont& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Xaxis::Tickfont& style(enum Style f);

    // Sets capitalization of text. It can be used to make text appear in all-uppercase or all-lowercase, or with each
    // word capitalized.
    // - Default: normal
    Layout::Xaxis::Tickfont& textcase(enum Textcase f);

    // Sets the variant of the font.
    // - Default: normal
    Layout::Xaxis::Tickfont& variant(enum Variant f);

    // Sets the weight (or boldness) of the font.
    Layout::Xaxis::Tickfont& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Xaxis::Tickfont& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Xaxis::Tickformatstops {
 public:
    Tickformatstops() = default;
    Tickformatstops(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    class Tickformatstop;

    Layout::Xaxis::Tickformatstops& tickformatstop(Tickformatstop f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Tickformatstop&>>>
    Layout::Xaxis::Tickformatstops& tickformatstop(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Xaxis::Tickformatstops::Tickformatstop {
 public:
    Tickformatstop() = default;
    Tickformatstop(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // range [*min*, *max*], where *min*, *max* - dtick values which describe some zoom level, it is possible to omit
    // *min* or *max* value by passing *null*
    Layout::Xaxis::Tickformatstops::Tickformatstop& dtickrange(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Xaxis::Tickformatstops::Tickformatstop& dtickrange(Callable&& c);

    // Determines whether or not this stop is used. If `false`, this stop is ignored even within its `dtickrange`.
    Layout::Xaxis::Tickformatstops::Tickformatstop& enabled(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Xaxis::Tickformatstops::Tickformatstop& enabled(Callable&& c);

    // When used in a template, named items are created in the output figure in addition to any items the figure already
    // has in this array. You can modify these items in the output figure by making your own item with
    // `templateitemname` matching this `name` alongside your modifications (including `visible: false` or `enabled:
    // false` to hide it). Has no effect outside of a template.
    Layout::Xaxis::Tickformatstops::Tickformatstop& name(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis::Tickformatstops::Tickformatstop& name(Callable&& c);

    // Used to refer to a named item in this array in the template. Named items from the template will be created even
    // without a matching item in the input figure, but you can modify one by making an item with `templateitemname`
    // matching its `name`, alongside your modifications (including `visible: false` or `enabled: false` to hide it). If
    // there is no template or no matching item, this item will be hidden unless you explicitly show it with `visible:
    // true`.
    Layout::Xaxis::Tickformatstops::Tickformatstop& templateitemname(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis::Tickformatstops::Tickformatstop& templateitemname(Callable&& c);

    // string - dtickformat for described zoom level, the same as *tickformat*
    Layout::Xaxis::Tickformatstops::Tickformatstop& value(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis::Tickformatstops::Tickformatstop& value(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Xaxis::Title {
 public:
    Title() = default;
    Title(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Sets this axis' title font.
    class Font;

    // Sets this axis' title font.
    Layout::Xaxis::Title& font(Font f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Font&>>>
    Layout::Xaxis::Title& font(Callable&& c);

    // Sets the standoff distance (in px) between the axis labels and the title text The default value is a function of
    // the axis tick labels, the title `font.size` and the axis `linewidth`. Note that the axis title position is always
    // constrained within the margins, so the actual standoff distance is always less than the set or default value. By
    // setting `standoff` and turning on `automargin`, plotly.js will push the margins to fit the axis title at given
    // standoff distance.
    Layout::Xaxis::Title& standoff(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Xaxis::Title& standoff(Callable&& c);

    // Sets the title of this axis.
    Layout::Xaxis::Title& text(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis::Title& text(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets this axis' title font.
class Layout::Xaxis::Title::Font {
 public:
    Font() = default;
    Font(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    enum class Textcase {
        Normal,
        WordCaps,
        Upper,
        Lower,
    };
    static std::string to_string(Textcase e);

    enum class Variant {
        Normal,
        SmallCaps,
        AllSmallCaps,
        AllPetiteCaps,
        PetiteCaps,
        Unicase,
    };
    static std::string to_string(Variant e);

    Layout::Xaxis::Title::Font& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis::Title::Font& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Xaxis::Title::Font& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis::Title::Font& family(Callable&& c);

    // Sets the kind of decoration line(s) with text, such as an *under*, *over* or *through* as well as combinations
    // e.g. *under+over*, etc.
    // - Default: none
    // - Flags: ['under', 'over', 'through']
    // - Extras ['none']
    Layout::Xaxis::Title::Font& lineposition(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis::Title::Font& lineposition(Callable&& c);

    // Sets the shape and color of the shadow behind text. *auto* places minimal shadow and applies contrast text font
    // color. See https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow for additional options.
    Layout::Xaxis::Title::Font& shadow(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Xaxis::Title::Font& shadow(Callable&& c);

    Layout::Xaxis::Title::Font& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Xaxis::Title::Font& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Xaxis::Title::Font& style(enum Style f);

    // Sets capitalization of text. It can be used to make text appear in all-uppercase or all-lowercase, or with each
    // word capitalized.
    // - Default: normal
    Layout::Xaxis::Title::Font& textcase(enum Textcase f);

    // Sets the variant of the font.
    // - Default: normal
    Layout::Xaxis::Title::Font& variant(enum Variant f);

    // Sets the weight (or boldness) of the font.
    Layout::Xaxis::Title::Font& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Xaxis::Title::Font& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Yaxis {
 public:
    Yaxis() = default;
    Yaxis(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Autorange {
        True,
        False,
        Reversed,
        MinReversed,
        MaxReversed,
        Min,
        Max,
    };
    static std::string to_string(Autorange e);

    enum class Autotypenumbers {
        ConvertTypes,
        Strict,
    };
    static std::string to_string(Autotypenumbers e);

    enum class Calendar {
        Chinese,
        Coptic,
        Discworld,
        Ethiopian,
        Gregorian,
        Hebrew,
        Islamic,
        Jalali,
        Julian,
        Mayan,
        Nanakshahi,
        Nepali,
        Persian,
        Taiwan,
        Thai,
        Ummalqura,
    };
    static std::string to_string(Calendar e);

    enum class Categoryorder {
        Trace,
        CategoryAscending,
        CategoryDescending,
        Array,
        TotalAscending,
        TotalDescending,
        MinAscending,
        MinDescending,
        MaxAscending,
        MaxDescending,
        SumAscending,
        SumDescending,
        MeanAscending,
        MeanDescending,
        GeometricMeanAscending,
        GeometricMeanDescending,
        MedianAscending,
        MedianDescending,
    };
    static std::string to_string(Categoryorder e);

    enum class Constrain {
        Range,
        Domain,
    };
    static std::string to_string(Constrain e);

    enum class Constraintoward {
        Left,
        Center,
        Right,
        Top,
        Middle,
        Bottom,
    };
    static std::string to_string(Constraintoward e);

    enum class Exponentformat {
        None,
        E,
        Power,
        Si,
        B,
    };
    static std::string to_string(Exponentformat e);

    enum class Layer {
        AboveTraces,
        BelowTraces,
    };
    static std::string to_string(Layer e);

    enum class Mirror {
        True,
        Ticks,
        False,
        All,
        Allticks,
    };
    static std::string to_string(Mirror e);

    enum class Rangemode {
        Normal,
        Tozero,
        Nonnegative,
    };
    static std::string to_string(Rangemode e);

    enum class Showexponent {
        All,
        First,
        Last,
        None,
    };
    static std::string to_string(Showexponent e);

    enum class Showtickprefix {
        All,
        First,
        Last,
        None,
    };
    static std::string to_string(Showtickprefix e);

    enum class Showticksuffix {
        All,
        First,
        Last,
        None,
    };
    static std::string to_string(Showticksuffix e);

    enum class Side {
        Top,
        Bottom,
        Left,
        Right,
    };
    static std::string to_string(Side e);

    enum class Spikesnap {
        Data,
        Cursor,
        HoveredData,
    };
    static std::string to_string(Spikesnap e);

    enum class Ticklabelmode {
        Instant,
        Period,
    };
    static std::string to_string(Ticklabelmode e);

    enum class Ticklabeloverflow {
        Allow,
        HidePastDiv,
        HidePastDomain,
    };
    static std::string to_string(Ticklabeloverflow e);

    enum class Ticklabelposition {
        Outside,
        Inside,
        OutsideTop,
        InsideTop,
        OutsideLeft,
        InsideLeft,
        OutsideRight,
        InsideRight,
        OutsideBottom,
        InsideBottom,
    };
    static std::string to_string(Ticklabelposition e);

    enum class Tickmode {
        Auto,
        Linear,
        Array,
        Sync,
    };
    static std::string to_string(Tickmode e);

    enum class Ticks {
        Outside,
        Inside,
        Empty,
    };
    static std::string to_string(Ticks e);

    enum class Tickson {
        Labels,
        Boundaries,
    };
    static std::string to_string(Tickson e);

    enum class Type {
        Hyphen,
        Linear,
        Log,
        Date,
        Category,
        Multicategory,
    };
    static std::string to_string(Type e);

    class Autorangeoptions;
    class Minor;
    class Rangebreaks;
    // Sets the tick font.
    class Tickfont;
    class Tickformatstops;
    class Title;

    // If set to an opposite-letter axis id (e.g. `x2`, `y`), this axis is bound to the corresponding opposite-letter
    // axis. If set to *free*, this axis' position is determined by `position`.
    Layout::Yaxis& anchor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Yaxis& anchor(Callable&& c);

    // Determines whether long tick labels automatically grow the figure margins.
    // - Default: False
    // - Flags: ['height', 'width', 'left', 'right', 'top', 'bottom']
    // - Extras [True, False]
    Layout::Yaxis& automargin(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Yaxis& automargin(Callable&& c);

    // Determines whether or not the range of this axis is computed in relation to the input data. See `rangemode` for
    // more info. If `range` is provided and it has a value for both the lower and upper bound, `autorange` is set to
    // *false*. Using *min* applies autorange only to set the minimum. Using *max* applies autorange only to set the
    // maximum. Using *min reversed* applies autorange only to set the minimum on a reversed axis. Using *max reversed*
    // applies autorange only to set the maximum on a reversed axis. Using *reversed* applies autorange on both ends and
    // reverses the axis direction.
    // - Default: True
    Layout::Yaxis& autorange(enum Autorange f);

    Layout::Yaxis& autorangeoptions(Autorangeoptions f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Autorangeoptions&>>>
    Layout::Yaxis& autorangeoptions(Callable&& c);

    // Automatically reposition the axis to avoid overlap with other axes with the same `overlaying` value. This
    // repositioning will account for any `shift` amount applied to other axes on the same side with `autoshift` is set
    // to true. Only has an effect if `anchor` is set to *free*.
    Layout::Yaxis& autoshift(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Yaxis& autoshift(Callable&& c);

    // When `tickangle` is set to *auto*, it will be set to the first angle in this array that is large enough to
    // prevent label overlap.
    Layout::Yaxis& autotickangles(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Yaxis& autotickangles(Callable&& c);

    // Using *strict* a numeric string in trace data is not converted to a number. Using *convert types* a numeric
    // string in trace data may be treated as a number during automatic axis `type` detection. Defaults to
    // layout.autotypenumbers.
    // - Default: convert types
    Layout::Yaxis& autotypenumbers(enum Autotypenumbers f);

    // Sets the calendar system to use for `range` and `tick0` if this is a date axis. This does not set the calendar
    // for interpreting data on this axis, that's specified in the trace or via the global `layout.calendar`
    // - Default: gregorian
    Layout::Yaxis& calendar(enum Calendar f);

    // Sets the order in which categories on this axis appear. Only has an effect if `categoryorder` is set to *array*.
    // Used with `categoryorder`.
    template <typename T, typename = std::enable_if_t<is_data_array_element_v<T>>>
    Layout::Yaxis& categoryarray(const std::vector<T>& f);
    template <
        typename T, typename Callable,
        typename = std::enable_if_t<is_data_array_element_v<T> && (std::is_invocable_v<Callable, std::vector<T>&>)>>
    Layout::Yaxis& categoryarray(Callable&& c);

    // Sets the source reference on Chart Studio Cloud for `categoryarray`.
    Layout::Yaxis& categoryarraysrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Yaxis& categoryarraysrc(Callable&& c);

    // Specifies the ordering logic for the case of categorical variables. By default, plotly uses *trace*, which
    // specifies the order that is present in the data supplied. Set `categoryorder` to *category ascending* or
    // *category descending* if order should be determined by the alphanumerical order of the category names. Set
    // `categoryorder` to *array* to derive the ordering from the attribute `categoryarray`. If a category is not found
    // in the `categoryarray` array, the sorting behavior for that attribute will be identical to the *trace* mode. The
    // unspecified categories will follow the categories in `categoryarray`. Set `categoryorder` to *total ascending* or
    // *total descending* if order should be determined by the numerical order of the values. Similarly, the order can
    // be determined by the min, max, sum, mean, geometric mean or median of all the values.
    // - Default: trace
    Layout::Yaxis& categoryorder(enum Categoryorder f);

    // Sets default for all colors associated with this axis all at once: line, font, tick, and grid colors. Grid color
    // is lightened by blending this with the plot background Individual pieces can override this.
    Layout::Yaxis& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Yaxis& color(Callable&& c);

    // If this axis needs to be compressed (either due to its own `scaleanchor` and `scaleratio` or those of the other
    // axis), determines how that happens: by increasing the *range*, or by decreasing the *domain*. Default is *domain*
    // for axes containing image traces, *range* otherwise.
    Layout::Yaxis& constrain(enum Constrain f);

    // If this axis needs to be compressed (either due to its own `scaleanchor` and `scaleratio` or those of the other
    // axis), determines which direction we push the originally specified plot area. Options are *left*, *center*
    // (default), and *right* for x axes, and *top*, *middle* (default), and *bottom* for y axes.
    Layout::Yaxis& constraintoward(enum Constraintoward f);

    // Sets the color of the dividers Only has an effect on *multicategory* axes.
    Layout::Yaxis& dividercolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Yaxis& dividercolor(Callable&& c);

    // Sets the width (in px) of the dividers Only has an effect on *multicategory* axes.
    Layout::Yaxis& dividerwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Yaxis& dividerwidth(Callable&& c);

    // Sets the domain of this axis (in plot fraction).
    Layout::Yaxis& domain(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Yaxis& domain(Callable&& c);

    // Sets the step in-between ticks on this axis. Use with `tick0`. Must be a positive number, or special strings
    // available to *log* and *date* axes. If the axis `type` is *log*, then ticks are set every 10^(n*dtick) where n is
    // the tick number. For example, to set a tick mark at 1, 10, 100, 1000, ... set dtick to 1. To set tick marks at 1,
    // 100, 10000, ... set dtick to 2. To set tick marks at 1, 5, 25, 125, 625, 3125, ... set dtick to log_10(5), or
    // 0.69897000433. *log* has several special values; *L<f>*, where `f` is a positive number, gives ticks linearly
    // spaced in value (but not position). For example `tick0` = 0.1, `dtick` = *L0.5* will put ticks at 0.1,
    // 0.6, 1.1, 1.6 etc. To show powers of 10 plus small digits between, use *D1* (all digits) or *D2* (only 2 and 5).
    // `tick0` is ignored for *D1* and *D2*. If the axis `type` is *date*, then you must convert the time to
    // milliseconds. For example, to set the interval between ticks to one day, set `dtick` to 86400000.0. *date* also
    // has special values *M<n>* gives ticks spaced by a number of months. `n` must be a positive integer. To set ticks
    // on the 15th of every third month, set `tick0` to *2000-01-15* and `dtick` to *M3*. To set ticks every 4 years,
    // set `dtick` to *M48*
    template <typename T>
    Layout::Yaxis& dtick(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Yaxis& dtick(Callable&& c);

    // Determines a formatting rule for the tick exponents. For example, consider the number 1,000,000,000. If *none*,
    // it appears as 1,000,000,000. If *e*, 1e+9. If *E*, 1E+9. If *power*, 1x10^9 (with 9 in a super script). If *SI*,
    // 1G. If *B*, 1B.
    // - Default: B
    Layout::Yaxis& exponentformat(enum Exponentformat f);

    // Determines whether or not this axis is zoom-able. If true, then zoom is disabled.
    Layout::Yaxis& fixedrange(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Yaxis& fixedrange(Callable&& c);

    // Sets the color of the grid lines.
    Layout::Yaxis& gridcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Yaxis& gridcolor(Callable&& c);

    // Sets the dash style of lines. Set to a dash type string (*solid*, *dot*, *dash*, *longdash*, *dashdot*, or
    // *longdashdot*) or a dash length list in px (eg *5px,10px,2px,2px*).
    Layout::Yaxis& griddash(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Yaxis& griddash(Callable&& c);

    // Sets the width (in px) of the grid lines.
    Layout::Yaxis& gridwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Yaxis& gridwidth(Callable&& c);

    // Sets the hover text formatting rule using d3 formatting mini-languages which are very similar to those in Python.
    // For numbers, see: https://github.com/d3/d3-format/tree/v1.4.5#d3-format. And for dates see:
    // https://github.com/d3/d3-time-format/tree/v2.2.3#locale_format. We add two items to d3's date formatter: *%h* for
    // half of the year as a decimal number as well as *%{n}f* for fractional seconds with n digits. For example,
    // *2016-10-13 09:15:23.456* with tickformat *%H~%M~%S.%2f* would display *09~15~23.46*
    Layout::Yaxis& hoverformat(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Yaxis& hoverformat(Callable&& c);

    // Could be used to set the desired inside range of this axis (excluding the labels) when `ticklabelposition` of the
    // anchored axis has *inside*. Not implemented for axes with `type` *log*. This would be ignored when `range` is
    // provided.
    Layout::Yaxis& insiderange(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Yaxis& insiderange(Callable&& c);

    // Replacement text for specific tick or hover labels. For example using {US: 'USA', CA: 'Canada'} changes US to USA
    // and CA to Canada. The labels we would have shown must match the keys exactly, after adding any tickprefix or
    // ticksuffix. For negative numbers the minus sign symbol used (U+2212) is wider than the regular ascii dash. That
    // means you need to use 1 instead of -1. labelalias can be used with any axis type, and both keys (if needed) and
    // values (if desired) can include html-like tags or MathJax.
    template <typename T>
    Layout::Yaxis& labelalias(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Yaxis& labelalias(Callable&& c);

    // Sets the layer on which this axis is displayed. If *above traces*, this axis is displayed above all the subplot's
    // traces If *below traces*, this axis is displayed below all the subplot's traces, but above the grid lines. Useful
    // when used together with scatter-like traces with `cliponaxis` set to *false* to show markers and/or text nodes
    // above this axis.
    // - Default: above traces
    Layout::Yaxis& layer(enum Layer f);

    // Sets the axis line color.
    Layout::Yaxis& linecolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Yaxis& linecolor(Callable&& c);

    // Sets the width (in px) of the axis line.
    Layout::Yaxis& linewidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Yaxis& linewidth(Callable&& c);

    // If set to another axis id (e.g. `x2`, `y`), the range of this axis will match the range of the corresponding axis
    // in data-coordinates space. Moreover, matching axes share auto-range values, category lists and histogram
    // auto-bins. Note that setting axes simultaneously in both a `scaleanchor` and a `matches` constraint is currently
    // forbidden. Moreover, note that matching axes must have the same `type`.
    Layout::Yaxis& matches(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Yaxis& matches(Callable&& c);

    // Determines the maximum range of this axis.
    template <typename T>
    Layout::Yaxis& maxallowed(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Yaxis& maxallowed(Callable&& c);

    // Determines the minimum range of this axis.
    template <typename T>
    Layout::Yaxis& minallowed(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Yaxis& minallowed(Callable&& c);

    // Hide SI prefix for 10^n if |n| is below this number. This only has an effect when `tickformat` is *SI* or *B*.
    Layout::Yaxis& minexponent(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Yaxis& minexponent(Callable&& c);

    Layout::Yaxis& minor(Minor f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Minor&>>>
    Layout::Yaxis& minor(Callable&& c);

    // Determines if the axis lines or/and ticks are mirrored to the opposite side of the plotting area. If *true*, the
    // axis lines are mirrored. If *ticks*, the axis lines and ticks are mirrored. If *false*, mirroring is disable. If
    // *all*, axis lines are mirrored on all shared-axes subplots. If *allticks*, axis lines and ticks are mirrored on
    // all shared-axes subplots.
    // - Default: False
    Layout::Yaxis& mirror(enum Mirror f);

    // Specifies the maximum number of ticks for the particular axis. The actual number of ticks will be chosen
    // automatically to be less than or equal to `nticks`. Has an effect only if `tickmode` is set to *auto*.
    Layout::Yaxis& nticks(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Yaxis& nticks(Callable&& c);

    // If set a same-letter axis id, this axis is overlaid on top of the corresponding same-letter axis, with traces and
    // axes visible for both axes. If *false*, this axis does not overlay any same-letter axes. In this case, for axes
    // with overlapping domains only the highest-numbered axis will be visible.
    Layout::Yaxis& overlaying(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Yaxis& overlaying(Callable&& c);

    // Sets the position of this axis in the plotting space (in normalized coordinates). Only has an effect if `anchor`
    // is set to *free*.
    Layout::Yaxis& position(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Yaxis& position(Callable&& c);

    // Sets the range of this axis. If the axis `type` is *log*, then you must take the log of your desired range (e.g.
    // to set the range from 1 to 100, set the range from 0 to 2). If the axis `type` is *date*, it should be date
    // strings, like date data, though Date objects and unix milliseconds will be accepted and converted to strings. If
    // the axis `type` is *category*, it should be numbers, using the scale where each category is assigned a serial
    // number from zero in the order it appears. Leaving either or both elements `null` impacts the default `autorange`.
    Layout::Yaxis& range(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Yaxis& range(Callable&& c);

    Layout::Yaxis& rangebreaks(Rangebreaks f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Rangebreaks&>>>
    Layout::Yaxis& rangebreaks(Callable&& c);

    // If *normal*, the range is computed in relation to the extrema of the input data. If *tozero*`, the range extends
    // to 0, regardless of the input data If *nonnegative*, the range is non-negative, regardless of the input data.
    // Applies only to linear axes.
    // - Default: normal
    Layout::Yaxis& rangemode(enum Rangemode f);

    // If set to another axis id (e.g. `x2`, `y`), the range of this axis changes together with the range of the
    // corresponding axis such that the scale of pixels per unit is in a constant ratio. Both axes are still zoomable,
    // but when you zoom one, the other will zoom the same amount, keeping a fixed midpoint. `constrain` and
    // `constraintoward` determine how we enforce the constraint. You can chain these, ie `yaxis: {scaleanchor: *x*},
    // xaxis2: {scaleanchor: *y*}` but you can only link axes of the same `type`. The linked axis can have the opposite
    // letter (to constrain the aspect ratio) or the same letter (to match scales across subplots). Loops (`yaxis:
    // {scaleanchor: *x*}, xaxis: {scaleanchor: *y*}` or longer) are redundant and the last constraint encountered will
    // be ignored to avoid possible inconsistent constraints via `scaleratio`. Note that setting axes simultaneously in
    // both a `scaleanchor` and a `matches` constraint is currently forbidden. Setting `false` allows to remove a
    // default constraint (occasionally, you may need to prevent a default `scaleanchor` constraint from being applied,
    // eg. when having an image trace `yaxis: {scaleanchor: "x"}` is set automatically in order for pixels to be
    // rendered as squares, setting `yaxis: {scaleanchor: false}` allows to remove the constraint).
    Layout::Yaxis& scaleanchor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Yaxis& scaleanchor(Callable&& c);

    // If this axis is linked to another by `scaleanchor`, this determines the pixel to unit scale ratio. For example,
    // if this value is 10, then every unit on this axis spans 10 times the number of pixels as a unit on the linked
    // axis. Use this for example to create an elevation profile where the vertical scale is exaggerated a fixed amount
    // with respect to the horizontal.
    Layout::Yaxis& scaleratio(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Yaxis& scaleratio(Callable&& c);

    // If "true", even 4-digit integers are separated
    Layout::Yaxis& separatethousands(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Yaxis& separatethousands(Callable&& c);

    // Moves the axis a given number of pixels from where it would have been otherwise. Accepts both positive and
    // negative values, which will shift the axis either right or left, respectively. If `autoshift` is set to true,
    // then this defaults to a padding of -3 if `side` is set to *left*. and defaults to +3 if `side` is set to *right*.
    // Defaults to 0 if `autoshift` is set to false. Only has an effect if `anchor` is set to *free*.
    Layout::Yaxis& shift(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Yaxis& shift(Callable&& c);

    // Determines whether or not a dividers are drawn between the category levels of this axis. Only has an effect on
    // *multicategory* axes.
    Layout::Yaxis& showdividers(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Yaxis& showdividers(Callable&& c);

    // If *all*, all exponents are shown besides their significands. If *first*, only the exponent of the first tick is
    // shown. If *last*, only the exponent of the last tick is shown. If *none*, no exponents appear.
    // - Default: all
    Layout::Yaxis& showexponent(enum Showexponent f);

    // Determines whether or not grid lines are drawn. If *true*, the grid lines are drawn at every tick mark.
    Layout::Yaxis& showgrid(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Yaxis& showgrid(Callable&& c);

    // Determines whether or not a line bounding this axis is drawn.
    Layout::Yaxis& showline(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Yaxis& showline(Callable&& c);

    // Determines whether or not spikes (aka droplines) are drawn for this axis. Note: This only takes affect when
    // hovermode = closest
    Layout::Yaxis& showspikes(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Yaxis& showspikes(Callable&& c);

    // Determines whether or not the tick labels are drawn.
    Layout::Yaxis& showticklabels(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Yaxis& showticklabels(Callable&& c);

    // If *all*, all tick labels are displayed with a prefix. If *first*, only the first tick is displayed with a
    // prefix. If *last*, only the last tick is displayed with a suffix. If *none*, tick prefixes are hidden.
    // - Default: all
    Layout::Yaxis& showtickprefix(enum Showtickprefix f);

    // Same as `showtickprefix` but for tick suffixes.
    // - Default: all
    Layout::Yaxis& showticksuffix(enum Showticksuffix f);

    // Determines whether a x (y) axis is positioned at the *bottom* (*left*) or *top* (*right*) of the plotting area.
    Layout::Yaxis& side(enum Side f);

    // Sets the spike color. If undefined, will use the series color
    Layout::Yaxis& spikecolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Yaxis& spikecolor(Callable&& c);

    // Sets the dash style of lines. Set to a dash type string (*solid*, *dot*, *dash*, *longdash*, *dashdot*, or
    // *longdashdot*) or a dash length list in px (eg *5px,10px,2px,2px*).
    Layout::Yaxis& spikedash(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Yaxis& spikedash(Callable&& c);

    // Determines the drawing mode for the spike line If *toaxis*, the line is drawn from the data point to the axis the
    // series is plotted on. If *across*, the line is drawn across the entire plot area, and supercedes *toaxis*. If
    // *marker*, then a marker dot is drawn on the axis the series is plotted on
    // - Default: toaxis
    // - Flags: ['toaxis', 'across', 'marker']
    Layout::Yaxis& spikemode(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Yaxis& spikemode(Callable&& c);

    // Determines whether spikelines are stuck to the cursor or to the closest datapoints.
    // - Default: hovered data
    Layout::Yaxis& spikesnap(enum Spikesnap f);

    // Sets the width (in px) of the zero line.
    Layout::Yaxis& spikethickness(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Yaxis& spikethickness(Callable&& c);

    // Sets the placement of the first tick on this axis. Use with `dtick`. If the axis `type` is *log*, then you must
    // take the log of your starting tick (e.g. to set the starting tick to 100, set the `tick0` to 2) except when
    // `dtick`=*L<f>* (see `dtick` for more info). If the axis `type` is *date*, it should be a date string, like date
    // data. If the axis `type` is *category*, it should be a number, using the scale where each category is assigned a
    // serial number from zero in the order it appears.
    template <typename T>
    Layout::Yaxis& tick0(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Yaxis& tick0(Callable&& c);

    // Sets the angle of the tick labels with respect to the horizontal. For example, a `tickangle` of -90 draws the
    // tick labels vertically.
    Layout::Yaxis& tickangle(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Yaxis& tickangle(Callable&& c);

    // Sets the tick color.
    Layout::Yaxis& tickcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Yaxis& tickcolor(Callable&& c);

    // Sets the tick font.
    Layout::Yaxis& tickfont(Tickfont f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Tickfont&>>>
    Layout::Yaxis& tickfont(Callable&& c);

    // Sets the tick label formatting rule using d3 formatting mini-languages which are very similar to those in Python.
    // For numbers, see: https://github.com/d3/d3-format/tree/v1.4.5#d3-format. And for dates see:
    // https://github.com/d3/d3-time-format/tree/v2.2.3#locale_format. We add two items to d3's date formatter: *%h* for
    // half of the year as a decimal number as well as *%{n}f* for fractional seconds with n digits. For example,
    // *2016-10-13 09:15:23.456* with tickformat *%H~%M~%S.%2f* would display *09~15~23.46*
    Layout::Yaxis& tickformat(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Yaxis& tickformat(Callable&& c);

    Layout::Yaxis& tickformatstops(Tickformatstops f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Tickformatstops&>>>
    Layout::Yaxis& tickformatstops(Callable&& c);

    // Only for axes with `type` *date* or *linear*. Instead of drawing the major tick label, draw the label for the
    // minor tick that is n positions away from the major tick. E.g. to always draw the label for the minor tick before
    // each major tick, choose `ticklabelindex` -1. This is useful for date axes with `ticklabelmode` *period* if you
    // want to label the period that ends with each major tick instead of the period that begins there.
    Layout::Yaxis& ticklabelindex(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Yaxis& ticklabelindex(Callable&& c);
    Layout::Yaxis& ticklabelindex(const std::vector<int>& f);

    // Sets the source reference on Chart Studio Cloud for `ticklabelindex`.
    Layout::Yaxis& ticklabelindexsrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Yaxis& ticklabelindexsrc(Callable&& c);

    // Determines where tick labels are drawn with respect to their corresponding ticks and grid lines. Only has an
    // effect for axes of `type` *date* When set to *period*, tick labels are drawn in the middle of the period between
    // ticks.
    // - Default: instant
    Layout::Yaxis& ticklabelmode(enum Ticklabelmode f);

    // Determines how we handle tick labels that would overflow either the graph div or the domain of the axis. The
    // default value for inside tick labels is *hide past domain*. Otherwise on *category* and *multicategory* axes the
    // default is *allow*. In other cases the default is *hide past div*.
    Layout::Yaxis& ticklabeloverflow(enum Ticklabeloverflow f);

    // Determines where tick labels are drawn with respect to the axis Please note that top or bottom has no effect on x
    // axes or when `ticklabelmode` is set to *period*. Similarly left or right has no effect on y axes or when
    // `ticklabelmode` is set to *period*. Has no effect on *multicategory* axes or when `tickson` is set to
    // *boundaries*. When used on axes linked by `matches` or `scaleanchor`, no extra padding for inside labels would be
    // added by autorange, so that the scales could match.
    // - Default: outside
    Layout::Yaxis& ticklabelposition(enum Ticklabelposition f);

    // Shifts the tick labels by the specified number of pixels in parallel to the axis. Positive values move the labels
    // in the positive direction of the axis.
    Layout::Yaxis& ticklabelshift(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Yaxis& ticklabelshift(Callable&& c);

    // Sets the standoff distance (in px) between the axis tick labels and their default position. A positive
    // `ticklabelstandoff` moves the labels farther away from the plot area if `ticklabelposition` is *outside*, and
    // deeper into the plot area if `ticklabelposition` is *inside*. A negative `ticklabelstandoff` works in the
    // opposite direction, moving outside ticks towards the plot area and inside ticks towards the outside. If the
    // negative value is large enough, inside ticks can even end up outside and vice versa.
    Layout::Yaxis& ticklabelstandoff(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Yaxis& ticklabelstandoff(Callable&& c);

    // Sets the spacing between tick labels as compared to the spacing between ticks. A value of 1 (default) means each
    // tick gets a label. A value of 2 means shows every 2nd label. A larger value n means only every nth tick is
    // labeled. `tick0` determines which labels are shown. Not implemented for axes with `type` *log* or
    // *multicategory*, or when `tickmode` is *array*.
    Layout::Yaxis& ticklabelstep(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Yaxis& ticklabelstep(Callable&& c);

    // Sets the tick length (in px).
    Layout::Yaxis& ticklen(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Yaxis& ticklen(Callable&& c);

    // Sets the tick mode for this axis. If *auto*, the number of ticks is set via `nticks`. If *linear*, the placement
    // of the ticks is determined by a starting position `tick0` and a tick step `dtick` (*linear* is the default value
    // if `tick0` and `dtick` are provided). If *array*, the placement of the ticks is set via `tickvals` and the tick
    // text is `ticktext`. (*array* is the default value if `tickvals` is provided). If *sync*, the number of ticks will
    // sync with the overlayed axis set by `overlaying` property.
    Layout::Yaxis& tickmode(enum Tickmode f);

    // Sets a tick label prefix.
    Layout::Yaxis& tickprefix(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Yaxis& tickprefix(Callable&& c);

    // Determines whether ticks are drawn or not. If **, this axis' ticks are not drawn. If *outside* (*inside*), this
    // axis' are drawn outside (inside) the axis lines.
    Layout::Yaxis& ticks(enum Ticks f);

    // Determines where ticks and grid lines are drawn with respect to their corresponding tick labels. Only has an
    // effect for axes of `type` *category* or *multicategory*. When set to *boundaries*, ticks and grid lines are drawn
    // half a category to the left/bottom of labels.
    // - Default: labels
    Layout::Yaxis& tickson(enum Tickson f);

    // Sets a tick label suffix.
    Layout::Yaxis& ticksuffix(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Yaxis& ticksuffix(Callable&& c);

    // Sets the text displayed at the ticks position via `tickvals`. Only has an effect if `tickmode` is set to *array*.
    // Used with `tickvals`.
    template <typename T, typename = std::enable_if_t<is_data_array_element_v<T>>>
    Layout::Yaxis& ticktext(const std::vector<T>& f);
    template <
        typename T, typename Callable,
        typename = std::enable_if_t<is_data_array_element_v<T> && (std::is_invocable_v<Callable, std::vector<T>&>)>>
    Layout::Yaxis& ticktext(Callable&& c);

    // Sets the source reference on Chart Studio Cloud for `ticktext`.
    Layout::Yaxis& ticktextsrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Yaxis& ticktextsrc(Callable&& c);

    // Sets the values at which ticks on this axis appear. Only has an effect if `tickmode` is set to *array*. Used with
    // `ticktext`.
    template <typename T, typename = std::enable_if_t<is_data_array_element_v<T>>>
    Layout::Yaxis& tickvals(const std::vector<T>& f);
    template <
        typename T, typename Callable,
        typename = std::enable_if_t<is_data_array_element_v<T> && (std::is_invocable_v<Callable, std::vector<T>&>)>>
    Layout::Yaxis& tickvals(Callable&& c);

    // Sets the source reference on Chart Studio Cloud for `tickvals`.
    Layout::Yaxis& tickvalssrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Yaxis& tickvalssrc(Callable&& c);

    // Sets the tick width (in px).
    Layout::Yaxis& tickwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Yaxis& tickwidth(Callable&& c);

    Layout::Yaxis& title(Title f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Title&>>>
    Layout::Yaxis& title(Callable&& c);

    // Sets the axis type. By default, plotly attempts to determined the axis type by looking into the data of the
    // traces that referenced the axis in question.
    // - Default: -
    Layout::Yaxis& type(enum Type f);

    // Controls persistence of user-driven changes in axis `range`, `autorange`, and `title` if in `editable: true`
    // configuration. Defaults to `layout.uirevision`.
    template <typename T>
    Layout::Yaxis& uirevision(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Yaxis& uirevision(Callable&& c);

    // A single toggle to hide the axis while preserving interaction like dragging. Default is true when a cheater plot
    // is present on the axis, otherwise false
    Layout::Yaxis& visible(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Yaxis& visible(Callable&& c);

    // Determines whether or not a line is drawn at along the 0 value of this axis. If *true*, the zero line is drawn on
    // top of the grid lines.
    Layout::Yaxis& zeroline(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Yaxis& zeroline(Callable&& c);

    // Sets the line color of the zero line.
    Layout::Yaxis& zerolinecolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Yaxis& zerolinecolor(Callable&& c);

    // Sets the width (in px) of the zero line.
    Layout::Yaxis& zerolinewidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Yaxis& zerolinewidth(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Yaxis::Autorangeoptions {
 public:
    Autorangeoptions() = default;
    Autorangeoptions(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Clip autorange maximum if it goes beyond this value. Has no effect when `autorangeoptions.maxallowed` is
    // provided.
    template <typename T>
    Layout::Yaxis::Autorangeoptions& clipmax(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Yaxis::Autorangeoptions& clipmax(Callable&& c);

    // Clip autorange minimum if it goes beyond this value. Has no effect when `autorangeoptions.minallowed` is
    // provided.
    template <typename T>
    Layout::Yaxis::Autorangeoptions& clipmin(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Yaxis::Autorangeoptions& clipmin(Callable&& c);

    // Ensure this value is included in autorange.
    template <typename T>
    Layout::Yaxis::Autorangeoptions& include(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Yaxis::Autorangeoptions& include(Callable&& c);
    template <typename T>
    Layout::Yaxis::Autorangeoptions& include(const std::vector<T>& f);

    // Sets the source reference on Chart Studio Cloud for `include`.
    Layout::Yaxis::Autorangeoptions& includesrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Yaxis::Autorangeoptions& includesrc(Callable&& c);

    // Use this value exactly as autorange maximum.
    template <typename T>
    Layout::Yaxis::Autorangeoptions& maxallowed(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Yaxis::Autorangeoptions& maxallowed(Callable&& c);

    // Use this value exactly as autorange minimum.
    template <typename T>
    Layout::Yaxis::Autorangeoptions& minallowed(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Yaxis::Autorangeoptions& minallowed(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Yaxis::Minor {
 public:
    Minor() = default;
    Minor(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Tickmode {
        Auto,
        Linear,
        Array,
    };
    static std::string to_string(Tickmode e);

    enum class Ticks {
        Outside,
        Inside,
        Empty,
    };
    static std::string to_string(Ticks e);

    // Sets the step in-between ticks on this axis. Use with `tick0`. Must be a positive number, or special strings
    // available to *log* and *date* axes. If the axis `type` is *log*, then ticks are set every 10^(n*dtick) where n is
    // the tick number. For example, to set a tick mark at 1, 10, 100, 1000, ... set dtick to 1. To set tick marks at 1,
    // 100, 10000, ... set dtick to 2. To set tick marks at 1, 5, 25, 125, 625, 3125, ... set dtick to log_10(5), or
    // 0.69897000433. *log* has several special values; *L<f>*, where `f` is a positive number, gives ticks linearly
    // spaced in value (but not position). For example `tick0` = 0.1, `dtick` = *L0.5* will put ticks at 0.1,
    // 0.6, 1.1, 1.6 etc. To show powers of 10 plus small digits between, use *D1* (all digits) or *D2* (only 2 and 5).
    // `tick0` is ignored for *D1* and *D2*. If the axis `type` is *date*, then you must convert the time to
    // milliseconds. For example, to set the interval between ticks to one day, set `dtick` to 86400000.0. *date* also
    // has special values *M<n>* gives ticks spaced by a number of months. `n` must be a positive integer. To set ticks
    // on the 15th of every third month, set `tick0` to *2000-01-15* and `dtick` to *M3*. To set ticks every 4 years,
    // set `dtick` to *M48*
    template <typename T>
    Layout::Yaxis::Minor& dtick(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Yaxis::Minor& dtick(Callable&& c);

    // Sets the color of the grid lines.
    Layout::Yaxis::Minor& gridcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Yaxis::Minor& gridcolor(Callable&& c);

    // Sets the dash style of lines. Set to a dash type string (*solid*, *dot*, *dash*, *longdash*, *dashdot*, or
    // *longdashdot*) or a dash length list in px (eg *5px,10px,2px,2px*).
    Layout::Yaxis::Minor& griddash(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Yaxis::Minor& griddash(Callable&& c);

    // Sets the width (in px) of the grid lines.
    Layout::Yaxis::Minor& gridwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Yaxis::Minor& gridwidth(Callable&& c);

    // Specifies the maximum number of ticks for the particular axis. The actual number of ticks will be chosen
    // automatically to be less than or equal to `nticks`. Has an effect only if `tickmode` is set to *auto*.
    Layout::Yaxis::Minor& nticks(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Yaxis::Minor& nticks(Callable&& c);

    // Determines whether or not grid lines are drawn. If *true*, the grid lines are drawn at every tick mark.
    Layout::Yaxis::Minor& showgrid(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Yaxis::Minor& showgrid(Callable&& c);

    // Sets the placement of the first tick on this axis. Use with `dtick`. If the axis `type` is *log*, then you must
    // take the log of your starting tick (e.g. to set the starting tick to 100, set the `tick0` to 2) except when
    // `dtick`=*L<f>* (see `dtick` for more info). If the axis `type` is *date*, it should be a date string, like date
    // data. If the axis `type` is *category*, it should be a number, using the scale where each category is assigned a
    // serial number from zero in the order it appears.
    template <typename T>
    Layout::Yaxis::Minor& tick0(T f);
    template <typename T, typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, T&>>>
    Layout::Yaxis::Minor& tick0(Callable&& c);

    // Sets the tick color.
    Layout::Yaxis::Minor& tickcolor(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Yaxis::Minor& tickcolor(Callable&& c);

    // Sets the tick length (in px).
    Layout::Yaxis::Minor& ticklen(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Yaxis::Minor& ticklen(Callable&& c);

    // Sets the tick mode for this axis. If *auto*, the number of ticks is set via `nticks`. If *linear*, the placement
    // of the ticks is determined by a starting position `tick0` and a tick step `dtick` (*linear* is the default value
    // if `tick0` and `dtick` are provided). If *array*, the placement of the ticks is set via `tickvals` and the tick
    // text is `ticktext`. (*array* is the default value if `tickvals` is provided).
    Layout::Yaxis::Minor& tickmode(enum Tickmode f);

    // Determines whether ticks are drawn or not. If **, this axis' ticks are not drawn. If *outside* (*inside*), this
    // axis' are drawn outside (inside) the axis lines.
    Layout::Yaxis::Minor& ticks(enum Ticks f);

    // Sets the values at which ticks on this axis appear. Only has an effect if `tickmode` is set to *array*. Used with
    // `ticktext`.
    template <typename T, typename = std::enable_if_t<is_data_array_element_v<T>>>
    Layout::Yaxis::Minor& tickvals(const std::vector<T>& f);
    template <
        typename T, typename Callable,
        typename = std::enable_if_t<is_data_array_element_v<T> && (std::is_invocable_v<Callable, std::vector<T>&>)>>
    Layout::Yaxis::Minor& tickvals(Callable&& c);

    // Sets the source reference on Chart Studio Cloud for `tickvals`.
    Layout::Yaxis::Minor& tickvalssrc(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Yaxis::Minor& tickvalssrc(Callable&& c);

    // Sets the tick width (in px).
    Layout::Yaxis::Minor& tickwidth(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Yaxis::Minor& tickwidth(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Yaxis::Rangebreaks {
 public:
    Rangebreaks() = default;
    Rangebreaks(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    class Rangebreak;

    Layout::Yaxis::Rangebreaks& rangebreak(Rangebreak f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Rangebreak&>>>
    Layout::Yaxis::Rangebreaks& rangebreak(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Yaxis::Rangebreaks::Rangebreak {
 public:
    Rangebreak() = default;
    Rangebreak(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Pattern {
        DayOfWeek,
        Hour,
        Empty,
    };
    static std::string to_string(Pattern e);

    // Sets the lower and upper bounds of this axis rangebreak. Can be used with `pattern`.
    Layout::Yaxis::Rangebreaks::Rangebreak& bounds(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Yaxis::Rangebreaks::Rangebreak& bounds(Callable&& c);

    // Sets the size of each `values` item. The default is one day in milliseconds.
    Layout::Yaxis::Rangebreaks::Rangebreak& dvalue(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Yaxis::Rangebreaks::Rangebreak& dvalue(Callable&& c);

    // Determines whether this axis rangebreak is enabled or disabled. Please note that `rangebreaks` only work for
    // *date* axis type.
    Layout::Yaxis::Rangebreaks::Rangebreak& enabled(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Yaxis::Rangebreaks::Rangebreak& enabled(Callable&& c);

    // When used in a template, named items are created in the output figure in addition to any items the figure already
    // has in this array. You can modify these items in the output figure by making your own item with
    // `templateitemname` matching this `name` alongside your modifications (including `visible: false` or `enabled:
    // false` to hide it). Has no effect outside of a template.
    Layout::Yaxis::Rangebreaks::Rangebreak& name(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Yaxis::Rangebreaks::Rangebreak& name(Callable&& c);

    // Determines a pattern on the time line that generates breaks. If *day of week* - days of the week in English e.g.
    // 'Sunday' or `sun` (matching is case-insensitive and considers only the first three characters), as well as
    // Sunday-based integers between 0 and 6. If *hour* - hour (24-hour clock) as decimal numbers between 0 and 24. for
    // more info. Examples: - { pattern: 'day of week', bounds: [6, 1] }  or simply { bounds: ['sat', 'mon'] }   breaks
    // from Saturday to Monday (i.e. skips the weekends). - { pattern: 'hour', bounds: [17, 8] }   breaks from 5pm to
    // 8am (i.e. skips non-work hours).
    Layout::Yaxis::Rangebreaks::Rangebreak& pattern(enum Pattern f);

    // Used to refer to a named item in this array in the template. Named items from the template will be created even
    // without a matching item in the input figure, but you can modify one by making an item with `templateitemname`
    // matching its `name`, alongside your modifications (including `visible: false` or `enabled: false` to hide it). If
    // there is no template or no matching item, this item will be hidden unless you explicitly show it with `visible:
    // true`.
    Layout::Yaxis::Rangebreaks::Rangebreak& templateitemname(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Yaxis::Rangebreaks::Rangebreak& templateitemname(Callable&& c);

    // Sets the coordinate values corresponding to the rangebreaks. An alternative to `bounds`. Use `dvalue` to set the
    // size of the values along the axis.
    Layout::Yaxis::Rangebreaks::Rangebreak& values(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Yaxis::Rangebreaks::Rangebreak& values(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets the tick font.
class Layout::Yaxis::Tickfont {
 public:
    Tickfont() = default;
    Tickfont(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    enum class Textcase {
        Normal,
        WordCaps,
        Upper,
        Lower,
    };
    static std::string to_string(Textcase e);

    enum class Variant {
        Normal,
        SmallCaps,
        AllSmallCaps,
        AllPetiteCaps,
        PetiteCaps,
        Unicase,
    };
    static std::string to_string(Variant e);

    Layout::Yaxis::Tickfont& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Yaxis::Tickfont& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Yaxis::Tickfont& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Yaxis::Tickfont& family(Callable&& c);

    // Sets the kind of decoration line(s) with text, such as an *under*, *over* or *through* as well as combinations
    // e.g. *under+over*, etc.
    // - Default: none
    // - Flags: ['under', 'over', 'through']
    // - Extras ['none']
    Layout::Yaxis::Tickfont& lineposition(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Yaxis::Tickfont& lineposition(Callable&& c);

    // Sets the shape and color of the shadow behind text. *auto* places minimal shadow and applies contrast text font
    // color. See https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow for additional options.
    Layout::Yaxis::Tickfont& shadow(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Yaxis::Tickfont& shadow(Callable&& c);

    Layout::Yaxis::Tickfont& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Yaxis::Tickfont& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Yaxis::Tickfont& style(enum Style f);

    // Sets capitalization of text. It can be used to make text appear in all-uppercase or all-lowercase, or with each
    // word capitalized.
    // - Default: normal
    Layout::Yaxis::Tickfont& textcase(enum Textcase f);

    // Sets the variant of the font.
    // - Default: normal
    Layout::Yaxis::Tickfont& variant(enum Variant f);

    // Sets the weight (or boldness) of the font.
    Layout::Yaxis::Tickfont& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Yaxis::Tickfont& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Yaxis::Tickformatstops {
 public:
    Tickformatstops() = default;
    Tickformatstops(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    class Tickformatstop;

    Layout::Yaxis::Tickformatstops& tickformatstop(Tickformatstop f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Tickformatstop&>>>
    Layout::Yaxis::Tickformatstops& tickformatstop(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Yaxis::Tickformatstops::Tickformatstop {
 public:
    Tickformatstop() = default;
    Tickformatstop(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // range [*min*, *max*], where *min*, *max* - dtick values which describe some zoom level, it is possible to omit
    // *min* or *max* value by passing *null*
    Layout::Yaxis::Tickformatstops::Tickformatstop& dtickrange(const std::vector<double>& f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::vector<double>&>>>
    Layout::Yaxis::Tickformatstops::Tickformatstop& dtickrange(Callable&& c);

    // Determines whether or not this stop is used. If `false`, this stop is ignored even within its `dtickrange`.
    Layout::Yaxis::Tickformatstops::Tickformatstop& enabled(bool f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, bool&>>>
    Layout::Yaxis::Tickformatstops::Tickformatstop& enabled(Callable&& c);

    // When used in a template, named items are created in the output figure in addition to any items the figure already
    // has in this array. You can modify these items in the output figure by making your own item with
    // `templateitemname` matching this `name` alongside your modifications (including `visible: false` or `enabled:
    // false` to hide it). Has no effect outside of a template.
    Layout::Yaxis::Tickformatstops::Tickformatstop& name(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Yaxis::Tickformatstops::Tickformatstop& name(Callable&& c);

    // Used to refer to a named item in this array in the template. Named items from the template will be created even
    // without a matching item in the input figure, but you can modify one by making an item with `templateitemname`
    // matching its `name`, alongside your modifications (including `visible: false` or `enabled: false` to hide it). If
    // there is no template or no matching item, this item will be hidden unless you explicitly show it with `visible:
    // true`.
    Layout::Yaxis::Tickformatstops::Tickformatstop& templateitemname(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Yaxis::Tickformatstops::Tickformatstop& templateitemname(Callable&& c);

    // string - dtickformat for described zoom level, the same as *tickformat*
    Layout::Yaxis::Tickformatstops::Tickformatstop& value(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Yaxis::Tickformatstops::Tickformatstop& value(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

class Layout::Yaxis::Title {
 public:
    Title() = default;
    Title(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    // Sets this axis' title font.
    class Font;

    // Sets this axis' title font.
    Layout::Yaxis::Title& font(Font f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, Font&>>>
    Layout::Yaxis::Title& font(Callable&& c);

    // Sets the standoff distance (in px) between the axis labels and the title text The default value is a function of
    // the axis tick labels, the title `font.size` and the axis `linewidth`. Note that the axis title position is always
    // constrained within the margins, so the actual standoff distance is always less than the set or default value. By
    // setting `standoff` and turning on `automargin`, plotly.js will push the margins to fit the axis title at given
    // standoff distance.
    Layout::Yaxis::Title& standoff(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Yaxis::Title& standoff(Callable&& c);

    // Sets the title of this axis.
    Layout::Yaxis::Title& text(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Yaxis::Title& text(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

// Sets this axis' title font.
class Layout::Yaxis::Title::Font {
 public:
    Font() = default;
    Font(std::string jsonStr)
    : json(parse(std::move(jsonStr))) {}

    enum class Style {
        Normal,
        Italic,
    };
    static std::string to_string(Style e);

    enum class Textcase {
        Normal,
        WordCaps,
        Upper,
        Lower,
    };
    static std::string to_string(Textcase e);

    enum class Variant {
        Normal,
        SmallCaps,
        AllSmallCaps,
        AllPetiteCaps,
        PetiteCaps,
        Unicase,
    };
    static std::string to_string(Variant e);

    Layout::Yaxis::Title::Font& color(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Yaxis::Title::Font& color(Callable&& c);

    // HTML font family - the typeface that will be applied by the web browser. The web browser will only be able to
    // apply a font if it is available on the system which it operates. Provide multiple font families, separated by
    // commas, to indicate the preference in which to apply fonts if they aren't available on the system. The Chart
    // Studio Cloud (at https://chart-studio.plotly.com or on-premise) generates images on a server, where only a select
    // number of fonts are installed and supported. These include *Arial*, *Balto*, *Courier New*, *Droid Sans*, *Droid
    // Serif*, *Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*, *PT Sans Narrow*,
    // *Raleway*, *Times New Roman*.
    Layout::Yaxis::Title::Font& family(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Yaxis::Title::Font& family(Callable&& c);

    // Sets the kind of decoration line(s) with text, such as an *under*, *over* or *through* as well as combinations
    // e.g. *under+over*, etc.
    // - Default: none
    // - Flags: ['under', 'over', 'through']
    // - Extras ['none']
    Layout::Yaxis::Title::Font& lineposition(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Yaxis::Title::Font& lineposition(Callable&& c);

    // Sets the shape and color of the shadow behind text. *auto* places minimal shadow and applies contrast text font
    // color. See https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow for additional options.
    Layout::Yaxis::Title::Font& shadow(std::string f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, std::string&>>>
    Layout::Yaxis::Title::Font& shadow(Callable&& c);

    Layout::Yaxis::Title::Font& size(double f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, double&>>>
    Layout::Yaxis::Title::Font& size(Callable&& c);

    // Sets whether a font should be styled with a normal or italic face from its family.
    // - Default: normal
    Layout::Yaxis::Title::Font& style(enum Style f);

    // Sets capitalization of text. It can be used to make text appear in all-uppercase or all-lowercase, or with each
    // word capitalized.
    // - Default: normal
    Layout::Yaxis::Title::Font& textcase(enum Textcase f);

    // Sets the variant of the font.
    // - Default: normal
    Layout::Yaxis::Title::Font& variant(enum Variant f);

    // Sets the weight (or boldness) of the font.
    Layout::Yaxis::Title::Font& weight(int f);
    template <typename Callable, typename = std::enable_if_t<std::is_invocable_v<Callable, int&>>>
    Layout::Yaxis::Title::Font& weight(Callable&& c);

    // Advanced users may modify the JSON representation directly, at their own peril!
    Json json{};
};

} // namespace plotlypp

#include "impl/layout_impl.hpp"
